## 第四章

## 面向游戏开发者的 Android

Android 的应用程序框架庞大，有时令人困惑。对于你能想到的每一个可能的任务，都有一个你可以使用的 API。当然，你必须先学习 API。幸运的是，我们游戏开发者只需要非常有限的一组 API。我们想要的只是一个有单一 UI 组件的窗口，我们可以在其中绘图，从那里我们可以接收输入，以及播放音频的能力。这涵盖了我们实现上一章设计的游戏框架的所有需求，并且是以一种平台无关的方式。

在这一章中，你将学到实现 Nom 先生所需的最少数量的 Android APIs。您会惊讶地发现，要实现这个目标，您实际上只需要了解这些 API。让我们回忆一下我们需要哪些原料:

*   窗口管理
*   投入
*   文件输入输出
*   声音的
*   制图法

对于这些模块中的每一个，在应用程序框架 API 中都有一个对应的模块。我们将挑选处理这些模块所需的 API，讨论它们的内部结构，最后实现我们在上一章设计的游戏框架的各个接口。

然而，在我们深入 Android 上的窗口管理之前，我们必须回顾一下我们在第 2 章中简单讨论过的东西:通过清单文件定义我们的应用程序。

### 定义一个 Android 应用程序:清单文件

一个 Android 应用程序可以由许多不同的组件组成:

> *Activities:* 这些是面向用户的组件，提供一个可以与之交互的 UI。
> 
> *服务:*这些是在后台工作的进程，没有可见的用户界面。例如，服务可能负责轮询邮件服务器以获取新的电子邮件。
> 
> *内容提供者:*这些组件使您的部分应用程序数据对其他应用程序可用。
> 
> *意图:*这些是由系统或应用程序自己创建的消息。然后，它们被传递给任何感兴趣的一方。意图可能会通知我们系统事件，如 SD 卡被移除或 USB 电缆被连接。意图也被系统用来启动我们的应用程序的组件，比如活动。我们还可以触发自己的意图，要求其他应用程序执行某个操作，比如打开照片库来显示图像，或者启动相机应用程序来拍照。
> 
> *广播接收器:*这些接收器对特定的意图做出反应，它们可能会执行一个动作，比如开始一个特定的活动或者向系统发出另一个意图。

Android 应用程序没有单一的入口点，就像我们习惯在桌面操作系统上拥有的那样(例如，以 Java 的`main()`方法的形式)。取而代之的是，Android 应用程序的组件被启动或被要求执行特定意图的特定动作。

应用程序的清单文件中定义了我们的应用程序由哪些组件组成，以及这些组件对哪些意图做出反应。Android 系统使用这个清单文件来了解我们的应用程序是由什么组成的，比如应用程序启动时显示的默认活动。

**注意:**我们只关心本书中的活动，所以我们只讨论这种类型组件的清单文件的相关部分。如果你想让自己晕头转向，你可以在 Android 开发者网站上了解更多关于 manifest 文件的信息。

清单文件不仅仅用于定义应用程序的组件。以下列表总结了游戏开发环境中清单文件的相关部分:

*   在 Android Market 上显示和使用的应用程序版本
*   我们的应用程序可以运行的 Android 版本
*   我们的应用需要的硬件配置文件(即多点触摸、特定的屏幕分辨率或对 OpenGL ES 2.0 的支持)
*   使用特定组件的权限，例如写入 SD 卡或访问网络堆栈

我们将在下面的小节中创建一个模板清单，我们可以在本书的所有项目中以稍微修改的方式重用它。为此，我们将浏览定义应用程序所需的所有相关 XML 标记。

#### <显现>元素

标签是一个文件的根元素。这里有一个基本的例子:

`<manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="com.helloworld"
      android:versionCode="1"
      android:versionName="1.0"
      android:installLocation="preferExternal">
…
</manifest>`

我们假设您以前使用过 XML，所以您应该熟悉第一行。`<manifest>`标签指定了一个名为`android`的名称空间，该名称空间在清单文件的其余部分中使用。`package`属性定义了我们的应用程序的根包名。稍后，我们将引用与这个包名相关的应用程序的特定类。

`versionCode`和`versionName`属性以两种形式指定了应用程序的版本。`versionCode`是一个整数，每次我们发布应用程序的新版本时，它都要增加。Android Market 使用它来跟踪我们的应用程序的版本。当 Android Market 的用户浏览我们的应用程序时,`versionName`会显示给他们。我们可以在这里使用任何我们喜欢的字符串。

只有当我们在 Eclipse 中将 Android 项目的构建目标设置为 Android 2.2 或更新版本时，`installLocation`属性才可用。它指定了我们的应用程序应该安装在哪里。字符串`preferExternal`告诉系统我们希望我们的应用程序安装到 SD 卡上。这只适用于 Android 2.2 或更高版本，所有早期的 Android 应用程序都会忽略该字符串。在 Android 2.2 或更高版本中，应用程序总是会尽可能地安装到内部存储中。

清单文件中 XML 元素的所有属性通常都以名称空间`android`为前缀，如前所示。为了简洁起见，在下面的部分中，当谈到特定的属性时，我们将不指定名称空间。

在`<manifest>`元素中，我们定义了应用程序的组件、权限、硬件配置文件和支持的 Android 版本。

#### 应用元素

与`<manifest>`元素的情况一样，让我们以示例的形式来讨论`<application>`元素:

`<application android:icon=*"@drawable/icon" android:label="@string/app_name"*
android:debuggable="*true"*>
…
</application>`

这看起来是不是有点奇怪？`@drawable/icon`和`@string/app_name`弦是怎么回事？在开发一个标准的 Android 应用程序时，我们通常会编写大量的 XML 文件，每个文件都定义了应用程序的一个特定部分。这些部分的完整定义要求我们还能够引用 XML 文件中没有定义的资源，比如图像或国际化字符串。这些资源位于`res/`文件夹的子文件夹中，正如我们在 Eclipse 中剖析 Hello World 项目时在[第 2 章](02.html#ch2)中所讨论的。

为了引用资源，我们使用前面的符号。`@`指定我们想要引用在别处定义的资源。下面的字符串标识了我们想要引用的资源的类型，它直接映射到`res/`目录中的一个文件夹或文件。最后一部分指定了资源的名称。在前面的例子中，这是一个名为`icon`的图像和一个名为`app_name`的字符串。在图像的情况下，它是我们指定的实际文件名，在`res/drawable/`文件夹中找到。请注意，图像名称没有像`.png`或`.jpg`这样的后缀。Android 会根据`res/drawable/`文件夹中的内容自动推断后缀。在`res/values/strings.xml`文件中定义了`app_name`字符串，该文件将存储应用程序使用的所有字符串。字符串的名称在`strings.xml`文件中定义。

**注意:**Android 上的资源处理非常灵活，但也很复杂。对于这本书，我们决定跳过大部分资源处理，原因有两个:这对游戏开发来说完全是大材小用，我们想完全控制我们的资源。Android 有修改放置在`res/`文件夹中的资源的习惯，尤其是图片(称为 drawables)。这是我们作为游戏开发者不希望看到的。我们建议 Android 资源系统在游戏开发中的唯一用途是国际化字符串。我们不会在本书中深入探讨这一点；相反，我们将使用对游戏开发更友好的`assets/`文件夹，它不影响我们的资源，并允许我们指定自己的文件夹层次结构。

现在,`<application>`元素属性的含义应该变得更清楚了。`icon`属性指定来自`res/drawable/`文件夹的图像用作应用程序的图标。该图标将显示在 Android Market 以及设备上的应用程序启动器中。它也是我们在`<application>`元素中定义的所有活动的默认图标。

`label`属性指定在应用程序启动器中为我们的应用程序显示的字符串。在前面的例子中，它引用了 `res/values/string.xml`文件中的一个字符串，这是我们在 Eclipse 中创建 Android 项目时指定的。我们也可以将其设置为一个原始字符串，比如`My Super Awesome Game`。该标签也是我们在`<application>`元素中定义的所有活动的默认标签。标签将显示在我们的应用程序的标题栏中。

属性指定我们的应用程序是否可以被调试。对于开发，我们通常应该将此设置为`true`。当你把你的应用程序部署到市场上时，只需把它切换到`false`。如果不将此设置为`true`，您将无法在 Eclipse 中调试应用程序。

我们只讨论了可以为`<application>`元素指定的很小一部分属性。但是，这些对于我们的游戏开发需求来说已经足够了。如果你想知道更多，你可以在 Android 开发者的网站上找到完整的文档。

`<application>`元素包含所有应用程序组件的定义，包括活动和服务，以及使用的任何附加库。

#### <活动>元素

现在越来越有趣了。这是我们的提名先生游戏的一个假设的例子:

`<activity android:name=".*MrNomActivity*"
          android:label="*Mr. Nom*"
          android:screenOrientation="*portrait*"<
          android:configChanges="*keyboard|keyboardHidden|orientation*"<
    <intent-filter>
        <action *android:name="android.intent.action.MAIN*" />
        <category android:name="*android.intent.category.LAUNCHER"* />
    </intent-filter>
</activity>`

我们先来看看`<activity>`标签的属性。

> `name`:这指定了相对于我们在`<manifest>`元素中指定的`package`属性的活动类的名称。您也可以在这里指定一个完全限定的类名。
> 
> `label`:我们已经在`<application>`中指定了相同的属性。该标签显示在活动的标题栏中(如果有)。如果我们定义的活动是应用程序的入口点，标签也将用作应用程序启动器中显示的文本。如果我们不指定它，将使用来自`<application>`元素的标签。注意，我们在这里使用了一个原始字符串，而不是对`string.xml`文件中一个字符串的引用。
> 
> `screenOrientation`:该属性指定活动将使用的方向。这里我们为我们的提名先生游戏指定了`portrait`，它只能在肖像模式下工作。或者，如果我们想在风景模式下运行，我们可以指定`landscape`。这两种配置都将强制活动的方向在活动的生命周期中保持不变，不管设备实际上是如何定向的。如果我们忽略这个属性，那么活动将使用设备的当前方向，通常基于加速度计数据。这也意味着无论何时设备方向改变，活动都将被破坏并重新开始——这在游戏中是不可取的。我们通常将游戏活动的方向固定为横向或纵向模式。
> 
> `configChanges`:重新定位设备或滑出键盘被视为配置更改。在这种变化的情况下，Android 将销毁并重新启动我们的应用程序来适应这种变化。这在游戏中是不可取的。`<activity>`元素的`configChanges`属性来帮忙了。它允许我们指定我们想要自己处理的配置更改，而不破坏和重新创建我们的活动。通过使用`|`字符来连接它们，可以指定多个配置更改。在前面的例子中，我们自己处理变更`keyboard`、`keyboardHidden`和`orientation`。

与`<application>`元素一样，当然，您可以为`<activity>`元素指定更多的属性。对于游戏开发来说，我们摆脱了刚才讨论的四个属性。

现在，您可能已经注意到,`<activity>`元素不是空的，但是它包含另一个元素，该元素本身又包含两个元素。这些是干什么用的？

正如我们之前指出的，Android 上的应用程序没有单一的主入口点。相反，我们可以有多个活动和服务形式的入口点，这些入口点是由于系统或第三方应用程序发出的特定意图而启动的。不知何故，我们需要与 Android 沟通，我们的应用程序的哪些活动和服务将对特定意图做出反应(以及以何种方式)。这就是`<intent-filter>`元素发挥作用的地方。

在前面的例子中，我们指定了两种类型的意图过滤器:一个`<action>`和一个`<category>`。`<action>`元素告诉 Android 我们的活动是应用程序的主要入口。`<category>`元素指定我们希望将该活动添加到应用程序启动器中。这两个元素一起允许 Android 推断，当应用程序启动器中的图标被按下时，它应该开始特定的活动。

对于`<action>`和`<category>`元素，唯一指定的是`name`属性，它标识了活动将对其做出反应的意图。意图`android.intent.action.MAIN`是一个特殊的意图，Android 系统使用它来启动应用程序的主要活动。意图`android.intent.category.LAUNCHER`用于告诉 Android 应用程序的特定活动是否应该在应用程序启动器中有一个条目。

通常，我们只有一个活动指定这两个意图过滤器。然而，一个标准的 Android 应用程序几乎总是有多个活动，这些也需要在`manifest.xml`文件中定义。下面是这种子活动的定义示例:

`<activity android:name=".*MySubActivity*"
          android:label=“*Sub Activity Title*"
          android:screenOrientation="*portrait*">
          android:configChanges="*keyboard|keyboardHidden|orientation*"/>`

这里没有指定意图过滤器，只有我们之前讨论的活动的四个属性。当我们像这样定义一个活动时，它只对我们自己的应用程序可用。我们带着一种特殊的意图以编程方式开始这种类型的活动；比方说，当在一个活动中按下一个按钮来打开一个新的活动时。我们将在后面的章节中看到如何以编程方式启动一个活动。

总而言之，我们为一个活动指定了两个意图过滤器，这样它就成为了我们应用程序的主要入口点。对于所有其他活动，我们省略了意图过滤器规范，这样它们就在我们的应用程序内部。我们将以编程方式启动这些。

注意:如前所述，我们的游戏中只会有一个活动。该活动将具有与前面所示完全相同的意图过滤器规范。我们讨论如何指定多个活动的原因是，我们将在一分钟内创建一个具有多个活动的特殊示例应用程序。别担心，这很容易。

#### <使用权限>元素

我们现在离开`<application>`元素，回到我们通常定义为`<manifest>`元素的子元素的元素。其中一个元素是`<uses-permission>`元素。

Android 有一个复杂的安全模型。每个应用程序都运行在自己的进程和 VM 中，有自己的 Linux 用户和组，它不能影响其他应用程序。Android 还限制系统资源的使用，如网络设施、SD 卡和录音硬件。如果我们的应用程序想要使用这些系统资源，我们必须请求许可。这是通过`<uses-permission>`元素完成的。

权限总是具有以下形式，其中`string`指定我们想要被授予的权限的名称:

`<uses-permission android:name="string"/>`

以下是一些可能会派上用场的权限名称:

> 这允许我们使用录音硬件。
> 
> 这允许我们访问所有的网络 API，这样我们就可以从网上获取图片或者上传高分。
> 
> `android.permission.WRITE_EXTERNAL_STORAGE`:这允许我们读写外部存储器上的文件，通常是设备的 SD 卡。
> 
> 这允许我们获得一个所谓的唤醒锁。有了这个唤醒锁，如果屏幕有一段时间没有被触摸过，我们可以防止设备进入睡眠状态。例如，这可能发生在仅由加速度计控制的游戏中。
> 
> 这是一个非常有用的权限，因为它允许你获得非 gps 级别的访问权限，比如用户所在的国家，这对于语言默认和分析非常有用。
> 
> 这允许应用程序通过 NFC(近场通信)执行 I/O 操作，这对于涉及少量信息快速交换的各种游戏功能非常有用。

为了访问网络 API，我们将下面的元素指定为`<manifest>`元素的子元素:

`<uses-permission android:name="android.permission.INTERNET"/>`

对于任何额外的权限，我们只需添加更多的`<uses-permission>`元素。您可以指定更多的权限；我们再次建议您参考 Android 官方文档。我们只需要刚才讨论过的那套。

忘记添加访问 SD 卡等权限是常见的错误来源。它表现为设备日志中的一条消息，由于日志中的混乱，这条消息可能会存在而不被发现。考虑游戏需要的权限，并在最初创建项目时指定它们。

另一件要注意的事情是，当用户安装您的应用程序时，他或她将首先被要求检查您的应用程序需要的所有权限。许多用户会跳过这些，高兴地安装他们能找到的任何东西。一些用户对他们的决定更有意识，会详细检查权限。如果你请求可疑的许可，比如发送昂贵的短信或获取用户位置的能力，当你的应用程序上市时，你可能会在评论区收到用户的一些讨厌的反馈。如果你必须使用那些有问题的权限之一，你也应该在你的应用程序描述中告诉用户你为什么要使用它。最好的办法是首先避免这些权限，或者提供合法使用它们的功能。

#### <使用-特征>元素

如果你自己是一个 Android 用户，并且拥有一个旧版本的 Android 设备，比如 1.5，你会注意到一些很棒的应用程序不会出现在你设备上的 Android Market 应用程序中。其中一个原因可能是在应用程序的清单文件中使用了`<uses-feature>`元素。

Android Market 应用程序将根据您的硬件配置文件过滤所有可用的应用程序。使用`<uses-feature>`元素，应用程序可以指定它需要哪些硬件特性；比如多点触控或者支持 OpenGL ES 2.0。任何不具备指定功能的设备都将触发该过滤器，因此最终用户首先不会看到该应用程序。

一个`<uses-feature>`元素具有以下属性:

`<uses-feature android:name="*string*" android:required=["true" | "false"]
android:glEsVersion="integer" />`

`name`属性指定了特性本身。`required`属性告诉过滤器我们是否真的在所有情况下都需要这个特性，或者它只是一个很好的特性。最后一个属性是可选的，仅在需要特定的 OpenGL ES 版本时使用。

对于游戏开发者来说，以下功能最为重要:

> `android.hardware.touchscreen.multitouch`:这要求设备具有多点触摸屏幕，能够进行基本的多点触摸交互，例如捏放缩放等。这些类型的屏幕在独立跟踪多个手指方面存在问题，所以你必须评估这些功能是否足以满足你的游戏。
> 
> `android.hardware.touchscreen.multitouch.distinct`:这是最后一个功能的老大哥。这需要完整的多点触摸功能，适合于实现像屏幕上的虚拟双操纵杆这样的控制。

我们将在本章的后半部分研究多点触摸。现在，只要记住，当我们的游戏需要多点触摸屏幕时，我们可以通过指定一个具有前面的功能名称的`<uses-feature>`元素来剔除所有不支持该功能的设备，就像这样:

`<uses-feature android:name="*android.hardware.touchscreen.multitouch*"
android:required="true"/>`

游戏开发者要做的另一件有用的事情是指定需要哪个 OpenGL ES 版本。在本书中，我们将关注 OpenGL ES 1.0 和 1.1。对于这些，我们通常不指定一个`<uses-feature>`元素，因为它们彼此并没有太大的不同。然而，任何实现 OpenGL ES 2.0 的设备都可以被认为是图形发电站。如果我们的游戏在视觉上很复杂，需要大量的处理能力，我们可以要求 OpenGL ES 2.0，以便游戏只在能够以可接受的帧速率呈现令人惊叹的视觉效果的设备上显示。注意，我们没有使用 OpenGL ES 2.0，我们只是通过硬件类型进行过滤，以便我们的 OpenGL ES 1.x 代码获得足够的处理能力。我们可以这样做:

`<uses-feature android:glEsVersion="0x00020000"android:required="true"/>`

这将使我们的游戏只能在支持 OpenGL ES 2.0 的设备上显示，因此被认为具有相当强大的图形处理器。

**注意:**一些设备错误地报告了这个特性，这将使你的应用对其他完美的设备不可见。慎用。

假设您希望为您的游戏提供可选的 USB 外设支持，以便设备可以成为 USB 主机，并连接控制器或其他外设。正确的处理方式是添加:

`<uses-feature android:name="android.hardware.usb.host" android:required="false"/>`

设置“`android:required`”为假表示市场“我们可以使用这个功能，但没有必要下载和运行游戏。”设置可选硬件功能的使用是一种很好的方法，可以让你的游戏在各种你还没有遇到过的硬件上经得起时间考验。它允许制造商将应用程序限制在那些声明支持其特定硬件的应用程序中，如果你声明支持它，你将被包括在可以为该设备下载的应用程序中。

现在，你在硬件方面的每一个具体要求都有可能减少你的游戏可以安装的设备数量，这将直接影响你的销售。在指定以上任何一项之前，请三思。例如，如果你的游戏的标准模式需要多点触摸，但你也可以想办法让它在单点触摸设备上工作，你应该努力有两个代码路径——每个硬件配置文件一个——以便你的游戏可以部署到更大的市场。

#### <使用-sdk >元素

我们将放入清单文件的最后一个元素是`<uses-sdk>`元素。它是`<manifest>`元素的子元素。我们在[第 2 章](02.html#ch2)中创建 Hello World 项目时隐式定义了这个元素，并且在新的 Android 项目对话框中指定了 SDK 的最低版本。那么这个元素是做什么的呢？这里有一个例子:

`<uses-sdk android:minSdkVersion="3" android:targetSdkVersion="13"/>`

正如我们在[第二章](02.html#ch2)中讨论的，每个 Android 版本都有一个整数，也称为 SDK 版本。元素指定了我们的应用程序支持的最低版本和我们的应用程序的目标版本。在本例中，我们将最低版本定义为 Android 1.5，将目标版本定义为 Android 1.5，因为该元素允许我们将使用仅在较新版本中可用的 API 的应用程序部署到安装了较低版本的设备上。一个突出的例子是多点触摸 API，它从 SDK 版本 5 (Android 2.0)开始就受到支持。当我们在 Eclipse 中设置我们的 Android 项目时，我们使用支持该 API 的构建目标；比如 SDK 第 5 版或更高版本(我们通常设置为最新的 SDK 版本，编写时为 13)。如果我们希望我们的游戏也能在安装了 SDK 版本 3 (Android 1.5)的设备上运行，我们像以前一样在 manifest 文件中指定`minSdkVersion,`。当然，我们必须注意不要使用任何在较低版本中不可用的 API，至少在 1.5 设备上是这样。在更高版本的设备上，我们也可以使用更新的 API。

对于大多数游戏来说，前面的配置通常是好的(除非你不能为更高版本的 API 提供单独的回退代码路径，在这种情况下，你会想要将`minSdkVersion`属性设置为你实际支持的最低 SDK 版本)。

#### 安卓游戏项目设置十步走

现在让我们结合前面的所有信息，开发一个简单的逐步方法，在 Eclipse 中创建新的 Android 游戏项目。以下是我们希望从我们的项目中得到的:

*   它应该能够使用最新 SDK 版本的功能，同时保持与一些设备仍在运行的最低 SDK 版本的兼容性。那意味着我们要支持 Android 1.5 及以上版本。
*   如果可能的话，应该将它安装到 SD 卡上，这样我们就不会填满设备的内部存储空间。
*   它应该是可调试的。
*   它应该有一个单独的主活动，自己处理所有的配置更改，这样当硬件键盘暴露或者设备的方向改变时，它就不会被破坏。
*   活动应固定为纵向或横向模式。
*   它应该允许我们访问 SD 卡。
*   它应该能让我们得到一个唤醒锁。

利用你刚刚获得的信息，这些是一些容易实现的目标。以下是步骤:

1.  通过打开新的 Android 项目对话框，在 Eclipse 中创建新的 Android 项目，如第 2 章中所述。
2.  在 New Android Project 对话框中，指定项目的名称，并将构建目标设置为最新的可用 SDK 版本。
3.  在同一个对话框中，指定游戏的名称、存储所有类的包以及主活动的名称。然后将 SDK 的最低版本设置为 3。按“完成”使项目成为现实。
4.  打开`AndroidManifest.xml`文件。
5.  要让 Android 在 SD 卡可用时安装游戏，将`installLocation`属性添加到`<manifest>`元素，并将其设置为`preferExternal`。
6.  为了使游戏可调试，将`debuggable`属性添加到`<application>`元素中，并将其设置为`true`。
7.  要固定活动的方向，将`screenOrientation`属性添加到`<activity>`元素，并指定您想要的方向`(portrait`或`landscape`。
8.  为了告诉 Android 我们想要处理`keyboard`、`keyboardHidden`和`orientation`的配置更改，将`<activity>`元素的`configChanges`属性设置为`keyboard|keyboardHidden|orientation`。
9.  在`<manifest>`元素中添加两个`<uses-permission>`元素，并指定`name`属性`android.permission.WRITE_EXTERNALSTORAGE`和`android.permission.WAKE_LOCK`。
10.  最后，将`targetSdkVersion`属性添加到`<uses-sdk>`元素，并指定您的目标 SDK。它应该与您在步骤 1 中为构建目标指定的名称相同。

这就是了。十个简单的步骤将生成一个完全定义的应用程序，该应用程序将安装到 SD 卡上(在 Android 2.2 及更高版本上)，可调试，具有固定方向，不会在配置更改时爆炸，允许您访问 SD 卡和唤醒锁，并将在从 1.5 到最新版本的所有 Android 版本上工作。以下是执行上述步骤后的最终`AndroidManifest.xml`内容:

`<?xml version=*"1.0"* encoding=*"utf-8"*?>
<manifest xmlns:android=*"http://schemas.android.com/apk/res/android"*
      package=*"com.badlogic.awesomegame"*
      android:versionCode=*"1"*
      android:versionName=*"1.0"*
      android:installLocation=*"preferExternal"*>
    <application android:icon=*"@drawable/icon"*
                 android:label=*"Awesomnium"*
                 android:debuggable=*"true"*>
        <activity android:name=*".GameActivity"*
                  android:label=*"Awesomnium"*
                  android:screenOrientation=*"landscape"*
                  android:configChanges=*"keyboard|keyboardHidden|orientation"*>
            <intent-filter>
                <action android:name=*"android.intent.action.MAIN"* />
                <category android:name=*"android.intent.category.LAUNCHER"* />
            </intent-filter>
        </activity>
    </application>
    <uses-permission android:name=*"android.permission.WRITE_EXTERNAL_STORAGE"*/>
    <uses-permission android:name=*"android.permission.WAKE_LOCK"*/>
    <uses-sdk android:minSdkVersion=*"3"* android:targetSdkVersion=*"9"*/>
</manifest>`

如您所见，我们去掉了`<application>`和`<activity>`元素的标签属性中的`@string/app_name`。这不是真正必要的，但是最好将应用程序定义放在一个地方。从现在开始，一切都是为了代码！还是真的？

#### 市场过滤器

有这么多不同的 Android 设备，有这么多不同的功能，硬件制造商有必要只允许兼容的应用程序下载并在他们的设备上运行，否则用户会有尝试运行不兼容的应用程序的糟糕体验。为了解决这个问题，Android Market 从特定设备的可用应用程序列表中过滤掉不兼容的应用程序。例如，如果你有一个没有摄像头的设备，而你搜索一个需要摄像头的游戏，它就不会出现。不管是好是坏，对你这个用户来说，就好像这个应用程序不存在一样。

我们之前讨论的许多清单元素都被用作市场过滤器。除了我们讨论过的`<uses-feature>`、`<uses-sdk>`和`<uses-permission>`之外，还有一些特定于市场过滤的因素，您应该记住:

> 这允许你声明游戏可以运行的屏幕尺寸和密度。理想情况下，你的游戏可以在所有屏幕上运行，我们将向你展示如何做到这一点。但是，在清单中，您会希望尽可能明确地声明对每种屏幕尺寸的支持。
> 
> 这允许你在设备上声明对输入配置类型的显式支持，比如硬键盘、qwerty 专用键盘、触摸屏或者轨迹球导航输入。理想情况下，你会支持以上所有内容，但是如果你的游戏需要非常具体的输入，你会想要调查并使用这个标签进行市场过滤。
> 
> 这允许声明你的游戏所依赖的第三方库存在于设备上。例如，你可能需要一个非常大的文本到语音转换库，但是对于你的游戏来说非常普通。用这个标签声明这个库可以确保只有安装了这个库的设备才能看到和下载你的游戏。这样做的一个常见用途是允许基于 GPS/地图的游戏只能在安装了谷歌地图库的设备上运行。

随着 Android 的发展，可能会有更多的市场过滤器标签，所以在部署之前，请确保查看开发者网站上的官方市场过滤器页面以获得最新信息。

#### 定义你游戏的图标

当你把你的游戏部署到一个设备上，打开应用程序启动器，你会看到它的入口有一个漂亮的，但不是真正唯一的，Android 图标。你的游戏在市场上会显示同样的图标。如何将它更改为自定义图标？

再次仔细看看`<application>`元素。在那里，我们定义了一个名为`icon`的属性。它引用了`res/drawable`目录中一个名为`icon`的图像。所以，很明显应该怎么做:用你自己的图标图像替换`drawable`文件夹中的图标图像。

当你检查`res/`文件夹时，你会看到不止一个`drawable`文件夹，如图[图 4–1](#fig_4_1)所示。

![images](images/0401.jpg)

**图 4–1。** *我的 res/文件夹怎么了？*

这又是一个经典的先有鸡还是先有蛋的问题。在第 2 章的[中，在我们的 Hello World 项目中只有一个单独的`res/drawable`文件夹。这是因为我们将 SDK 版本 3 指定为我们的构建目标。该版本仅支持单一屏幕尺寸。Android 1.6 (SDK 版本 4)改变了这一点。我们在](02.html#ch2)[第一章](01.html#ch1)中看到设备可以有不同的尺寸，但是我们没有谈论 Android 如何处理这些。原来有一个精心设计的机制，允许你为一组所谓的屏幕密度定义你的图形资产。*屏幕密度*是物理屏幕尺寸和屏幕像素数的组合。我们将在后面的部分更详细地研究这个主题。现在，知道 Android 定义了三种密度就足够了:低密度屏幕的 ldpi、标准密度屏幕的 mdpi、高密度屏幕的 hdpi 和超高密度屏幕的 xhdpi。对于低密度的屏幕，我们通常使用较小的图像；对于更高密度的屏幕，我们使用高分辨率的资产。

因此，对于我们的图标，我们需要提供四个版本:每个密度一个。但是这些版本应该有多大呢？幸运的是，我们已经在`res/drawable`文件夹中有了默认图标，可以用来重新设计我们自己图标的大小。`res/drawable-ldpi`中的图标分辨率为 36×36 像素，`res/drawable-mdpi`中的图标分辨率为 48×48 像素，`res/drawable-hdpi`中的图标分辨率为 72×72 像素，`res/drawable-xhdpi`中的图标分辨率为 96×96 像素。我们需要做的就是用相同的分辨率创建自定义图标的版本，并用我们自己的`icon.png`文件替换每个文件夹中的`icon.png`文件。我们可以保持清单文件不变，只要我们调用我们的图标图像文件`icon.png`。请注意，清单文件中的文件引用区分大小写。为了安全起见，在资源文件中总是使用小写字母。

为了真正兼容 Android 1.5，我们需要添加一个名为`res/drawable/`的文件夹，并将来自`res/drawable-mdpi/`文件夹的图标图像放在那里。Android 1.5 不知道其他的`drawable`文件夹，所以它可能找不到我们的图标。

最后，我们准备完成一些 Android 编码。

### Android API 基础知识

在这一章的其余部分，我们将集中精力研究那些与我们游戏开发需求相关的 Android APIs。为此，我们将做一些相当方便的事情:我们将建立一个测试项目，该项目将包含我们将要使用的不同 API 的所有小测试示例。我们开始吧。

#### 创建测试项目

从上一节，我们已经知道如何设置我们所有的项目。所以，我们要做的第一件事就是执行前面列出的十个步骤。我们遵循这些步骤，创建了一个名为`ch04--android-basics`的项目，其中有一个名为`AndroidBasicsStarter`的主活动。我们将使用一些旧的和一些新的 API，所以我们将最低 SDK 版本设置为 3 (Android 1.5)，将构建目标和目标 SDK 版本设置为 9 (Android 2.3)。从现在开始，我们要做的就是创建新的 activity 实现，每个实现演示 Android APIs 的一部分。

但是，请记住，我们只有一个主要活动。那么，我们的主要活动是什么样的呢？我们需要一种方便的方式来添加新的活动，并且能够轻松地开始一个特定的活动。对于一个主要的活动，应该清楚的是，这个活动将会以某种方式为我们提供一个方法来开始一个特定的测试活动。如前所述，main 活动将被指定为清单文件中的主入口点。我们添加的每一个额外的活动都将在没有`<intent-filter>`子元素的情况下被指定。我们将从主活动中以编程方式启动它们。

##### AndroidBasicsStarter 活动

Android API 为我们提供了一个名为`ListActivity`的特殊类，它来自我们在 Hello World 项目中使用的`Activity`类。`ListActivity`是一种特殊类型的活动，它的唯一目的是显示一个事物列表(例如，字符串)。我们使用它来显示我们的测试活动的名称。当我们触摸其中一个列表项时，我们将以编程方式启动相应的活动。[清单 4–1](#list_4_1)显示了我们的`AndroidBasicsStarter`主活动的代码。

**清单 4–1。***AndroidBasicsStarter.java，我们的主要活动，负责列出并开始我们所有的测试*

`**package** com.badlogic.androidgames;

**import** android.app.ListActivity;
**import** android.content.Intent;
**import** android.os.Bundle;
**import** android.view.View;`
`**import** android.widget.ArrayAdapter;
**import** android.widget.ListView;

**publicclass** AndroidBasicsStarter **extends** ListActivity {
    String tests[] = { "LifeCycleTest", "SingleTouchTest", "MultiTouchTest",
            "KeyTest", "AccelerometerTest", "AssetsTest",
            "ExternalStorageTest", "SoundPoolTest", "MediaPlayerTest",
            "FullScreenTest", "RenderViewTest", "ShapeTest", "BitmapTest",
            "FontTest", "SurfaceViewTest" };

    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        setListAdapter(**new** ArrayAdapter&sLT;String>(**this**,
                android.R.layout.*simple_list_item_1*, tests));
    }

    @Override
    **protected void** onListItemClick(ListView list, View view, **int** position,
            **long** id) {
        **super**.onListItemClick(list, view, position, id);
        String testName = tests[position];
        **try** {
            Class clazz = Class
                    .*forName*("com.badlogic.androidgames." + testName);
            Intent intent = **new** Intent(**this**, clazz);
            startActivity(intent);
        } **catch** (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}`

我们选择的包名是`com.badlogic.androidgames`。导入也应该是不言自明的；这些就是我们将在代码中使用的所有类。我们的`AndroidBasicsStarter`类是从`ListActivity`类派生而来的——仍然没什么特别的。字段`tests`是一个字符串数组，它保存了我们的 starter 应用程序应该显示的所有测试活动的名称。请注意，数组中的名称正是我们稍后要实现的活动类的 Java 类名。

下一段代码应该是熟悉的；这是我们必须为我们的每个活动实现的`onCreate()`方法，当活动被创建时，它将被调用。记住我们必须调用我们活动的基类的`onCreate()`方法。这是我们在自己的`Activity`实现的`onCreate()`方法中必须做的第一件事。如果我们不这样做，将会抛出一个异常，并且不会显示该活动。

这样一来，我们接下来要做的就是调用一个名为`setListAdapter()`的方法。这个方法是由我们从中派生出来的`ListActivity`类提供给我们的。它让我们指定希望`ListActivity`为我们显示的列表项。这些需要以实现`ListAdapter`接口的类实例的形式传递给方法。我们使用方便的`ArrayAdapter`来做到这一点。这个类的构造函数有三个参数:第一个是我们的活动，第二个我们稍后会解释，第三个是`ListActivity`应该显示的项目数组。我们很高兴地为第三个参数指定了之前定义的`tests`数组，这就是我们需要做的。

那么`ArrayAdapter`构造函数的第二个参数是什么呢？为了解释这一点，我们不得不经历所有的 Android UI API 的东西，我们不打算在本书中使用。因此，我们不会在我们不需要的东西上浪费页面，而是给你一个简单明了的解释:列表中的每一项都通过一个`View`显示。该参数定义了每个`View`的布局，以及每个`View`的类型。值`android.R.layout.simple_list_item_1`是 UI API 提供的预定义常量，用于快速启动和运行。它代表将显示文本的标准列表项`View`。简单回顾一下，`View`是 Android 上的一个 UI 小部件，比如按钮、文本字段或滑块。我们在第 2 章中剖析[活动时谈到了这一点。](02.html#ch2)

如果我们仅用这个`onCreate()`方法开始我们的活动，我们将看到类似于图 4–2 所示的屏幕。

![images](images/0402.jpg)

**图 4–2。** *我们的测试启动活动，看起来很花哨，但还没做多少*

现在让我们在触摸列表项时发生一些事情。我们希望开始我们接触的列表项所代表的相应活动。

##### 以编程方式启动活动

`ListActivity`类有一个名为`onListItemClick()`的受保护方法，当点击一个项目时将调用该方法。我们所要做的就是在我们的`AndroidBasicsStarter`类中覆盖那个方法。这正是我们在[清单 4–1](#list_4_1)中所做的。

这个方法的参数是`ListActivity`用来显示项目的`ListView`、被触摸并包含在那个`ListView`中的`View`、被触摸项目在列表中的位置以及一个 ID，我们并不太感兴趣。我们真正关心的是`position`的争论。

`onListItemClicked()`方法从成为好公民开始，首先调用基类方法。如果我们覆盖一个活动的方法，这总是一件好事。接下来，我们根据`position`参数从`tests`数组中获取类名。这是拼图的第一部分。

前面，我们讨论过可以通过`Intent`以编程方式启动清单文件中定义的活动。`Intent`类有一个很好的简单的构造函数来做这件事，它有两个参数:一个`Context`实例和一个`Class`实例，代表我们想要启动的活动的 Java 类。

`Context`是一个为我们提供应用程序全局信息的接口。它是由`Activity`类实现的，所以我们简单地将这个引用传递给`Intent`构造函数。

为了获得表示我们想要开始的活动的`Class`实例，我们使用了一点反射，如果您使用过 Java，这可能会很熟悉。静态方法`Class.forName()`接受一个字符串，该字符串包含我们想要获得一个`Class`实例的类的全限定名。我们稍后将实现的所有测试活动都将包含在`com.badlogic.androidgames`包中。将包名与我们从`tests`数组中获取的类名连接起来，将会得到我们想要启动的活动类的全限定名。我们将该名称传递给`Class.forName()`，并获得一个漂亮的`Class`实例，我们可以将它传递给`Intent`构造函数。

一旦构造了`Intent`，我们就可以通过调用`startActivity()`方法来启动它。这个方法也在`Context`接口中定义。因为我们的活动实现了那个接口，所以我们只调用它的那个方法的实现。就这样！

那么我们的应用程序将如何表现呢？首先，将显示启动器活动。每次我们触摸列表上的一个项目，相应的活动就会启动。启动活动将暂停并进入后台。新活动将由我们发出的意向创建，并将替换屏幕上的起始活动。当我们按下手机上的 back 按钮时，活动被破坏，starter 活动恢复，收回屏幕。

##### 创建测试活动

当我们创建一个新的测试活动时，我们必须执行以下步骤:

1.  在`com.badlogic.androidgames`包中创建相应的 Java 类，并实现其逻辑。
2.  在清单文件中为它添加一个条目，使用它需要的任何属性(即，`android:configChanges`或`android:screenOrientation`)。注意，我们不会指定一个`<intent-filter>`元素，因为我们将以编程方式启动活动。
3.  将活动的类名添加到`AndroidBasicsStarter`类的`tests`数组中。

只要我们坚持这个过程，其他一切都将由我们在`AndroidBasicsStarter`类中实现的逻辑来处理。新的活动会自动出现在列表中，只需轻轻一触就能启动。

您可能想知道的一件事是，在 touch 上开始的测试活动是否在它自己的进程和 VM 中运行。不是的。由活动组成的应用程序有一个叫做*活动栈*的东西。每次我们开始一个新的活动，它就会被推到堆栈上。当我们关闭新的活动时，最后一个推入堆栈的活动将被弹出并恢复，成为屏幕上新的活动活动。

这也有一些其他的含义。首先，应用程序的所有活动(堆栈上暂停的活动和活动的活动)共享同一个 VM。它们还共享同一个内存堆。这可能是福也可能是祸。如果您的活动中有静态字段，它们一启动就会在堆上获得内存。作为静态字段，它们将在活动的销毁和活动实例的后续垃圾收集中幸存。如果您不小心使用静态字段，这可能会导致一些糟糕的内存泄漏。在使用静态字段之前要三思。

正如已经说过几次的，我们在实际的游戏中只会有一个活动。前面的活动启动器是这个规则的一个例外，让我们的生活变得更轻松。但是不用担心；即使是一项活动，我们也有很多机会陷入困境。

**注意:**这是我们将要深入研究的 Android UI 编程。从现在开始，我们将总是在活动中使用单个`View`来输出内容和接收输入。如果你想了解布局、视图组和 Android UI 库提供的所有功能，我们建议你看看马克·墨菲的书《Android 2*入门》(2010 年出版)，或者 Android 开发者网站上的优秀开发者指南。*

#### 活动生命周期

在为 Android 编程时，我们首先要弄清楚的是一个活动是如何表现的。在 Android 上，这被称为*活动生命周期*。它描述了活动所处的状态以及这些状态之间的转换。我们先来讨论一下这背后的理论。

##### 理论上

活动可以处于以下三种状态之一:

> *运行*:在这种状态下，占据屏幕并直接与用户交互的是顶层活动。
> 
> *暂停*:当活动在屏幕上仍然可见，但被透明活动或对话框部分遮挡，或者手机屏幕被锁定时，会出现这种情况。Android 系统可以在任何时间点终止暂停的活动(例如，由于内存不足)。请注意，活动实例本身仍然活跃在 VM 堆中，并等待返回到运行状态。
> 
> *Stopped* :当一个活动被另一个活动完全遮挡，从而在屏幕上不再可见时，就会出现这种情况。例如，如果我们开始一个测试活动，我们的`AndroidBasicsStarter`活动将处于这种状态。当用户按下主屏幕按钮暂时转到主屏幕时，也会发生这种情况。如果内存不足，系统可以再次决定完全终止该活动并将其从内存中删除。

在暂停和停止状态下，Android 系统可以决定在任何时间点终止活动。它可以礼貌地这样做，首先通过调用它的`finished()`方法来通知活动，或者不做坏事，悄悄地终止它的进程。

活动可以从暂停或停止状态返回到运行状态。再次注意，当活动从暂停或停止状态恢复时，它仍然是内存中的同一个 Java 实例，因此所有状态和成员变量都与活动暂停或停止前相同。

活动有一些受保护的方法，我们可以覆盖这些方法来获取有关状态更改的信息:

> 第一次启动我们的活动时会调用这个函数。在这里，我们设置所有的 UI 组件并连接到输入系统。这在我们活动的生命周期中只会被调用一次。
> 
> `Activity.onRestart()`:当活动从停止状态恢复时调用。它之前是对`onStop()`的调用。
> 
> `Activity.onStart()`:在`onCreate()`之后或者当活动从停止状态恢复时调用。在后一种情况下，它之前是一个调用`onRestart()`。
> 
> `Activity.onResume()`:在`onStart()`之后或当活动从暂停状态恢复时调用(例如当屏幕解锁时)。
> 
> `Activity.onPause()`:当活动进入暂停状态时调用。这可能是我们收到的最后一个通知，因为 Android 系统可能会决定悄悄地杀死我们的应用程序。我们要用这种方法保存所有我们想坚持的状态！
> 
> `Activity.onStop()`:当活动进入停止状态时调用。它之前是对`onPause()`的调用。这意味着，在活动停止之前，它会先暂停。和`onPause()`一样，这可能是我们在安卓系统无声无息地终止活动之前收到的最后一个通知。我们也可以在这里保存持久状态。然而，系统可能决定不调用这个方法，而只是终止活动。由于`onPause()`总是会在`onStop()`之前被调用，在活动被无声地杀死之前，我们宁愿在`onPause()`方法中保存我们所有的东西。
> 
> `Activity.onDestroy()`:这在活动生命周期结束时被调用，此时活动被不可撤销地销毁。这是我们最后一次保存任何信息，以便在下次重新创建活动时恢复。注意，如果活动在系统调用了`onPause()`或`onStop()`后被静默销毁，这个方法可能永远不会被调用。

[图 4–3](#fig_4_3)说明了活动生命周期和方法调用顺序。

![images](images/0403.jpg)

**图 4–3。** *浩浩荡荡、令人困惑的活动生命周期*

下面是我们应该从中吸取的三大教训:

1.  在我们的活动进入运行状态之前，`onResume()`方法总是被调用，不管我们是从停止状态还是暂停状态恢复。因此，我们可以放心地忽略`onRestart()`和`onStart()`方法。我们不关心是从停止状态还是暂停状态恢复。对于我们的游戏，我们只需要知道我们现在实际上正在运行，`onResume`()方法向我们发出信号。
2.  活动可以在`onPause()`之后无声无息的销毁。我们永远都不应该假设`onStop()`或`onDestroy()`会被叫到。我们也知道`onPause()`总是在`onStop()`之前被调用。因此，我们可以安全地忽略`onStop()`和`onDestroy()`方法，只覆盖`onPause()`。在这种方法中，我们必须确保我们想要保持的所有状态，比如高分和等级进步，都被写入外部存储器，比如 SD 卡。在`onPause()`之后，所有的赌注都结束了，我们不知道我们的活动是否还有机会再次运行。
3.  我们知道，如果系统决定在`onPause()`或`onStop()`之后终止活动，那么`onDestroy()`可能永远不会被调用。然而，有时我们想知道活动是否真的会被扼杀。那么，如果`onDestroy()`不会被调用，我们该怎么做呢？`Activity`类有一个叫做`Activity.isFinishing()`的方法，我们可以随时调用它来检查我们的活动是否会被终止。我们至少可以保证在活动被终止之前调用了`onPause()`方法。我们需要做的就是在`onPause()`方法中调用这个`isFinishing()`方法，以决定活动是否会在`onPause()`调用后死亡。

这让生活变得简单多了。我们只覆盖了`onCreate()`、`onResume()`和`onPause()`方法。

*   在`onCreate()`中，我们设置我们的窗口和 UI 组件，我们向其呈现并从其接收输入。
*   在`onResume()`中，我们(重新)开始我们的主循环线程(在上一章中讨论过)。
*   在`onPause()`中，我们简单地暂停我们的主循环线程，如果`Activity.isFinishing()`返回`true`，我们也保存任何我们想要保存到磁盘的状态。

许多人纠结于活动生命周期，但是如果我们遵循这些简单的规则，我们的游戏将能够处理暂停和恢复以及清理。

##### 在实践中

让我们编写演示活动生命周期的第一个测试示例。我们希望有某种输出来显示到目前为止发生了哪些状态变化。我们将通过两种方式做到这一点:

1.  活动将显示的唯一 UI 组件是所谓的`TextView`。它显示文本，我们已经在 starter 活动中隐式地使用它来显示每个条目。每次我们进入一个新的状态，我们都会向`TextView`添加一个字符串，它将显示到目前为止发生的所有状态变化。
2.  因为我们不能在`TextView`中显示我们活动的破坏事件，因为它会很快从屏幕上消失，所以我们也将所有状态变化输出到`LogCat`。我们用`Log`类来实现这一点，它提供了两个静态方法来向`LogCat`添加消息。

记住我们需要做什么来添加一个测试活动到我们的测试应用程序中。首先，我们在清单文件中以`<activity>`元素的形式定义它，它是`<application>`元素的子元素:

`<activity android:label=*"Life Cycle Test"*
          android:name=*".LifeCycleTest"*
          android:configChanges=*"keyboard|keyboardHidden|orientation"*/>`

接下来，我们将名为`LifeCycleTest`的新 Java 类添加到我们的`com.badlogic.androidgames`包中。最后，我们将类名添加到前面定义的`AndroidBasicsStarter`类的`tests`成员中。(当然，当我们出于演示的目的编写这个类时，我们就已经有了。)

对于我们在接下来的部分中创建的任何测试活动，我们将不得不重复所有这些步骤。为简洁起见，我们不再提及这些步骤。还要注意，我们没有为`LifeCycleTest`活动指定方向。在本例中，我们可以处于横向或纵向模式，具体取决于设备方向。我们这样做是为了让您可以看到方向变化对生命周期的影响(没有，因为我们设置了`configChanges`属性)。[清单 4–2](#list_4_2)向您展示了整个活动的代码。

**清单 4–2。***【LifeCycleTest.java】，`Demonstrating the Activity Life Cycle`*

`**package** com.badlogic.androidgames;

**import** android.app.Activity;
**import** android.os.Bundle;
**import** android.util.Log;
**import** android.widget.TextView;

**publicclass** LifeCycleTest **extends** Activity {
    StringBuilder builder = **new** StringBuilder();
    TextView textView;

    **privatevoid** log(String text) {
        Log.*d*("LifeCycleTest", text);
        builder.append(text);`
`        builder.append('\n');
        textView.setText(builder.toString());
    }

    @Override
    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        textView = **new** TextView(**this**);
        textView.setText(builder.toString());
        setContentView(textView);
        log("created");
    }

    @Override
    **protected void** onResume() {
        **super**.onResume();
        log("resumed");
    }

    @Override
    **protected void** onPause() {
        **super**.onPause();
        log("paused");

        **if** (isFinishing()) {
            log("finishing");
        }
    }
}`

让我们快速浏览一下这段代码。该类源自`Activity`——这并不奇怪。我们定义了两个成员:一个是`StringBuilder`，它将保存我们到目前为止生成的所有消息，另一个是`TextView`，我们用它直接在`Activity`中显示这些消息。

接下来，我们定义一个小的私有 helper 方法，它将把文本记录到 LogCat，附加到我们的`StringBuilder`中，并更新`TextView`文本。对于 LogCat 输出，我们使用静态的`Log.d()`方法，该方法将一个标签作为第一个参数，将实际消息作为第二个参数。

在`onCreate()`方法中，我们像往常一样首先调用超类方法。我们创建了`TextView`,并将其设置为活动的内容视图。它将填满活动的整个空间。最后，我们将创建的消息记录到 LogCat 中，并用我们之前定义的助手方法`log()`更新`TextView`文本。

接下来，我们覆盖活动的`onResume()`方法。与我们覆盖的任何活动方法一样，我们首先调用超类方法。我们所做的就是用`resumed`作为参数再次调用`log()`。

被覆盖的`onPause()`方法看起来很像`onResume()`方法。我们首先将消息记录为“暂停”。我们还想知道在调用了`onPause()`方法之后，活动是否会被销毁，所以我们检查了`Activity.isFinishing()`方法。如果它返回`true`，我们也记录结束事件。当然，我们将无法看到更新后的`TextView`文本，因为在更改显示在屏幕上之前，活动将被销毁。因此，如前所述，我们也将所有内容输出到 LogCat。

运行应用程序，并稍微试验一下这个测试活动。以下是您可以执行的一系列操作:

1.  从启动活动启动测试活动。
2.  锁屏。
3.  解锁屏幕。
4.  按下主屏幕按钮(这将使你回到主屏幕)。
5.  在主屏幕上，按住主屏幕按钮，直到出现当前正在运行的应用程序。选择 Android 基础入门应用程序以继续(这将使测试活动回到屏幕上)。
6.  按 back 按钮(这将使您返回到 starter activity)。

如果您的系统没有决定在暂停时静默终止活动，您将会在[Figure 4–4](#fig_4_4)中看到输出(当然，前提是您还没有按下 back 按钮)。

![images](images/0404.jpg)

**图 4–4。** *运行生命周期测试活动*

启动时，调用`onCreate()`，然后调用`onResume()`。当我们锁定屏幕时，`onPause()`被调用。当我们解锁屏幕时，`onResume()`被调用。当我们按下 home 键时，`onPause()`被调用。回去活动会再叫`onResume()`。当然，相同的消息也显示在 LogCat 中，您可以在 LogCat 视图中观察到这些消息。[Figure 4–5](#fig_4_5)显示了我们在执行前面的动作序列(加上按下 back 按钮)时写入 LogCat 的内容。

![images](images/0405.jpg)

**图 4–5。** *生命周期测试的 LogCat 输出*

再次按下后退按钮调用`onPause()`方法。因为它也破坏了活动，所以`onPause()`中的条件也被触发，通知我们这是最后一次看到该活动。

这就是活动生命周期，去神秘化和简化了我们游戏编程的四个需求。我们现在可以轻松地处理任何暂停和恢复事件，并保证在活动被销毁时得到通知。

#### 输入设备处理

正如前面章节所讨论的，我们可以从 Android 上的许多不同的输入设备中获取信息。在这一节中，我们将讨论 Android 上三个最相关的输入设备以及如何使用它们:触摸屏、键盘和加速度计。

##### 获取(多点)触摸事件

触摸屏可能是获取用户输入的最重要的方式。在 Android 版本之前，API 只支持处理单指触摸事件。多点触控是在 Android 2.0 (SDK 版本 5)中引入的。多点触摸事件报告被标记在单触式 API 上，在可用性方面有一些混合的结果。我们将首先研究处理单点触摸事件，这在所有 Android 版本上都可用。

##### 处理单点触摸事件

当我们在第二章中处理点击按钮时，我们看到监听器接口是 Android 向我们报告事件的方式。触摸事件也不例外。触摸事件被传递给一个我们用一个`View`注册的`OnTouchListener`接口实现。`OnTouchListener`接口只有一个方法:

`public abstract boolean onTouch (View v, MotionEvent event)`

第一个参数是触摸事件被分派到的`View`。第二个参数是我们将分析以获得触摸事件的内容。

一个`OnTouchListener`可以通过`View.setOnTouchListener()`方法注册到任何一个`View`实现中。在`MotionEvent`被分派给`View`之前`OnTouchListener`将被调用。我们可以在`onTouch()`方法的实现中向`View`发出信号，表明我们已经通过从该方法返回`true`处理了事件。如果我们返回`false`，那么`View`本身将处理该事件。

`MotionEvent`实例有三个与我们相关的方法:

> `MotionEvent.getX()`和`MotionEvent.getY()`:这些方法报告触摸事件相对于`View`的 x 和 y 坐标。坐标系定义为原点在视图的左上方，x 轴指向右侧，y 轴指向下方。坐标以像素为单位。请注意，这些方法返回浮点数，因此坐标具有子像素精度。
> 
> `MotionEvent.getAction()`:返回触摸事件的类型。它是一个整数，取值为`MotionEvent.ACTION_DOWN`、`MotionEvent.ACTION_MOVE`、`MotionEvent.ACTION_CANCEL`和`MotionEvent.ACTION_UP`中的一个。

听起来很简单，事实也确实如此。当手指触摸屏幕时发生`MotionEvent.ACTION_DOWN`事件。当手指移动时，类型为`MotionEvent.ACTION_MOVE`的事件被触发。请注意，你总是会遇到`MotionEvent.ACTION_MOVE`事件，因为你无法保持手指不动来避免它们。触摸传感器将识别最轻微的变化。当手指再次抬起时，报告`MotionEvent.ACTION_UP`事件。`MotionEvent.ACTION_CANCEL`事件有点神秘。文档显示，当当前手势被取消时，它们将被触发。我们还从未在现实生活中见过这一事件。然而，当我们开始实现我们的第一个游戏时，我们仍然会处理它并假设它是一个`MotionEvent.ACTION_UP`事件。

让我们编写一个简单的测试活动，看看这在代码中是如何工作的。该活动应该显示手指在屏幕上的当前位置以及事件类型。[清单 4–3](#list_4_3)向您展示了我们的成果。

**清单 4–3。**SingleTouchTest.java*；测试单点触摸操作*

`**package** com.badlogic.androidgames;

**import** android.app.Activity;
**import** android.os.Bundle;
**import** android.util.Log;
**import** android.view.MotionEvent;
**import** android.view.View;
**import** android.view.View.OnTouchListener;
**import** android.widget.TextView;

**publicclass** SingleTouchTest **extends** Activity **implements** OnTouchListener {
    StringBuilder builder = **new** StringBuilder();
    TextView textView;`

`    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        textView = **new** TextView(**this**);
        textView.setText("Touch and drag (one finger only)!");
        textView.setOnTouchListener(**this**);
        setContentView(textView);
    }

    @Override
    **public boolean** onTouch(View v, MotionEvent event) {
        builder.setLength(0);
        **switch** (event.getAction()) {
        **case** MotionEvent.*ACTION_DOWN*:
            builder.append("down, ");
            **break**;
        **case** MotionEvent.*ACTION_MOVE*:
            builder.append("move, ");
            **break**;
        **case** MotionEvent.*ACTION_CANCEL*:
            builder.append("cancle, ");
            **break**;
        **case** MotionEvent.*ACTION_UP*:
            builder.append("up, ");
            **break**;
        }
        builder.append(event.getX());
        builder.append(", ");
        builder.append(event.getY());
        String text = builder.toString();
        Log.*d*("TouchTest", text);
        textView.setText(text);
        **returntrue**;
    }
}`

我们让我们的活动实现`OnTouchListener`接口。我们还有两个成员:一个用于`TextView`,另一个用于`StringBuilder`,我们将使用它们来构造事件字符串。

`onCreate()`方法非常简单明了。惟一的新颖之处是对`TextView.setOnTouchListener()`的调用，在这里我们向`TextView`注册我们的活动，以便它接收`MotionEvent` s

剩下的就是`onTouch()`方法实现本身。我们忽略了`view`参数，因为我们知道它一定是`TextView`。我们感兴趣的是获取触摸事件类型，将标识它的字符串附加到我们的`StringBuilder`，附加触摸坐标，并更新`TextView`文本。就这样。我们还将事件记录到 LogCat 中，这样我们可以看到事件发生的顺序，因为`TextView`将只显示我们处理的最后一个事件(每次调用`onTouch()`时，我们都会清除`StringBuilder`)。

`onTouch()`方法中一个微妙的细节是返回语句，我们在这里返回`true`。通常，我们会坚持侦听器的概念并返回`false`，以便不干扰事件调度过程。如果我们在示例中这样做，除了`MotionEvent.ACTION_DOWN`事件之外，我们不会得到任何其他事件。因此，我们告诉`TextView`我们刚刚消费了事件。不同的`View`实现之间的行为可能不同。幸运的是，在本书的其余部分，我们只需要其他三个视图，这些视图将让我们愉快地消费我们想要的任何事件。

如果我们在模拟器或连接的设备上启动这个应用程序，我们可以看到`TextView`总是显示最后一个事件类型和报告给`onTouch()`方法的位置。此外，您可以在 LogCat 中看到相同的消息。

我们没有修复清单文件中活动的方向。当然，如果您旋转设备，使活动处于横向模式，坐标系也会改变。[图 4–6](#fig_4_6)显示了纵向和横向模式下的活动。在这两种情况下，我们都试图触摸`View`的中间。注意 x 坐标和 y 坐标是如何交换的。该图还显示了这两种情况下的 x 轴和 y 轴(黄线)，以及我们在屏幕上粗略触摸的点(绿色圆圈)。在这两种情况下，原点都在`TextView`的左上角，x 轴指向右侧，y 轴指向下方。

![images](images/0406.jpg)

**图 4–6。** *在纵向和横向模式下触摸屏幕*

当然，根据方向的不同，我们的最大 x 和 y 值也会变化。前面的图片是在 Nexus One 上拍摄的，它的屏幕分辨率在纵向模式下为 480×800 像素(在横向模式下为 800×480 像素)。由于触摸坐标是相对于`View`给出的，并且由于视图没有填满整个屏幕，我们的最大 y 值将小于分辨率高度。稍后我们将看到如何启用全屏模式，以便标题栏和通知栏不会妨碍我们。

遗憾的是，旧版本 Android 和第一代设备上的触摸事件存在一些问题:

> *触摸事件泛滥*:当手指落在触摸屏上时，司机会报告尽可能多的触摸事件——在一些设备上每秒数百次。我们可以通过在我们的`onTouch()`方法中加入一个`Thread.sleep(16)`调用来解决这个问题，这将使那些事件被分派到的 UI 线程休眠 16 毫秒。这样的话，我们每秒最多可以处理 60 个事件，这对于一个反应灵敏的游戏来说已经足够了。这只是安卓 1.5 版本设备上的问题。
> 
> *触屏吃 CPU* :即使我们在`onTouch()`方法中睡眠，系统也要处理驱动程序报告的内核中的事件。在老设备上，比如 Hero 或 G1，这可以使用高达 50%的 CPU，这使得我们的主循环线程的处理能力大大降低。因此，我们完美的帧速率将会大大下降，有时会到游戏无法播放的程度。在第二代设备上，这个问题要小得多，通常可以忽略。遗憾的是，在旧设备上没有解决方案。

一般来说，你会想在所有的`onTouch()`方法中加入`Thread.sleep(16)`以确保万无一失。在较新的设备上，它将不起作用；在较旧的设备上，它至少可以防止触摸事件泛滥。

随着第一代设备慢慢消亡，随着时间的推移，这不再是一个问题。尽管如此，它仍然引起了游戏开发者的极大悲痛。试着向你的用户解释，你的游戏运行得像糖蜜一样，因为驱动程序中的某些东西耗尽了所有的 CPU。是啊，没人会在意。

##### 处理多点触摸事件

警告:前方剧痛！多点触摸 API 已经被标记到`MotionEvent`类中，该类最初只处理单点触摸。当试图解码多点触摸事件时，这造成了一些主要的混乱。让我们试着理解它。

**注意:**多点触控 API 显然也让创建它的 Android 工程师感到困惑。它在 SDK 版本 8 (Android 2.2)中得到了重大改进，增加了新方法、新常量，甚至重命名了常量。这些变化应该会让多点触控的使用变得更加容易。但是，它们仅从 SDK 版本 8 开始提供。为了支持所有支持多点触摸的 Android 版本(2.0 到 2.2.1)，我们必须使用 SDK 版本 5 的 API。

处理多点触摸与处理单点触摸事件非常相似。我们仍然实现了为单点触摸事件实现的相同的`OnTouchListener`接口。我们还获得了一个从其中读取数据的`MotionEvent`实例。我们还处理以前处理过的事件类型，比如`MotionEvent.ACTION_UP`，加上几个没什么大不了的新事件。

###### 指针 id 和索引

当我们想要访问触摸事件的坐标时，差异就开始了。`MotionEvent.getX()`和`MotionEvent.getY()`返回单个手指在屏幕上的坐标。当我们处理多点触摸事件时，我们使用这些方法的重载变体，它们采用所谓的*指针索引*。这可能如下所示:

`event.getX(pointerIndex);
event.getY(pointerIndex);`

现在，人们会期望`pointerIndex`直接对应于触摸屏幕的一个手指(例如，第一个放下的手指有`pointerIndex` 0，下一个放下的手指有`pointerIndex` 1，等等)。可悲的是，事实并非如此。

`pointerIndex`是对`MotionEvent`内部数组的索引，它保存了触摸屏幕的特定手指的事件坐标。手指在屏幕上的真实标识符叫做*指针标识符*。指针标识符是一个任意的数字，它唯一地标识一个指针接触到屏幕上的实例。有一个叫做`MotionEvent.getPointerIdentifier(int pointerIndex)`的独立方法，它基于指针索引返回指针标识符。只要单个手指接触屏幕，指针标识符将保持不变。指针索引不一定如此。重要的是要理解两者之间的区别，并理解你不能依赖于第一次触摸是索引 0，id 0，因为在一些设备上，特别是 Xperia Play 的第一个版本，指针 id 总是会增加到 15，然后从 0 开始，而不是重复使用 id 的最低可用数字。

让我们从研究如何到达一个事件的指针索引开始。我们现在将忽略事件类型。

`int pointerIndex = (event.getAction()& MotionEvent.ACTION_POINTER_ID_MASK) >>
MotionEvent.ACTION_POINTER_ID_SHIFT;`

当我们第一次实现它时，您可能会有同样的想法。在我们对人性失去信心之前，让我们试着破译这里发生了什么。我们通过`MotionEvent.getAction()`从`MotionEvent`获取事件类型。很好，我们以前做过。接下来，我们使用从`MotionEvent.getAction()`方法得到的整数和一个名为`MotionEvent.ACTION_POINTER_ID_MASK`的常数执行一个按位 AND 运算。现在好戏开始了。

该常量的值为`0xff00`，所以我们基本上把所有的位都设为 0，除了第 8 位到第 15 位，它们保存了事件的指针索引。由`event.getAction()`返回的整数的低八位保存事件类型的值，例如`MotionEvent.ACTION_DOWN`及其兄弟。通过这种位运算，我们实际上抛弃了事件类型。这种转变现在应该更有意义了。我们移位了值为 8 的`MotionEvent.ACTION_POINTER_ID_SHIFT`，所以我们基本上将第 8 位到第 15 位移动到第 0 位到第 7 位，到达事件的实际指针索引。这样，我们就可以获得事件的坐标，以及指针标识符。

注意，我们的神奇常数被称为`XXX_POINTER_ID_XXX`而不是`XXX_POINTER_INDEX_XXX`(这更有意义，因为我们实际上想要提取指针索引，而不是指针标识符)。好吧，安卓工程师一定也很困惑。在 SDK 版本 8 中，他们弃用了这些常量，并引入了名为`XXX_POINTER_INDEX_XXX`的新常量，这些常量与弃用的常量具有完全相同的值。为了让针对 SDK 第 5 版编写的遗留应用程序继续在较新的 Android 版本上工作，旧的常量当然仍然可用。

所以我们现在知道如何获得神秘的指针索引，我们可以用它来查询事件的坐标和指针标识符。

###### 动作掩码和更多事件类型

接下来，我们必须得到纯事件类型减去编码在由`MotionEvent.getAction()`返回的整数中的附加指针索引。我们只需要屏蔽掉指针索引:

`int action = event.getAction()& MotionEvent.ACTION_MASK;`

好吧，那很简单。遗憾的是，只有当你知道指针索引是什么，并且它实际上编码在动作中时，你才能理解它。

剩下的就是像我们之前做的那样解码事件类型。我们已经说过有一些新的事件类型，现在让我们来看一下:

> `MotionEvent.ACTION_POINTER_DOWN`:在第一个手指触摸屏幕后，任何其他手指触摸屏幕都会发生此事件。第一个手指仍然会产生一个`MotionEvent.ACTION_DOWN`事件。
> 
> `MotionEvent.ACTION_POINTER_UP`:这类似于前面的动作。当一个手指从屏幕上抬起，并且不止一个手指触摸屏幕时，就会触发这个事件。屏幕上最后一个抬起的手指将产生一个`MotionEvent.ACTION_UP`事件。这个手指不一定是触摸屏幕的第一个手指。

幸运的是，我们可以假设这两个新的事件类型与旧的`MotionEvent.ACTION_UP`和`MotionEvent.ACTION_DOWN`事件相同。

最后一个区别是，单个`MotionEvent`可以有多个事件的数据。是的，你没看错。为此，合并的事件必须具有相同的类型。实际上，这只会发生在`MotionEvent.ACTION_MOVE`事件上，所以我们只需要在处理所述事件类型时处理这个事实。为了检查单个`MotionEvent`中包含多少事件，我们使用`MotionEvent.getPointerCount()`方法，它告诉我们在`MotionEvent`中有坐标的手指的数量。然后，我们可以通过`MotionEvent.getX()`、`MotionEvent.getY()`和`MotionEvent.getPointerId()`方法获取指针标识符和指针索引 0 到`MotionEvent.getPointerCount() -- 1`的坐标。

###### 在实践中

让我们为这个优秀的 API 写一个例子。我们希望最多跟踪十个手指(还没有设备可以跟踪更多，所以我们在这里是安全的)。当我们在屏幕上添加更多手指时，Android 设备通常会分配连续的指针索引，但这并不总是有保证的，所以我们依赖于数组的指针索引，并将简单地显示哪个 id 分配给了触摸点。我们跟踪每个指针的坐标和触摸状态(触摸与否)，并通过`TextView`将这些信息输出到屏幕上。让我们称我们的测试活动为`MultiTouchTest`。[清单 4–4](#list_4_4)显示了完整的代码。

**清单 4–4。**MultiTouchTest.java*；测试多点触摸 API*

`**package** com.badlogic.androidgames;

**import** android.app.Activity;
**import** android.os.Bundle;
**import** android.view.MotionEvent;
**import** android.view.View;
**import** android.view.View.OnTouchListener;
**import** android.widget.TextView;

**public class** MultiTouchTest **extends** Activity **implements** OnTouchListener {
    StringBuilder builder = **new** StringBuilder();
    TextView textView;
    **float**[] x = **new float**[10];
    **float**[] y = **new float**[10];
    **boolean**[] touched = **new boolean**[10];
    **int**[] id = **new int**[10];

    **private void** updateTextView() {
        builder.setLength(0);
        **for** (**int** i = 0; i < 10; i++) {
            builder.append(touched[i]);
            builder.append(", ");
            builder.append(id[i]);
            builder.append(", ");
            builder.append(x[i]);
            builder.append(", ");
            builder.append(y[i]);
            builder.append("\n");
        }
        textView.setText(builder.toString());
    }

    **public void** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        textView = **new** TextView(**this**);
        textView.setText("Touch and drag (multiple fingers supported)!");
        textView.setOnTouchListener(**this**);
        setContentView(textView);
        **for** (**int** i = 0; i < 10; i++) {
            id[i] = -1;
        }`
`        updateTextView();
    }

    @Override
    **public boolean** onTouch(View v, MotionEvent event) {
        **int** action = event.getAction()& MotionEvent.*ACTION_MASK*;
        **int** pointerIndex = (event.getAction()& MotionEvent.*ACTION_POINTER_ID_MASK*) >>
MotionEvent.*ACTION_POINTER_ID_SHIFT*;
        **int** pointerCount = event.getPointerCount();
        **for** (**int** i = 0; i < 10; i++) {
            **if** (i >= pointerCount) {
                touched[i] = **false**;
                id[i] = -1;
                **continue**;
            }
            **if** (event.getAction() != MotionEvent.*ACTION_MOVE*&& i != pointerIndex) {
                // if it's an up/down/cancel/out event, mask the id to see if we should
process it for this touch point
                **continue**;
            }
            **int** pointerId = event.getPointerId(i);
            **switch** (action) {
            **case** MotionEvent.*ACTION_DOWN*:
            **case** MotionEvent.*ACTION_POINTER_DOWN*:
                touched[i] = **true**;
                id[i] = pointerId;
                x[i] = (**int**) event.getX(i);
                y[i] = (**int**) event.getY(i);
                **break**;

            **case** MotionEvent.*ACTION_UP*:
            **case** MotionEvent.*ACTION_POINTER_UP*:
    **case** MotionEvent.*ACTION_OUTSIDE*:
            **case** MotionEvent.*ACTION_CANCEL*:
                touched[i] = **false**;
                id[i] = -1;
                x[i] = (**int**) event.getX(i);
                y[i] = (**int**) event.getY(i);
                **break**;

            **case** MotionEvent.*ACTION_MOVE*:
                touched[i] = **true**;
                id[i] = pointerId;
                x[i] = (**int**) event.getX(i);
                y[i] = (**int**) event.getY(i);
                **break**;
            }
        }

        updateTextView();
        **return true**;
    }
}`

我们像以前一样实现了`OnTouchListener`接口。为了跟踪十个手指的坐标和触摸状态，我们添加了三个新的成员数组来保存这些信息。数组`x`和`y`保存每个指针 ID 的坐标，数组`touched`存储具有该指针 ID 的手指是否按下。

接下来，我们自由地创建一个小助手方法，将手指的当前状态输出到`TextView`。它简单地遍历所有十个手指状态，并通过一个`StringBuilder`将它们连接起来。最终文本被设置为`TextView`。

`onCreate()`方法设置我们的活动，并通过`TextView`将其注册为一个`OnTouchListener`。我们已经把那部分背熟了。

现在到了可怕的部分:`onTouch()`方法。

我们首先通过屏蔽由`event.getAction()`返回的整数来获取事件类型。接下来，我们提取指针索引，并从`MotionEvent`中获取相应的指针标识符，如前所述。

`onTouch()`方法的核心是那个讨厌的`switch`语句，我们已经用它的简化形式来处理单点触摸事件。我们将所有事件分为三大类:

*   发生了触地事件:(`MotionEvent.ACTION_DOWN`或`MotionEvent.ACTION_PONTER_DOWN`)。我们将指针标识符的触摸状态设置为`true`，并且我们还保存了指针的当前坐标。
*   发生了一个触发事件:(`MotionEvent.ACTION_UP`、`MotionEvent.ACTION_POINTER_UP`或`MotionEvent.CANCEL`)。我们将该指针标识符的触摸状态设置为`false`,并保存其最后已知的坐标。
*   一个或多个手指被拖过屏幕:(`MotionEvent.ACTION_MOVE`)。我们检查有多少事件包含在`MotionEvent`中，然后更新指针索引 0 到`MotionEvent.getPointerCount()-1`的坐标。对于每个事件，我们获取相应的指针标识符并更新坐标。

一旦事件被处理，我们通过调用我们之前定义的`updateView()`方法来更新`TextView`。最后我们返回`true`，表明我们处理了触摸事件。

[图 4–7](#fig_4_7)显示了在三星 Galaxy S 上触摸 5 个手指并稍微拖动它们所产生的活动输出。

![images](images/0407.jpg)

**图 4–7。** *多点触控的乐趣*

运行这个示例时，我们可以观察到一些情况:

*   如果我们在 Android 版本低于 2.0 的设备或模拟器上启动它，我们会得到一个令人讨厌的异常，因为我们使用了一个在那些早期版本上不可用的 API。我们可以通过确定应用程序运行的 Android 版本来解决这个问题，在运行 Android 1.5 和 1.6 的设备上使用单触代码，在运行 Android 2.0 或更高版本的设备上使用多触代码。我们将在下一章回到这一点。
*   模拟器上没有多点触摸。如果我们创建一个运行 Android 或更高版本的仿真器，API 就在那里，但我们只有一个鼠标。即使我们有两只老鼠，也不会有什么不同。
*   向下触摸两个手指，抬起第一个手指，然后再次向下触摸。在第一个手指抬起后，第二个手指将保持其指针标识符。当第一个手指第二次按下时，它会获得一个新的指针标识符，通常为 0，但可以是任何整数。任何触摸屏幕的新手指都将获得一个新的指针标识符，该标识符可以是当前没有被另一个活动触摸使用的任何东西。这是一条需要记住的规则。
*   如果你在 Nexus One 或 Droid 上尝试这样做，你会注意到当你在一个轴上交叉两个手指时会出现一些奇怪的行为。这是因为这些设备的屏幕不完全支持对单个手指的跟踪。这是一个大问题，但是我们可以通过精心设计我们的 ui 来解决它。我们将在下一章中再来看这个问题。要记住的一句话是:*不要过河拆桥！*

这就是多点触摸处理在 Android 上的工作方式。这是一件痛苦的事情，但是一旦你解开了所有的术语，并且平静地接受了这种无聊的事情，你就会对实现感到更加舒服，并且会像专家一样处理所有的接触点。

**注:**如果这让你的头爆炸了，我们很抱歉。这部分任务相当繁重。遗憾的是，该 API 的官方文档极其缺乏，大多数人只是通过简单地钻研来“学习”该 API。我们建议您尝试一下前面的代码示例，直到您完全理解其中的内容。

##### 处理关键事件

经过上一节的疯狂，我们应该得到一些非常简单的东西。欢迎处理关键事件。

为了捕捉关键事件，我们实现了另一个监听器接口，称为`OnKeyListener`。它有一个名为`onKey()`的方法，其签名如下:

`public boolean onKey(View view, int keyCode, KeyEvent event)`

`View`指定接收按键事件的视图，`keyCode`参数是在`KeyEvent`类中定义的常量之一，最后一个参数是按键事件本身，它有一些附加信息。

什么是关键代码？(屏幕)键盘上的每个键和每个系统键都有一个唯一的编号。这些键码在`KeyEvent`类中被定义为静态公共最终整数。一个这样的键代码是`KeyCode.KEYCODE_A`，它是 A 键的代码。这与按下某个键时文本字段中生成的字符无关。它实际上只是标识了密钥本身。

`KeyEvent`类类似于`MotionEvent`类。它有两种与我们相关的方法:

> `KeyEvent.getAction()`:该方法返回`KeyEvent.ACTION_DOWN`、`KeyEvent.ACTION_UP`和`KeyEvent.ACTION_MULTIPLE`。出于我们的目的，我们可以忽略最后一个关键事件类型。另外两个将在按键被按下或释放时发送。
> 
> `KeyEvent.getUnicodeChar()`:返回文本字段中的 Unicode 字符。假设我们按住 Shift 键并按下 A 键。这将被报告为一个键码为`KeyEvent.KEYCODE_A`的事件，但带有一个 Unicode 字符`A`。如果我们自己想做文字输入，可以用这个方法。

要接收键盘事件，`View`必须有焦点。这可以通过以下方法调用来强制实现:

`View.setFocusableInTouchMode(true);
View.requestFocus();`

第一种方法将保证`View`可以聚焦。第二种方法要求特定视图获得焦点。

让我们实现一个简单的测试活动，看看这两者是如何结合起来的。我们希望获得关键事件，并显示我们在`TextView`中收到的最后一个事件。我们将显示的信息是键事件类型，以及键代码和 Unicode 字符(如果会产生的话)。请注意，有些键本身并不产生 Unicode 字符，而是与其他字符组合产生。[清单 4–5](#list_4_5)展示了我们如何用几行代码实现所有这些。

**清单 4–5。**KeyTest.Java*；测试关键事件 API*

`**package** com.badlogic.androidgames;

**import** android.app.Activity;
**import** android.os.Bundle;
**import** android.util.Log;
**import** android.view.KeyEvent;
**import** android.view.View;
**import** android.view.View.OnKeyListener;
**import** android.widget.TextView;

**publicclass** KeyTest **extends** Activity **implements** OnKeyListener {
    StringBuilder builder = **new** StringBuilder();
    TextView textView;

    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        textView = **new** TextView(**this**);
        textView.setText("Press keys (if you have some)!");
        textView.setOnKeyListener(**this**);
        textView.setFocusableInTouchMode(**true**);
        textView.requestFocus();
        setContentView(textView);
    }

    @Override
    **public boolean** onKey(View view, **int** keyCode, KeyEvent event) {
        builder.setLength(0);
        **switch** (event.getAction()) {
        **case** KeyEvent.*ACTION_DOWN*:
            builder.append("down, ");
            **break**;
        **case** KeyEvent.*ACTION_UP*:
            builder.append("up, ");
            **break**;`
`        }
        builder.append(event.getKeyCode());
        builder.append(", ");
        builder.append((**char**) event.getUnicodeChar());
        String text = builder.toString();
        Log.*d*("KeyTest", text);
        textView.setText(text);

        **if** (event.getKeyCode() == KeyEvent.*KEYCODE_BACK*)
            **returnfalse**;
        **else**
            **returntrue**;
    }
}`

我们首先声明活动实现了`OnKeyListener`接口。接下来，我们定义两个我们已经熟悉的成员:一个`StringBuilder`用于构造要显示的文本，一个`TextView`用于显示文本。

在`onCreate()`方法中，我们确保`TextView`拥有焦点，这样它就可以接收按键事件。我们还通过`TextView.setOnKeyListener()`方法将活动注册为`OnKeyListener`。

`onKey()`方法也非常简单。我们处理`switch`语句中的两种事件类型，将一个适当的字符串附加到`StringBuilder`中。接下来，我们添加关键代码以及来自`KeyEvent`本身的 Unicode 字符，并将其输出到 LogCat 和`TextView`。

最后一个`if`语句很有趣:如果按下 back 键，我们从`onKey()`方法返回`false`，让`TextView`处理事件。否则，我们返回`true`。为什么在这里进行区分？

如果我们在返回键的情况下返回`true`,我们会稍微打乱活动的生命周期。该活动不会关闭，因为我们决定自己使用 back key。当然，在有些情况下，我们实际上想要捕捉 back 键，这样我们的活动就不会被关闭。但是，除非绝对必要，否则强烈建议不要这样做。

[Figure 4–8](#fig_4_8)展示了按住 Droid 键盘上的 Shift 和 A 键时活动的输出。

![images](images/0408.jpg)

**图 4–8。** *同时按下 Shift 和 A 键*

这里有几点需要注意:

*   当您查看 LogCat 输出时，请注意我们可以轻松地处理并发的键事件。按住多个键不是问题。
*   按下 D-pad 和滚动轨迹球都被报告为按键事件。
*   与触摸事件一样，按键事件会耗尽旧版本 Android 和第一代设备上的大量 CPU 资源。然而，它们不会产生大量事件。

与上一节相比，这相当轻松，不是吗？

**注意:**关键处理 API 比我们在这里展示的要复杂一些。然而，对于我们的游戏编程项目来说，这里包含的信息已经足够了。如果你需要更复杂的东西，可以参考 Android 开发者网站上的官方文档。

##### 读取加速度计状态

一个非常有趣的游戏输入选项是加速度计。所有 Android 设备都需要包含一个三轴加速度计。在上一章中，我们讨论了一点加速度计。一般来说，我们只会轮询加速度计的状态。

那么，我们如何获得加速度计信息呢？你猜对了——通过注册一个监听器。我们需要实现的接口叫做`SensorEventListener`，它有两个方法:

`**public void** onSensorChanged(SensorEvent event);
**public void** onAccuracyChanged(Sensor sensor, **int** accuracy);`

当新的加速度计事件到达时，调用第一个方法。当加速度计的精度改变时，调用第二种方法。出于我们的目的，我们可以安全地忽略第二种方法。

那么我们在哪里注册我们的`SensorEventListener`？为此，我们必须做一点工作。首先，我们需要检查设备中是否安装了加速度计。现在，我们刚刚告诉你，所有的 Android 设备都必须包含一个加速度计。这仍然是事实，但将来可能会改变。因此，我们希望百分之百地确保我们可以使用该输入法。

我们需要做的第一件事是获得所谓的`SensorManager`的一个实例。那个人会告诉我们是否安装了加速度计，这也是我们注册监听器的地方。为了得到`SensorManager`，我们使用了`Context`接口的一个方法:

`SensorManager manager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);`

`SensorManager`是安卓系统提供的所谓的*系统服务*。Android 由多个系统服务组成，每一个服务都为任何人提供不同的系统信息。

一旦有了管理器，我们就可以检查加速度计是否可用:

`boolean hasAccel = manager.getSensorList(Sensor.TYPE_ACCELEROMETER).size()> 0;`

使用这段代码，我们向管理器轮询所有安装的类型为`accelerometer`的传感器。虽然这意味着一个设备可以有多个加速度计，但实际上这只会返回一个加速度计传感器。

如果安装了加速度计，我们可以从`SensorManager`中获取它，并用它注册`SensorEventListener`，如下所示:

`Sensor sensor = manager.getSensorList(Sensor.TYPE_ACCELEROMETER).get(0);
**boolean** success = manager.registerListener(listener, sensor,
SensorManager.SENSOR_DELAY_GAME);`

参数`SensorManager.SENSOR_DELAY_GAME`指定监听器应该多久更新一次加速度计的最新状态。这是一个专门为游戏设计的特殊常量，所以我们很乐意使用它。注意，`SensorManager.registerListener()`方法返回一个布尔值，表明注册过程是否成功。这意味着我们必须在事后检查布尔值，以确保我们确实会从传感器获得任何事件。

一旦我们注册了监听器，我们将在`SensorEventListener.onSensorChanged()`方法中接收`SensorEvent` s。该方法的名称意味着它只在传感器状态改变时被调用。这有点令人困惑，因为加速度计的状态不断变化。当我们注册监听器时，我们实际上指定了传感器状态更新所需的频率。

那么我们如何处理`SensorEvent`？那相当容易。`SensorEvent`有一个名为`SensorEvent.values`的公共浮点数组成员，它保存加速度计三个轴中每个轴的当前加速度值。`SensorEvent.values[0]`保存 x 轴的值，`SensorEvent.values[1]`保存 y 轴的值，`SensorEvent.values[2]`保存 z 轴的值。我们在第 3 章中讨论了这些值的含义，所以如果你忘记了，请再次查看“输入”部分。

有了这些信息，我们可以编写一个简单的测试活动。我们想要做的就是在`TextView`中输出每个加速度计轴的加速度计值。[清单 4–6](#list_4_6)向您展示了如何做到这一点。

**清单 4–6。**AccelerometerTest.java*；测试加速度计 API*

`**package** com.badlogic.androidgames;

**import** android.app.Activity;
**import** android.content.Context;
**import** android.hardware.Sensor;
**import** android.hardware.SensorEvent;
**import** android.hardware.SensorEventListener;
**import** android.hardware.SensorManager;
**import** android.os.Bundle;
**import** android.widget.TextView;

**package** com.badlogic.androidgames;

**import** android.app.Activity;
**import** android.content.Context;
**import** android.hardware.Sensor;
**import** android.hardware.SensorEvent;
**import** android.hardware.SensorEventListener;
**import** android.hardware.SensorManager;
**import** android.os.Bundle;
**import** android.widget.TextView;

**publicclass** AccelerometerTest **extends** Activity **implements** SensorEventListener {
    TextView textView;
    StringBuilder builder = **new** StringBuilder();

    @Override
    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        textView = **new** TextView(**this**);
        setContentView(textView);

        SensorManager manager = (SensorManager)
getSystemService(Context.*SENSOR_SERVICE*);
        **if** (manager.getSensorList(Sensor.*TYPE_ACCELEROMETER*).size() == 0) {
            textView.setText("No accelerometer installed");
        } **else** {
            Sensor accelerometer = manager.getSensorList(
                    Sensor.*TYPE_ACCELEROMETER*).get(0);
            **if** (!manager.registerListener(**this**, accelerometer,`
`                    SensorManager.*SENSOR_DELAY_GAME*)) {
                textView.setText("Couldn't register sensor listener");
            }
        }
    }

    @Override
    **publicvoid** onSensorChanged(SensorEvent event) {
        builder.setLength(0);
        builder.append("x: ");
        builder.append(event.values[0]);
        builder.append(", y: ");
        builder.append(event.values[1]);
        builder.append(", z: ");
        builder.append(event.values[2]);
        textView.setText(builder.toString());
    }

    @Override
    **publicvoid** onAccuracyChanged(Sensor sensor, **int** accuracy) {
        // nothing to do here
    }
}`

我们首先检查加速度计传感器是否可用。如果是，我们从`SensorManager`中获取它，并尝试注册我们的活动，它实现了`SensorEventListener`接口。如果这些都失败了，我们设置`TextView`来显示一个正确的错误信息。

`onSensorChanged()`方法只是从传递给它的`SensorEvent`中读取轴值，并相应地更新`TextView`文本。

有了`onAccuracyChanged()`方法，我们就可以完全实现`SensorEventListener`接口。它没有真正的其他用途。

[Figure 4–9](#fig_4_9)向您展示了当设备与地面保持垂直时，轴在纵向和横向模式下的值。

![images](images/0409.jpg)

**图 4–9。** *当设备与地面保持垂直时，纵向模式(左)和横向模式(右)下的加速度计轴值*

Android 加速度计处理的一个问题是加速度计值是相对于设备的默认方向的。这意味着，如果你的游戏只在横向运行，那么在默认方向为纵向的设备和默认方向为横向的设备上，你会得到 90 度的不同值！那么，如何应对这种情况呢？使用这个方便的代码片段，您应该已经准备好了:

`**int** screenRotation;
**public void** onResume() {
        WindowManager windowMgr = (WindowManager)activity.getSystemService(Activity.WINDOW_SERVICE);
                // getOrientation() is deprecated in Android 8 but is the same as getRotation() which is the rotation from the natural orientation of the device
        screenRotation = windowMgr.getDefaultDisplay().getOrientation();
}

**static final int** *ACCELEROMETER_AXIS_SWAP*[][] = {
    {1, -1, 0, 1}, // ROTATION_0
    {-1, -1, 1, 0}, // ROTATION_90
    {-1, 1, 0, 1}, // ROTATION_180
    {1, 1, 1, 0}}; // ROTATION_270
**public void** onSensorChanged(SensorEvent event) {
    **final int**[] as = *ACCELEROMETER_AXIS_SWAP*[screenRotation];
    **float** screenX = (**float**)as[0] * event.values[as[2]];
    **float** screenY = (**float**)as[1] * event.values[as[3]];
    **float** screenZ = event.values[2];
    // use screenX, screenY and screenZ as your accelerometer values now!
}`

下面是一些关于加速度计的结束语:

*   正如您在[图 4–9](#fig_4_9)的右侧截图中看到的，加速度计值有时可能会超出其指定范围。这是由于传感器中的小误差造成的，因此如果您需要这些值尽可能精确，就必须进行调整。
*   无论您的活动方向如何，加速度计轴总是以相同的顺序报告。
*   应用开发人员负责根据设备的自然方向旋转加速度计值。

##### 读取指南针状态

除了加速度计之外的读数传感器，如指南针，非常相似。事实上，它是如此相似，我们可以让你简单地复制和粘贴以下内容，以便使用我们的加速度计测试代码作为指南针测试！替换所有实例:

`Sensor.*TYPE_ACCELEROMETER*`

随着

`Sensor.*TYPE_ORIENTATION*`

并重新运行测试。现在，您将看到您的 x、y 和 z 值正在做一些非常不同的事情。如果您将设备平放，屏幕朝上并与地面平行，`x`将读取指南针指向的度数，y 和`z`应该接近 0。现在将设备倾斜，看看这些数字是如何变化的。`x`应该仍然是主要的航向(方位角)，但是`y`和`z`正在显示设备的俯仰和滚动。由于`TYPE_ORIENTATION`的常量已被弃用，您也可以通过调用`SensorManager.getOrientation(float[] R, float[] values`来接收相同的罗盘数据，其中`R`是一个旋转矩阵(参见`SensorManager.getRotationMatrix()`),而`values`保存三个返回值，这次以弧度为单位。

至此，我们已经讨论了游戏开发所需的 Android API 的所有与输入处理相关的类。

**注意:**顾名思义，`SensorManager`类也允许您访问其他传感器。这包括指南针和光传感器。如果你想有创意，你可以想出一个使用这些传感器的游戏创意。处理事件的方式与我们处理加速度计数据的方式类似。Android 开发者网站上的文档会给你更多的信息。

#### 文件处理

Android 为我们提供了几种读写文件的方法。在本节中，我们将了解资产以及如何访问外部存储，大部分是作为 SD 卡实现的。先说资产。

##### 阅读资产

在[第二章](02.html#ch2)中，我们简单看了一下一个 Android 项目的所有文件夹。我们将`assets/`和`res/`文件夹确定为我们可以存放文件的文件夹，这些文件应该与我们的应用程序一起分发。当我们讨论清单文件时，我们告诉过你我们不打算使用`res/`文件夹，因为它意味着对我们如何构建文件集的限制。`assets/`目录是放置我们所有文件的地方，按照我们想要的文件夹层次结构。

文件夹`assets/`中的文件通过一个名为`AssetManager`的类公开。对于我们的应用程序，我们可以获得对该管理器的引用，如下所示:

`AssetManager assetManager = context.getAssets();`

我们已经看到了`Context`界面；它是由`Activity`类实现的。在现实生活中，我们会从活动中获取`AssetManager`。

一旦我们有了`AssetManager`，我们就可以开始疯狂地打开文件:

`InputStream inputStream = assetManager.open("dir/dir2/filename.txt");`

这个方法将返回一个普通的 Java `InputStream`，我们可以用它来读取任何类型的文件。`AssetManager.open()`方法的唯一参数是相对于资产目录的文件名。在前面的例子中，我们在`assets/`文件夹中有两个目录，其中第二个目录(`dir2/`)是第一个目录(`dir/`)的子目录。在我们的 Eclipse 项目中，该文件将位于`assets/dir/dir2/`中。

让我们编写一个简单的测试活动来检查这个功能。我们想从名为`texts`的`assets/`目录的子目录中加载一个名为`myawesometext.txt`的文本文件。文本文件的内容将显示在`TextView`中。[清单 4–7](#list_4_7)展示了这个令人敬畏的活动的来源。

**清单 4–7。***AssetsTest.java，演示如何读取资产文件*

`**package** com.badlogic.androidgames;

**import** java.io.ByteArrayOutputStream;
**import** java.io.IOException;
**import** java.io.InputStream;

**import** android.app.Activity;
**import** android.content.res.AssetManager;
**import** android.os.Bundle;
**import** android.widget.TextView;

**publicclass** AssetsTest **extends** Activity {
    @Override`
`    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        TextView textView = **new** TextView(**this**);
        setContentView(textView);

        AssetManager assetManager = getAssets();
        InputStream inputStream = **null**;
        **try** {
            inputStream = assetManager.open("texts/myawesometext.txt");
            String text = loadTextFile(inputStream);
            textView.setText(text);
        } **catch** (IOException e) {
            textView.setText("Couldn't load file");
        } **finally** {
            **if** (inputStream != **null**)
                **try** {
                    inputStream.close();
                } **catch** (IOException e) {
                    textView.setText("Couldn't close file");
                }
        }
    }

    **public** String loadTextFile(InputStream inputStream) **throws** IOException {
        ByteArrayOutputStream byteStream = **new** ByteArrayOutputStream();
        **byte**[] bytes = **newbyte**[4096];
        **int** len = 0;
        **while** ((len = inputStream.read(bytes)) > 0)
            byteStream.write(bytes, 0, len);
        **returnnew** String(byteStream.toByteArray(), "UTF8");
    }
}`

除了发现从一个`InputStream`加载简单文本在 Java 中相当冗长之外，我们在这里没有看到什么大的惊奇。我们编写了一个名为`loadTextFile()`的小方法，它将从`InputStream`中挤出所有的字节，并以字符串的形式返回这些字节。我们假设文本文件编码为 UTF-8。剩下的只是捕捉和处理各种异常。[图 4–10](#fig_4_10)向您展示了这个小活动的输出。

![images](images/0410.jpg)

**图 4-10。***`AssetsTest`*的文本输出

您应该从本节中删除以下内容:

*   用 Java 从一个`InputStream`加载一个文本文件简直是一团糟！通常，我们会用 Apache IOUtils 这样的东西来做。我们会把它留给你作为练习。
*   我们只能读资产，不能写资产。
*   我们可以很容易地修改`loadTextFile()`方法来加载二进制数据。我们只需要返回字节数组而不是字符串。

##### 访问外部存储器

虽然资产对于将我们所有的图像和声音与我们的应用程序一起传送来说是极好的，但是有时我们需要能够持久存储一些信息并在以后重新加载它。一个常见的例子是高分。

Android 提供了许多不同的方法来实现这一点:您可以使用应用程序的本地共享首选项、小型 SQLite 数据库等等。所有这些选项都有一个共同点:它们不能很好地处理大型二进制文件。我们为什么需要那个？虽然我们可以告诉 Android 将我们的应用程序安装在外部存储设备上，从而不浪费内部存储的内存，但这只能在 Android 2.2 及更高版本上运行。对于早期版本，我们所有的应用程序数据都将安装在内部存储中。理论上，我们只能将应用程序的代码包含在 APK 文件中，并在应用程序第一次启动时将所有的资产文件从服务器下载到 SD 卡中。Android 上很多高配置的游戏都是这么做的。

还有其他一些场景，我们想要访问 SD 卡(在所有当前可用的设备上，sd 卡与术语*外部存储*几乎是同义词)。我们可以允许我们的用户用游戏内编辑器创建他们自己的关卡。我们需要将这些级别存储在某个地方，而 SD 卡非常适合这个目的。

所以，现在我们已经说服你不要使用 Android 提供的花哨机制来存储应用程序偏好，让我们看看如何在 SD 卡上读写文件。

我们要做的第一件事是请求访问外部存储器的许可。这是在 manifest 文件中用本章前面讨论的`<uses-permission>`元素完成的。

我们要做的下一件事是检查我们运行的设备上是否真的有可用的外部存储设备。例如，如果您创建了一个 AVD，您可以选择不让它模拟 SD 卡，这样您就不能在您的应用程序中写入它。无法访问 SD 卡的另一个原因可能是外部存储设备当前正被其他设备使用(例如，用户可能正在通过台式 PC 上的 USB 来浏览它)。下面是我们获取外部存储状态的方法:

`String state = Environment.getExternalStorageState();`

嗯，我们得到了一个字符串。`Environment`类定义了几个常量。其中一个叫做`Environment.MEDIA_MOUNTED`。也是字符串。如果前面的方法返回的字符串等于这个常数，我们就拥有对外部存储的完全读/写访问权限。注意，你真的要用`equals()`方法来比较两个字符串；引用相等并不是在所有情况下都有效。

一旦我们确定我们实际上可以访问外部存储，我们需要获得它的根目录名。如果我们想要访问一个特定的文件，我们需要指定它相对于这个目录的位置。为了获得根目录，我们使用另一个`Environment`静态方法:

`File externalDir = Environment.getExternalStorageDirectory();`

从这里开始，我们可以使用标准的 Java I/O 类来读写文件。

让我们编写一个简单的例子，将一个文件写入 SD 卡，读回该文件，在一个`TextView`中显示其内容，然后再次从 SD 卡中删除该文件。[清单 4–8](#list_4_8)显示了它的源代码。

**清单 4–8。***externalstragetest 活动*

`**package** com.badlogic.androidgames;

**import** java.io.BufferedReader;
**import** java.io.BufferedWriter;
**import** java.io.File;
**import** java.io.FileReader;`
`**import** java.io.FileWriter;
**import** java.io.IOException;

**import** android.app.Activity;
**import** android.os.Bundle;
**import** android.os.Environment;
**import** android.widget.TextView;

**publicclass** ExternalStorageTest **extends** Activity {
    @Override
    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        TextView textView = **new** TextView(**this**);
        setContentView(textView);

        String state = Environment.*getExternalStorageState*();
        **if** (!state.equals(Environment.*MEDIA_MOUNTED*)) {
            textView.setText("No external storage mounted");
        } **else** {
            File externalDir = Environment.*getExternalStorageDirectory*();
            File textFile = **new** File(externalDir.getAbsolutePath()
                    + File.*separator* + "text.txt");
            **try** {
                writeTextFile(textFile, "This is a test. Roger");
                String text = readTextFile(textFile);
                textView.setText(text);
                **if** (!textFile.delete()) {
                    textView.setText("Couldn't remove temporary file");
                }
            } **catch** (IOException e) {
                textView.setText("Something went wrong! " + e.getMessage());
            }
        }
    }

    **privatevoid** writeTextFile(File file, String text) **throws** IOException {
        BufferedWriter writer = **new** BufferedWriter(**new** FileWriter(file));
        writer.write(text);
        writer.close();
    }

    **private** String readTextFile(File file) **throws** IOException {
        BufferedReader reader = **new** BufferedReader(**new** FileReader(file));
        StringBuilder text = **new** StringBuilder();
        String line;
        **while** ((line = reader.readLine()) != **null**) {
            text.append(line);
            text.append("\n");
        }
        reader.close();
        **return** text.toString();
    }
}`

首先，我们检查 SD 卡是否已经安装。如果不行，我们就提前退出。接下来，我们获取外部存储目录并构建一个新的`File`实例，该实例指向我们将在下一条语句中创建的文件。`writeTextFile()`方法使用标准的 Java I/O 类来施展它的魔法。如果文件还不存在，这个方法将创建它；否则，它将覆盖一个已经存在的文件。在我们成功地将测试文本转储到外部存储设备上的文件之后，我们再次读取它并将其设置为`TextView`的文本。最后一步，我们再次从外部存储器中删除该文件。所有这些都是在标准安全措施到位的情况下完成的，如果出现问题，将通过向`TextView`输出错误消息来报告。[图 4–11](#fig_4_11)显示了活动的输出。

![images](images/0411.jpg)

**图 4–11。** *罗杰！*

以下是可以从这一部分吸取的经验教训:

*   不要乱动任何不属于你的文件。如果你删除他们上一次度假的照片，你的用户会很生气。
*   务必检查外部存储设备是否已安装。
*   不要弄乱外部存储设备上的任何文件！我是认真的！

因为删除外部存储设备上的所有文件非常容易，所以在安装市场上请求 SD 卡权限的下一个应用程序之前，您可能会三思而行。该应用程序一旦安装，就可以完全控制你的文件。

##### 共享偏好

Android 提供了一个简单的 API 来存储应用程序的键值对，称为 SharedPreferences。SharedPreferences API 与标准的 Java 属性 API 没有什么不同。一个活动可以有一个默认的 SharedPreferences，也可以根据需要使用多个不同的 SharedPreferences。以下是从活动中获取 SharedPreferences 实例的典型方法:

`SharedPreferences prefs = PreferenceManager.*getDefaultSharedPreferences*(**this**);`

或者:

`SharedPreferences prefs = getPreferences(**MODE_PRIVATE**);`

第一个方法给出了一个公共的 SharedPreferences，它将被那个上下文(在我们的例子中是 Activity)共享。第二种方法做同样的事情，但是它让你选择共享偏好的隐私。选项有:`MODE_PRIVATE`，默认，`MODE_WORLD_READABLE`，`MODE_WORLD_WRITEABLE`。使用 private 之外的任何东西都是更高级的，对于保存游戏设置之类的事情来说没有必要。

要使用共享首选项，您首先需要获得编辑器。这是通过以下方式实现的:

`Editor editor = prefs.edit()`

现在我们可以插入一些值:

`editor.putString("key1", "banana");
editor.putInt("key2", 5);`

最后，当我们想要保存时，我们只需添加:

`editor.commit();`

准备好回读了吗？正如人们所料:

`String value1 = prefs.getString("key1", null);
int value2 = prefs.getInt("key2", 0);`

在我们的例子中，值 1 是“香蕉”,值 2 是 5。SharedPreferences 的“get”调用的第二个参数是默认值。如果在偏好设置中找不到密钥，将使用这些选项。例如，如果从未设置“key1”，那么在 getString 调用后，value1 将为 null。SharedPreferences 非常简单，我们实际上不需要任何测试代码来演示。只要记住总是提交这些编辑！

#### 音频编程

Android 提供了几个易于使用的 API 来播放音效和音乐文件——正好满足我们的游戏编程需求。我们来看看那些 API。

##### 设置音量控制

如果你有一个 Android 设备，你会注意到当你按下音量调高和调低按钮时，你会根据你当前使用的应用程序来控制不同的音量设置。在通话中，您可以控制传入语音流的音量。在 YouTube 应用程序中，您可以控制视频音频的音量。在主屏幕上，您可以控制铃声的音量。

Android 有不同用途的不同音频流。当我们在游戏中回放音频时，我们使用将音效和音乐输出到一个特定流的类，这个流被称为*音乐流*。在我们考虑播放音效或音乐之前，我们首先必须确保音量按钮将控制正确的音频流。为此，我们使用了`Context`接口的另一种方法:

`context.setVolumeControlStream(AudioManager.STREAM_MUSIC);`

一如既往，我们选择的`Context`实现将是我们的活动。这次通话后，音量按钮将控制音乐流，我们稍后将向其中输出音效和音乐。我们只需要在活动生命周期中调用这个方法一次。`Activity.onCreate()`方法是最好的方法。

编写一个只包含一行代码的示例有点矫枉过正。因此，我们将在这一点上避免这样做。只要记住在所有输出声音的活动中使用这种方法。

#### 播放音效

在第三章中，我们讨论了流媒体音乐和播放音效的区别。后者存储在内存中，通常不会超过几秒钟。Android 为我们提供了一个名为`SoundPool`的类，让播放音效变得非常容易。

我们可以如下简单地实例化新的`SoundPool`实例:

`SoundPool soundPool = **new** SoundPool(20, AudioManager.STREAM_MUSIC, 0);`

第一个参数定义了我们可以同时播放的声音效果的最大数量。这并不意味着我们不能加载更多的音效；它只是限制了可以同时播放的音效数量。第二个参数定义了`SoundPool`将输出音频的音频流。我们选择已经设置了音量控制的音乐流。最后一个参数目前没有使用，应该默认为 0。

要将音频文件中的音效加载到堆内存中，我们可以使用`SoundPool.load()`方法。我们将所有文件存储在`assets/`目录中，所以我们需要使用重载的`SoundPool.load()`方法，该方法需要一个`AssetFileDescriptor`。我们如何得到那个`AssetFileDescriptor`？很简单——通过我们之前合作过的`AssetManager`。下面是我们如何通过`SoundPool`从`assets/`目录加载一个名为`explosion.ogg`的 OGG 文件:

`AssetFileDescriptor descriptor = assetManager.openFd("explosion.ogg");
**int** explosionId = soundPool.load(descriptor, 1);`

通过`AssetManager.openFd()`方法获得`AssetFileDescriptor`很简单。通过`SoundPool`加载音效也同样简单。`SoundPool.load()`方法的第一个参数是我们的`AssetFileDescriptor`，第二个参数指定了音效的优先级。目前不使用，为了将来的兼容性，应该设置为 1。

`SoundPool.load()`方法返回一个整数，作为加载的音效的句柄。当我们想要播放声音效果时，我们指定这个句柄，以便`SoundPool`知道要播放什么效果。

播放声音效果也很容易:

`soundPool.play(explosionId, 1.0f, 1.0f, 0, 0, 1);`

第一个参数是我们从`SoundPool.load()`方法收到的句柄。接下来的两个参数指定用于左右声道的音量。这些值应该在 0(无声)和 1(耳朵爆炸)之间的范围内。

接下来是两个我们很少用到的论点。第一个是优先级，目前没有使用，应该设置为 0。另一个参数指定声音效果循环的频率。不推荐循环音效，所以这里一般应该用 0。最后一个参数是回放速率。将其设置为高于 1 的值将允许声音效果以比录制时更快的速度回放，而将其设置为低于 1 的值将导致回放速度变慢。

当我们不再需要声音效果并想释放一些内存时，我们可以使用`SoundPool.unload()`方法:

`soundPool.unload(explosionId);`

我们只需为音效传递从`SoundPool.load()`方法收到的句柄，它将从内存中卸载。

通常，我们在游戏中会有一个单独的`SoundPool`实例，我们将根据需要使用它来加载、播放和卸载音效。当我们完成所有的音频输出并且不再需要 SoundPool 时，我们应该总是调用`SoundPool.release() method`，这将释放 SoundPool 通常使用的所有资源。发布后，你当然不能再使用`SoundPool`。还有，那个`SoundPool`加载的所有音效都会没了。

让我们编写一个简单的测试活动，它将在我们每次点击屏幕时播放爆炸声音效果。我们已经知道了实现这个需要知道的一切，所以清单 4–9 应该不会有什么大的意外。

**清单 4–9。**SoundPoolTest.java*；播放音效*

`**package** com.badlogic.androidgames;

**import** java.io.IOException;

**import** android.app.Activity;
**import** android.content.res.AssetFileDescriptor;
**import** android.content.res.AssetManager;
**import** android.media.AudioManager;
**import** android.media.SoundPool;
**import** android.os.Bundle;`
`**import** android.view.MotionEvent;
**import** android.view.View;
**import** android.view.View.OnTouchListener;
**import** android.widget.TextView;

**public class**SoundPoolTest**extends** Activity **implements** OnTouchListener {
    SoundPool soundPool;
    **int** explosionId = -1;

    @Override
    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        TextView textView = **new** TextView(**this**);
        textView.setOnTouchListener(**this**);
        setContentView(textView);

        setVolumeControlStream(AudioManager.*STREAM_MUSIC*);
        soundPool = **new** SoundPool(20, AudioManager.*STREAM_MUSIC*, 0);

        **try** {
            AssetManager assetManager = getAssets();
            AssetFileDescriptor descriptor = assetManager
                    .openFd("explosion.ogg");
            explosionId = soundPool.load(descriptor, 1);
        } **catch** (IOException e) {
            textView.setText("Couldn't load sound effect from asset, "
                    + e.getMessage());
        }
    }

    @Override
    **public boolean** onTouch(View v, MotionEvent event) {
        **if** (event.getAction() == MotionEvent.*ACTION_UP*) {
            **if** (explosionId != -1) {
                soundPool.play(explosionId, 1, 1, 0, 0, 1);
            }
        }
        **returntrue**;
    }
}`

我们从从`Activity`派生我们的类开始，让它实现`OnTouchListener`接口，这样我们以后就可以处理屏幕上的点击。我们的类有两个成员:T2 和我们将要加载和回放的音效句柄。我们最初将其设置为- 1，表示音效尚未加载。

在`onCreate()`方法中，我们做了以前做过几次的事情:创建一个`TextView`，将活动注册为一个`OnTouchListener`，并将`TextView`设置为内容视图。

下一行设置音量控制来控制音乐流，如前所述。然后我们创建`SoundPool`，并对其进行配置，使其可以同时播放 20 个效果。这对大多数游戏来说应该足够了。

最后，我们从`AssetManager`得到一个`explosion.ogg`文件的`AssetFileDescriptor`，我们把它放在`assets/`目录中。要加载声音，我们只需将描述符传递给`SoundPool.load()`方法，并存储返回的句柄。`SoundPool.load()`方法在加载时出错的情况下抛出一个异常，在这种情况下，我们捕捉到异常并显示一条错误消息。

在`onTouch()`方法中，我们简单地检查手指是否抬起，这表示屏幕被点击。如果是这种情况，并且爆炸声音效果被成功加载(通过句柄不为- 1 来指示)，我们只需回放该声音效果。

当你执行这个小活动时，只需轻触屏幕就能让世界爆炸。如果您快速连续触摸屏幕，您会注意到声音效果会以重叠的方式播放多次。很难超过我们在`SoundPool`中配置的最大 20 次回放。然而，如果发生这种情况，当前播放的声音之一将被停止，以便为新请求的播放腾出空间。

注意，在前面的例子中，我们没有卸载声音或者释放`SoundPool`。这是为了简洁。通常当活动将要被销毁时，你会释放`onPause()`方法中的`SoundPool`。只要记住总是释放或卸载任何你不再需要的东西。

虽然`SoundPool`类非常容易使用，但是有几个注意事项您应该记住:

*   `SoundPool.load()`方法异步执行实际加载。这意味着在使用声音效果调用`SoundPool.play()`方法之前，您必须等待片刻，因为加载可能还没有完成。遗憾的是，没有办法检查音效何时加载完毕。这只有在`SoundPool`的 SDK 版本 8 下才有可能，我们希望支持所有的 Android 版本。通常这没什么大不了的，因为在第一次播放声音效果之前，您很可能会加载其他资源。
*   已知`SoundPool`在 MP3 文件和长声音文件方面存在问题，其中*长*被定义为“长于 5 到 6 秒”这两个问题都是没有记载的，所以没有严格的规则来决定你的音效会不会麻烦。一般来说，我们建议坚持使用 OGG 的音频文件，而不是 MP3，并在音频质量变差之前，尝试尽可能低的采样率和持续时间。

**注意:**和我们讨论的任何 API 一样，SoundPool 中有更多的功能。我们简单地告诉过你，你可以循环音效。为此，您可以从`SoundPool.play()`方法中获得一个 ID，您可以用它来暂停或停止循环音效。如果您需要该功能，请查看 Android 开发者网站上的`SoundPool`文档。

#### 流媒体音乐

小的音效适合 Android 应用程序从操作系统获得的有限堆内存。包含较长音乐片段的较大音频文件不适合。出于这个原因，我们需要将音乐流式传输到音频硬件，这意味着我们一次只能读入一小部分，足以将其解码为原始 PCM 数据并将其发送到音频芯片。

听起来很吓人。幸运的是，有一个`MediaPlayer`类，它为我们处理所有的事务。我们需要做的就是把它指向音频文件，告诉它回放。

实例化`MediaPlayer`类非常简单:

`MediaPlayer mediaPlayer = new MediaPlayer();`

接下来我们需要告诉`MediaPlayer`回放什么文件。这也是通过一个`AssetFileDescriptor`完成的:

`AssetFileDescriptor descriptor = assetManager.openFd("music.ogg");
mediaPlayer.setDataSource(descriptor.getFileDescriptor(), descriptor.getStartOffset(),
descriptor.getLength());`

这里发生的事情比`SoundPool`的情况多一点。`MediaPlayer.setDataSource()`方法不直接采用`AssetFileDescriptor`。相反，它想要一个`FileDescriptor`，我们通过`AssetFileDescriptor.getFileDescriptor()`方法得到它。此外，我们必须指定音频文件的偏移量和长度。为什么要抵消？实际上，所有资产都存储在一个文件中。为了让`MediaPlayer`到达文件的开头，我们必须向它提供文件在包含资产文件中的偏移量。

在我们开始回放音乐文件之前，我们必须再调用一个方法来为回放准备`MediaPlayer`:

`mediaPlayer.prepare();`

这将实际打开文件并检查它是否可以被`MediaPlayer`实例读取和回放。从这里开始，我们可以自由播放音频文件，暂停，停止，设置为循环播放，并改变音量。

要开始回放，我们只需调用以下方法:

`mediaPlayer.start();`

注意，这只能在成功调用`MediaPlayer.prepare()`方法之后调用(如果它抛出运行时异常，您会注意到)。

我们可以通过调用`pause()`方法来暂停回放:

`mediaPlayer.pause();`

只有当我们已经成功准备好`MediaPlayer`并开始回放时，调用该方法才有效。为了恢复暂停的`MediaPlayer`，我们可以在没有任何准备的情况下再次调用`MediaPlayer.start()`方法。

要停止回放，我们调用下面的方法:

`mediaPlayer.stop();`

注意，当我们想要启动一个停止的`MediaPlayer`时，我们首先必须再次调用`MediaPlayer.prepare()`方法。

我们可以用以下方法设置`MediaPlayer`循环播放:

`mediaPlayer.setLooping(true);`

要调节音乐播放的音量，我们可以用这个方法:

`mediaPlayer.setVolume(1, 1);`

这将设置左右声道的音量。文档没有指定这两个参数必须在什么范围内。根据实验，有效范围似乎在 0 和 1 之间。

最后，我们需要一种方法来检查回放是否已经完成。我们可以用两种方法做到这一点。首先，我们可以向`MediaPlayer`注册一个`OnCompletionListener`,回放结束时将调用它:

`mediaPlayer.setOnCompletionListener(listener);`

如果我们想要轮询`MediaPlayer`的状态，我们可以使用下面的方法来代替:

`boolean isPlaying = mediaPlayer.isPlaying();`

注意，如果`MediaPlayer`设置为循环，前面的方法都不会指示`MediaPlayer`已经停止。

最后，如果我们完成了那个`MediaPlayer`实例，我们通过调用下面的方法来确保它占用的所有资源都被释放:

`mediaPlayer.release();`

在丢弃实例之前总是这样做被认为是一种好的做法。

如果我们没有设置`MediaPlayer`来循环播放，并且播放已经结束，我们可以通过再次调用`MediaPlayer.prepare()`和`MediaPlayer.start()`方法来重启`MediaPlayer`。

这些方法中的大多数都是异步工作的，所以即使您调用了`MediaPlayer.stop()`,`MediaPlayer.isPlaying()`方法也可能会在短时间内返回。我们通常不担心这个。在大多数游戏中，我们将`MediaPlayer`设置为循环播放，然后在需要的时候停止(例如，当我们切换到不同的屏幕上播放其他音乐时)。

让我们编写一个小的测试活动，其中我们以循环模式从`assets/`目录中回放一个声音文件。这种声音效果将根据活动的生命周期暂停和恢复，当我们的活动暂停时，音乐也应该暂停，当活动恢复时，音乐播放应该从它停止的地方继续。[清单 4–10](#list_4_10)向您展示了如何做到这一点。

**清单 4–10。*MediaPlayerTest.java***；播放音频流

`**package** com.badlogic.androidgames;

**import** java.io.IOException;

**import** android.app.Activity;
**import** android.content.res.AssetFileDescriptor;
**import** android.content.res.AssetManager;
**import** android.media.AudioManager;
**import** android.media.MediaPlayer;
**import** android.os.Bundle;
**import** android.widget.TextView;

**public class** MediaPlayerTest **extends** Activity {
    MediaPlayer mediaPlayer;

    @Override
    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        TextView textView = **new** TextView(**this**);
        setContentView(textView);

        setVolumeControlStream(AudioManager.*STREAM_MUSIC*);
        mediaPlayer = **new** MediaPlayer();
        **try** {
            AssetManager assetManager = getAssets();
            AssetFileDescriptor descriptor = assetManager.openFd("music.ogg");
            mediaPlayer.setDataSource(descriptor.getFileDescriptor(),
                    descriptor.getStartOffset(), descriptor.getLength());
            mediaPlayer.prepare();
            mediaPlayer.setLooping(**true**);
        } **catch** (IOException e) {
            textView.setText("Couldn't load music file, " + e.getMessage());
            mediaPlayer = **null**;
        }
    }

    @Override
    **protected void** onResume() {
        **super**.onResume();
        **if** (mediaPlayer != **null**) {
            mediaPlayer.start();
        }
    }

    **protected void** onPause() {
        **super**.onPause();
        **if** (mediaPlayer != **null**) {
            mediaPlayer.pause();
            **if** (isFinishing()) {
                mediaPlayer.stop();
                mediaPlayer.release();
            }
        }
    }
}`

我们以活动成员的形式保留对`MediaPlayer`的引用。在`onCreate()`方法中，我们简单地创建了一个`TextView`,一如既往地输出任何错误消息。

在我们开始摆弄`MediaPlayer`之前，我们要确保音量控制确实能控制音乐流。设置好之后，我们实例化`MediaPlayer`。我们从`AssetManager`中取出位于`assets/`目录下的一个名为`music.ogg`的文件的`AssetFileDescriptor`，并将其设置为`MediaPlayer`的数据源。剩下要做的就是准备`MediaPlayer`实例，并将其设置为循环流。如果出现任何问题，我们将`MediaPlayer`成员设置为`null`，这样我们可以在以后确定加载是否成功。此外，我们向`TextView`输出一些错误文本。

在`onResume()`方法中，我们简单地启动`MediaPlayer`(如果创建成功的话)。`onResume()`方法是做这件事的完美地方，因为它是以`onCreate()`和`onPause()`命名的。第一种情况，它会第一次开始播放；在第二种情况下，它将简单地恢复暂停的`MediaPlayer`。

`onResume()`方法暂停`MediaPlayer`。如果这个活动要被终止，我们就停止`MediaPlayer`，然后释放它所有的资源。

如果你在玩这个，确保你也测试了它对暂停和恢复活动的反应，通过锁定屏幕或者暂时切换到主屏幕。恢复时，`MediaPlayer`将从暂停时离开的地方重新开始。

以下是一些需要记住的事情:

*   正如刚刚讨论的，方法`MediaPlayer.start()`、`MediaPlayer.pause()`和`MediaPlayer.resume()`只能在某些状态下被调用。在你还没有准备好`MediaPlayer`的时候，千万不要尝试给他们打电话。只有在准备好`MediaPlayer`之后，或者在通过调用`MediaPlayer.pause()`明确暂停之后想要恢复时，才调用`MediaPlayer.start()`。
*   实例是相当重要的。将它们实例化会占用大量的资源。我们应该总是尝试只有一个音乐播放。音效用`SoundPool`类处理的更好。
*   记得设置音量控制来处理音乐流，否则你的玩家将无法调整游戏的音量。

我们几乎完成了这一章，但是一个大的主题仍然摆在我们面前:2D 图形。

#### 基本图形编程

Android 为我们提供了两个大的在屏幕上绘图的 API。一个主要用于简单的 2D 图形编程，另一个用于硬件加速的 3D 图形编程。这一章和下一章将关注使用`Canvas` API 的 2D 图形编程，它是 Skia 库的一个很好的包装器，适合中等复杂的 2D 图形。在此之前，我们首先需要讨论两件事:全屏和唤醒锁。

##### 使用唤醒锁

如果你把我们写的测试放在一边几秒钟，你的手机屏幕就会变暗。只有当你触摸屏幕或按下按钮时，屏幕才会恢复到最大亮度。为了让我们的屏幕一直保持清醒，我们可以使用所谓的*唤醒锁*。

我们需要做的第一件事是在名为`android.permission.WAKE_LOCK`的清单文件中添加一个适当的`<uses-permission>`标记。这将允许我们使用`WakeLock`类。

我们可以从`PowerManager`中得到一个`WakeLock`实例，如下所示:

`PowerManager powerManager =
(PowerManager)context.getSystemService(Context.POWER_SERVICE);
WakeLock wakeLock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "My Lock");`

像所有其他系统服务一样，我们从一个`Context`实例中获取`PowerManager`。`PowerManager.newWakeLock()`方法有两个参数:锁的类型和我们可以自由定义的标签。有几种不同的唤醒锁类型；出于我们的目的，`PowerManager.FULL_WAKE_LOCK`型是正确的。它将确保屏幕将保持打开，CPU 将全速工作，键盘将保持启用。

要启用唤醒锁，我们必须调用它的`acquire()`方法:

`wakeLock.acquire();`

从这一点开始，无论多长时间没有用户交互，手机都将保持唤醒状态。当我们的应用程序暂停或被破坏时，我们必须再次禁用或释放唤醒锁:

`wakeLock.release();`

通常我们在`Activity.onCreate()`方法上实例化`WakeLock`实例，在`Activity.onResume()`方法中调用`WakeLock.acquire()`，在`Activity.onPause()`方法中调用`WakeLock.release()`方法。这样，我们保证我们的应用程序在暂停或恢复的情况下仍能很好地运行。因为只有四行代码要添加，所以我们不打算写一个完整的例子。相反，我们建议您只需将代码添加到下一节的全屏示例中，并观察效果。

##### 进入全屏模式

在我们开始用 Android APIs 绘制我们的第一批图形之前，让我们先解决一些别的问题。到目前为止，我们所有的活动都显示了标题栏。通知栏也是可见的。我们想通过去掉这些来让我们的玩家更加沉浸其中。我们可以通过两个简单的调用来实现:

`requestWindowFeature(Window.FEATURE_NO_TITLE);
getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
WindowManager.LayoutParams.FLAG_FULLSCREEN);`

第一个调用去掉了活动的标题栏。为了让活动全屏显示，从而消除通知栏，我们调用第二个方法。注意，我们必须在设置活动的内容视图之前调用这些方法。

清单 4–11 向您展示了一个非常简单的测试活动，演示了如何全屏显示。

**清单 4–11。**FullScreenTest.java*；让我们的活动全屏进行*

`**package** com.badlogic.androidgames;

**import** android.os.Bundle;
**import** android.view.Window;
**import** android.view.WindowManager;

**public class** FullScreenTest **extends** SingleTouchTest {

    @Override
    **publicvoid** onCreate(Bundle savedInstanceState) {
        requestWindowFeature(Window.*FEATURE_NO_TITLE*);
        getWindow().setFlags(WindowManager.LayoutParams.*FLAG_FULLSCREEN*,
                WindowManager.LayoutParams.*FLAG_FULLSCREEN*);
        **super**.onCreate(savedInstanceState);
    }
}`

这里发生了什么事？我们简单地从我们之前创建的`TouchTest`类派生并覆盖`onCreate()`方法。在`onCreate()`方法中，我们启用全屏模式，然后调用超类的`onCreate()`方法(在本例中是`TouchTest`活动)，这将设置所有其余的活动。再次注意，我们必须在设置内容视图之前调用这两个方法。因此，在我们执行这两个方法之后，超类`onCreate()`方法被调用。

我们还在清单文件中将活动的方向固定为纵向模式。您没有忘记在我们编写的每个测试的清单文件中添加`<activity>`元素，对吗？从现在开始，我们将总是把它固定为纵向或横向模式，因为我们不希望坐标系一直在变化。

通过从`TouchTest`派生，我们有了一个完全可用的例子，我们现在可以用它来探索我们将要绘制的坐标系。该活动将显示您触摸屏幕的坐标，如旧的`TouchTest`示例所示。这次的不同之处在于我们是全屏的，这意味着我们触摸事件的最大坐标等于屏幕分辨率(每个维度减一，因为我们从[0，0]开始)。对于 Nexus One，在纵向模式下，坐标系将跨越坐标(0，0)到(479，799)(总共 480×800 像素)。

虽然看起来屏幕是连续重绘的，但实际上不是。请记住，在我们的`TouchTest`类中，每次处理触摸事件时，我们都会更新`TextView`。这反过来又让`TextView`重画自己。如果我们不触摸屏幕，`TextView`就不会重画自己。对于一个游戏，我们需要尽可能频繁地重绘屏幕，最好是在我们的主循环线程中。我们将从简单开始，从 UI 线程中的连续呈现开始。

##### UI 线程中的连续呈现

到目前为止，我们所做的就是在需要的时候设置一个`TextView`的文本。实际的渲染已经由`TextView`自己完成了。让我们创建自己的自定义`View`，它的唯一目的是让我们在屏幕上绘制东西。我们还希望它尽可能经常地重画自己，并且我们希望在那个神秘的重画方法中有一个简单的方法来执行我们自己的绘制。

虽然这听起来可能很复杂，但实际上 Android 让我们很容易就能创建这样的东西。我们所要做的就是创建一个从`View`类派生的类，并覆盖一个名为`View.onDraw()`的方法。这个方法在每次需要我们的`View`重画自己的时候被 Android 系统调用。这可能是这样的:

`**class** RenderView **extends** View {
    **public** RenderView(Context context) {
        **super**(context);
    }

    **protected void** onDraw(Canvas canvas) {
        // to be implemented
    }
}`

不完全是火箭科学，是吗？我们将一个名为`Canvas`的类的实例传递给了`onDraw()`方法。这将是我们在下面几节中的主要工作。它允许我们将形状和位图绘制到另一个位图或`View`(或一个表面，我们稍后会谈到)。

我们可以像使用`TextView`一样使用这个`RenderView`。我们只是将它设置为活动的内容视图，并连接我们需要的任何输入侦听器。然而，它还不是那么有用，有两个原因:它实际上并不画任何东西，即使它画了，也只是在需要重画活动时才画(也就是说，当它被创建或恢复时，或者当一个与它重叠的对话框变得不可见时)。怎么才能让它自己重画？

简单，像这样:

`**protected void** onDraw(Canvas canvas) {
    // all drawing goes here
    invalidate();
}`

在`onDraw()`结束时对`View.invalidate()`方法的调用将告诉 Android 系统一旦找到时间就重新绘制`RenderView`。所有这些仍然发生在 UI 线程上，这有点像一匹懒马。然而，我们实际上用`onDraw()`方法进行了连续渲染，尽管连续渲染相对较慢。我们稍后会解决这个问题；目前，它足以满足我们的需求。

所以，让我们再次回到神秘的`Canvas`类。这是一个非常强大的类，它封装了一个名为 Skia 的自定义低级图形库，专门用于在 CPU 上执行 2D 渲染。`Canvas`类为我们提供了许多绘制各种形状、位图甚至文本的方法。

绘制方法绘制到哪里？那得看情况。一个`Canvas`可以渲染到一个`Bitmap`实例；`Bitmap`是由 Android 的 2D API 提供的另一个类，我们将在后面研究它。在这种情况下，它绘制到屏幕上`View`占据的区域。当然，这是一种疯狂的过度简化。在底层，它不会直接绘制到屏幕上，而是绘制到某种位图上，系统稍后将使用该位图与活动的所有其他`View`的位图相结合，以合成最终的输出图像。然后，该图像将被移交给 GPU，GPU 将通过另一组神秘的路径将其显示在屏幕上。

我们真的不需要关心细节。从我们的角度来看，我们的`View`似乎延伸到了整个屏幕，所以它也可以被绘制到系统的帧缓冲区。在接下来的讨论中，我们将假设我们直接绘制到 framebuffer，系统为我们做所有漂亮的事情，如垂直回扫和双缓冲。

只要系统允许，就会调用`onDraw()`方法。对我们来说，它非常类似于我们理论游戏主循环的主体。如果我们要用这个方法实现一个游戏，我们要把所有的游戏逻辑都放在这个方法中。出于各种原因，我们不会这样做，性能是其中之一。

所以让我们做一些有趣的事情。每次访问新的绘图 API 时，编写一个小测试来检查屏幕是否真的频繁重绘。这是一种穷人的灯光秀。在每次调用 redraw 方法时，您需要做的就是用一种新的随机颜色填充屏幕。这样，您只需要找到允许您填充屏幕的那个 API 的方法，而不需要了解很多细节。让我们用我们自己的定制`RenderView`实现来编写这样一个测试。

`Canvas`用特定颜色填充其渲染目标的方法称为`Canvas.drawRGB()`:

`Canvas.drawRGB(int r, int g, int b);`

`r`、`g`和`b`参数分别代表我们将用来填充“屏幕”的颜色的一个分量它们中的每一个都必须在 0 到 255 的范围内，所以我们实际上在这里指定了 RGB888 格式的颜色。如果你不记得关于颜色的细节，再看一下第 3 章的“数字编码颜色”一节，因为我们将在本章的其余部分使用这些信息。

[清单 4–12](#list_4_12)向您展示了我们的小灯光秀的代码。

**注意:**运行这段代码将会用随机颜色快速填充屏幕。如果你有癫痫或其他任何形式的光敏感，不要运行它。

**清单 4–12。***RenderViewTest 活动*

`**package** com.badlogic.androidgames;

**import** java.util.Random;

**import** android.app.Activity;
**import** android.content.Context;
**import** android.graphics.Canvas;
**import** android.os.Bundle;
**import** android.view.View;
**import** android.view.Window;
**import** android.view.WindowManager;

**public class** RenderViewTest **extends** Activity {
    **class** RenderView **extends** View {
        Random rand = **new** Random();

        **public** RenderView(Context context) {
            **super**(context);
        }

        **protected void** onDraw(Canvas canvas) {
            canvas.drawRGB(rand.nextInt(256), rand.nextInt(256),
                    rand.nextInt(256));
            invalidate();
        }
    }

    @Override
    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        requestWindowFeature(Window.*FEATURE_NO_TITLE*);
        getWindow().setFlags(WindowManager.LayoutParams.*FLAG_FULLSCREEN*,
                WindowManager.LayoutParams.*FLAG_FULLSCREEN*);
        setContentView(**new** RenderView(**this**));
    }
}`

对于我们的第一个图形演示，这是非常简洁的。我们将`RenderView`类定义为`RenderViewTest`活动的内部类。如前所述，`RenderView`类从`View`类派生而来，它有一个强制的构造函数和被覆盖的`onDraw()`方法。它还有一个作为成员的`Random`类的实例；我们将用它来生成我们的随机颜色。

`onDraw()`方法非常简单。我们首先告诉`Canvas`用随机颜色填充整个视图。对于每个颜色分量，我们简单地指定一个 0 到 255 之间的随机数(`Random.nextInt()`除外)。之后，我们告诉系统我们希望尽快再次调用`onDraw()`方法。

活动的`onCreate()`方法启用全屏模式，并将我们的`RenderView`类的一个实例设置为内容视图。为了使示例简短，我们现在不考虑唤醒锁。

截取这个例子的截图有点没有意义。它所做的只是在 UI 线程上以系统允许的最快速度用随机颜色填充屏幕。这没什么值得大书特书的。让我们做一些更有趣的事情:画一些形状。

**注意:**前面的连续渲染方法可以，但是我们强烈建议不要使用！我们应该在 UI 线程上做尽可能少的工作。一分钟后，我们将使用一个单独的线程来讨论如何正确地做到这一点，稍后我们还可以实现我们的游戏逻辑。

##### 获取屏幕分辨率(和坐标系)

在第 2 章中，我们讨论了很多关于帧缓冲区及其属性的内容。请记住，帧缓冲区保存了屏幕上显示的像素的颜色。我们可用的像素数是由屏幕分辨率定义的，屏幕分辨率是由屏幕的宽度和高度(以像素为单位)给出的。

现在，使用我们的自定义`View`实现，我们实际上并不直接渲染到帧缓冲区。然而，由于我们的`View`横跨整个屏幕，我们可以假装它是。为了知道我们可以在哪里渲染我们的游戏元素，我们需要知道 x 轴和 y 轴上有多少像素，或者屏幕的宽度和高度。

`Canvas`类有两个方法为我们提供这些信息:

`int width = canvas.getWidth();
int height = canvas.getHeight();`

这将返回`Canvas`渲染的目标的宽度和高度(以像素为单位)。请注意，根据我们活动的方向，宽度可能小于或大于高度。例如，Nexus One 在纵向模式下的分辨率为 480×800 像素，因此`Canvas.getWidth()`方法将返回 480，而`Canvas.getHeight()`方法将返回 800。在横向模式下，两个值简单地交换:`Canvas.getWidth()`将返回 800，`Canvas.getHeight()`将返回 480。

我们需要知道的第二条信息是我们渲染的坐标系统的组织。首先，只有整数像素坐标才有意义(有个概念叫子像素，但我们会忽略)。我们还知道，在纵向或横向模式下，坐标系的原点(0，0)总是在显示屏的左上角。正的 x 轴总是指向右侧，y 轴总是指向下方。[图 4–12](#fig_4_12)显示了一个分辨率为 48×32 像素的假想屏幕，处于横向模式。

![images](images/0412.jpg)

**图 4–12。***48×32 像素宽屏幕的坐标系*

注意[图 4–12](#fig_4_12)中坐标系的原点是如何与屏幕左上角的像素重合的。因此，屏幕左下角的像素不是我们预期的(48，32)，而是(47，31)。通常，(width–1，height–1)总是屏幕右下角像素的位置。

[Figure 4–12](#fig_4_12)向您展示了一个横向模式下的假想屏幕坐标系。到现在为止，你应该能够想象在纵向模式下坐标系是什么样子了。

`Canvas`的所有绘图方法都在这种坐标系下操作。通常，我们可以寻址比 48×32 像素(例如 800×480)更多的像素。也就是说；最后画一些像素，线条，圆形，矩形。

**注意:**您可能已经注意到，不同的设备可能会有不同的屏幕分辨率。我们将在下一章研究这个问题。现在，让我们把注意力集中在最终让我们自己在屏幕上有所作为。

##### 画简单的形状

一百五十页之后，我们终于开始绘制第一个像素。我们将快速浏览一下`Canvas`类提供给我们的一些绘图方法。

###### 绘图像素

我们想知道的第一件事是如何绘制单个像素。这是通过以下方法完成的:

`Canvas.drawPoint(float x, float y, Paint paint);`

需要立即注意的两件事是，像素的坐标是用浮点数指定的，而`Canvas`并没有让我们直接指定颜色，相反，它希望从我们这里得到一个`Paint`类的实例。

不要被我们将坐标指定为浮点数的事实所迷惑。有一些非常高级的功能，允许我们渲染到非整数坐标，这就是它的来源。不过，我们现在还不需要这个功能；我们将在下一章回到它。

`Paint`类保存用于绘制形状、文本和位图的样式和颜色信息。对于绘制形状，我们只对两件事感兴趣:颜料的颜色和风格。既然一个像素并没有真正的风格，那我们就先集中在颜色上。下面是我们如何实例化`Paint`类并设置颜色:

`Paint paint = **new** Paint();
paint.setARGB(alpha, red, green, blue);`

实例化`Paint`类是相当容易的。`Paint.setARGB()`方法也应该很容易破译。每个参数代表颜色的一种颜色成分，范围从 0 到 255。因此，我们在这里指定了 ARGB8888 颜色。

或者，我们可以使用下面的方法来设置一个`Paint`实例的颜色:

`Paint.setColor(0xff00ff00);`

我们向该方法传递一个 32 位整数。它再次编码 ARGB8888 颜色；在这种情况下，它是 alpha 设置为完全不透明的绿色。`Color`类定义了一些静态常量，这些常量对一些标准颜色进行编码，如`Color.RED`、`Color.YELLOW`等等。如果您不想自己指定十六进制值，可以使用这些。

###### 画线

要画一条线，我们可以使用下面的`Canvas`方法:

`Canvas.drawLine(float startX, float startY, float stopX, float stopY, Paint paint);`

前两个参数指定线条起点的坐标，接下来的两个参数指定线条终点的坐标，最后一个参数指定一个`Paint`实例。画出的线将有一个像素厚。如果我们想要线条更粗，我们可以通过设置`Paint`的笔画宽度来指定它的像素粗细:

`Paint.setStrokeWidth(float widthInPixels);`

###### 绘制矩形

我们也可以用`Canvas`来画矩形:

`Canvas.drawRect(float topleftX, float topleftY, float bottomRightX, float bottomRightY,
Paint paint);`

前两个参数指定矩形左上角的坐标，接下来的两个参数指定矩形左下角的坐标，`Paint`指定矩形的颜色和样式。那么我们可以有什么风格，如何设置呢？

为了设置一个`Paint`实例的样式，我们调用下面的方法:

`Paint.setStyle(Style style);`

Style 是一个枚举，它有值`Style.FILL`、`Style.STROKE`和`Style.FILL_AND_STROKE`。如果我们指定`Style.FILL`，矩形将被填充`Paint`的颜色。如果我们指定`Style.STROKE`，将只绘制矩形的轮廓，同样使用`Paint`的颜色和笔画宽度。如果设置了`Style.FILL_AND_STROKE`，矩形将被填充，轮廓将以给定的颜色和笔画宽度绘制。

###### 画圆

画圆可以带来更多乐趣，可以是实心的，也可以是描边的，或者两者兼而有之:

`Canvas.drawCircle(float centerX, float centerY, float radius, Paint paint);`

前两个参数指定圆心的坐标，下一个参数以像素为单位指定半径，最后一个参数也是一个`Paint`实例。与`Canvas.drawRectangle()`方法一样，`Paint`的颜色和样式将用于绘制圆。

最后一件重要的事情是，所有这些绘制方法都将执行阿尔法混合。只需将颜色的 alpha 指定为 255 (0xff)以外的值，您的像素、线条、矩形和圆形将是半透明的。

###### 把这一切放在一起

让我们编写一个快速测试活动来演示前面的方法。这一次，我们希望您首先分析清单 4–13 中的代码。在纵向模式下，找出 480×800 屏幕上不同形状将被绘制的位置。当进行图形编程时，最重要的是想象你发出的绘图命令将如何表现。这需要一些练习，但真的会有回报。

**清单 4–13。**ShapeTest.java*；疯狂画形状*

`**package** com.badlogic.androidgames;

**import** android.app.Activity;
**import** android.content.Context;
**import** android.graphics.Canvas;
**import** android.graphics.Color;
**import** android.graphics.Paint;
**import** android.graphics.Paint.Style;
**import** android.os.Bundle;
**import** android.view.View;
**import** android.view.Window;
**import** android.view.WindowManager;

**public class** ShapeTest **extends** Activity {`
`    **class** RenderView **extends** View {
        Paint paint;

        **public** RenderView(Context context) {
            **super**(context);
            paint = **new** Paint();
        }

        **protected void** onDraw(Canvas canvas) {
            canvas.drawRGB(255, 255, 255);
            paint.setColor(Color.*RED*);
            canvas.drawLine(0, 0, canvas.getWidth()-1, canvas.getHeight()-1, paint);

            paint.setStyle(Style.*STROKE*);
            paint.setColor(0xff00ff00);
            canvas.drawCircle(canvas.getWidth() / 2, canvas.getHeight() / 2, 40, paint);

            paint.setStyle(Style.*FILL*);
            paint.setColor(0x770000ff);
            canvas.drawRect(100, 100, 200, 200, paint);
            invalidate();
        }
    }

    @Override
    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        requestWindowFeature(Window.*FEATURE_NO_TITLE*);
        getWindow().setFlags(WindowManager.LayoutParams.*FLAG_FULLSCREEN*,
                             WindowManager.LayoutParams.*FLAG_FULLSCREEN*);
        setContentView(**new** RenderView(**this**));
    }
}`

你已经创造出那个心理图像了吗？那我们就赶紧分析一下`RenderView.onDraw()`的方法吧。剩下的和上一个例子一样。

我们从用白色填充屏幕开始。接下来，我们从原点到屏幕的右下角画一条线。我们使用一种颜色设置为红色的颜料，所以这条线将是红色的。

接下来，我们稍微修改一下画图，将其样式设置为`Style.STROKE`，颜色设置为绿色，alpha 设置为 255。使用我们刚刚修改的`Paint`在屏幕中心绘制半径为 40 像素的圆。由于`Paint`的风格，只画出圆的轮廓。

最后，我们再次修改`Paint`。我们将其样式设置为`Style.FILL`，颜色设置为全蓝色。注意，我们这次将 alpha 设置为 0×77，这在十进制中等于 119。这意味着我们在下一次调用时绘制的形状大约有 50%是半透明的。

[Figure 4–13](#fig_4_13)显示了纵向模式下 480×800 和 320×480 屏幕上测试活动的输出。

![images](images/0413.jpg)

**图 4–13。***480×800 屏幕(左)和 320×480 屏幕(右)上的 ShapeTest 输出(后加黑边)*

天啊，这里发生了什么事？这就是在不同的屏幕分辨率上使用绝对坐标和大小进行渲染的结果。两幅图中唯一不变的是红线，它只是从左上角画到右下角。这是以独立于屏幕分辨率的方式完成的。

该矩形位于(100，100)处。根据屏幕分辨率，到屏幕中心的距离会有所不同。矩形的大小为 100×100 像素。在大屏幕上，它比在小屏幕上占用的相对空间要少得多。

圆的位置也是独立于屏幕分辨率的，但它的半径不是。因此，它在较小的屏幕上比在较大的屏幕上占据更多的相对空间。

我们已经看到，处理不同的屏幕分辨率可能会有点问题。当我们考虑不同的物理屏幕尺寸时，情况会变得更糟。然而，我们将在下一章尝试解决这个问题。请记住，屏幕分辨率和物理尺寸很重要。

**注意:**`Canvas`和`Paint`课程提供的远不止我们刚刚谈到的。事实上，所有标准的 Android `View`都是用这个 API 绘制的，所以你可以想象它背后有更多的东西。一如既往，查看 Android 开发者的网站以获取更多信息。

##### 使用位图

虽然用线条或圆形等基本形状制作游戏是可能的，但这并不十分性感。我们希望一个令人敬畏的艺术家为我们创建精灵和背景以及所有的爵士乐，然后我们可以从 PNG 或 JPEG 文件加载。在 Android 上做到这一点极其容易。

###### 加载和检查位图

这个班将会成为我们最好的朋友。我们通过使用`BitmapFactory` singleton 从文件中加载一个位图。当我们以资产的形式存储图像时，让我们看看如何从`assets/`目录中加载图像:

`InputStream inputStream = assetManager.open("bob.png");
Bitmap bitmap = BitmapFactory.decodeStream(inputStream);`

这个类本身有一些我们感兴趣的方法。首先，我们想知道它的像素宽度和高度:

`int width = bitmap.getWidth();
int height = bitmap.getHeight();`

我们可能想知道的下一件事是存储的`Bitmap`的颜色格式:

`Bitmap.Config config = bitmap.getConfig();`

`Bitmap.Config`是一个枚举，其值为:

*   `Config.ALPHA_8`
*   `Config.ARGB_4444`
*   `Config.ARGB_8888`
*   `Config.RGB_565`

从[第 3 章](03.html#ch3)开始，你应该知道这些值是什么意思。如果没有，我们强烈建议你再读一遍[第 3 章](03.html#ch3)的“数字编码颜色”一节。

有趣的是，没有 RGB888 颜色格式。PNG 仅支持 ARGB8888、RGB888 和托盘化颜色。什么颜色格式将用于加载 RGB888 PNG？`BitmapConfig.RGB_565`就是答案。对于我们通过`BitmapFactory`加载的任何 RGB888 PNG，这都会自动发生。原因是大多数 Android 设备的实际帧缓冲区都支持这种颜色格式。加载每像素位深度更高的图像会浪费内存，因为像素无论如何都需要转换为 RGB565 以进行最终渲染。

那么为什么会有`Config.ARGB_8888`配置呢？答案是因为在将最终图像绘制到帧缓冲区之前，可以在 CPU 上完成图像合成。在 alpha 组件的情况下，我们也比使用`Config.ARGB_4444`有更多的位深度，这对于一些高质量的图像处理可能是必要的。

ARGB8888 PNG 图像将被加载到具有`Config.ARGB_8888`配置的`Bitmap`中。其他两种颜色格式很少使用。然而，我们可以告诉 `BitmapFactory`尝试加载一个特定颜色格式的图像，即使它的原始格式是不同的。

`InputStream inputStream = assetManager.open("bob.png");
BitmapFactory.Options options = **new** BitmapFactory.Options();
options.inPreferredConfig = Bitmap.Config.ARGB_4444;
Bitmap bitmap = BitmapFactory.decodeStream(inputStream, **null**, options);`

我们使用重载的`BitmapFactory.decodeStream()`方法将一个提示以`BitmapFactory.Options`类实例的形式传递给图像解码器。我们可以通过`BitmapFactory.Options.inPreferredConfig`成员指定`Bitmap`实例所需的颜色格式，如前所示。在这个假设的例子中，`bob.png`文件将是一个 ARGB8888 PNG，我们希望`BitmapFactory`加载它并将其转换为 ARGB4444 位图。不过，工厂可以忽略这个暗示。

这将释放该`Bitmap`实例使用的所有内存。当然，调用此方法后，您不能再使用位图进行渲染。

您也可以用下面的静态方法创建一个空的`Bitmap`:

`Bitmap bitmap = Bitmap.createBitmap(**int** width, **int** height, Bitmap.Config config);`

如果你想自己进行自定义图像合成，这可能会派上用场。`Canvas`类也适用于位图:

`Canvas canvas = **new** Canvas(bitmap);`

然后，您可以像修改`View`的内容一样修改您的位图。

###### 处置位图

`BitmapFactory`可以帮助我们在加载图像时减少内存占用。位图会占用很多内存，正如在[第三章](03.html#ch3)中所讨论的。通过使用较小的颜色格式来减少每像素的位数是有帮助的，但是如果我们继续一个接一个地加载位图，最终我们会耗尽内存。因此，我们应该总是通过以下方法来处置我们不再需要的任何`Bitmap`实例:

`Bitmap.recycle();`

###### 绘制位图

一旦我们加载了位图，我们就可以通过`Canvas`来绘制它们。最简单的方法如下所示:

`Canvas.drawBitmap(Bitmap bitmap, **float** topLeftX, **float** topLeftY, Paint paint);`

第一个论点应该是显而易见的。参数`topLeftX`和`topLeftY`指定了位图左上角在屏幕上的坐标。最后一个论点可以是`null`。我们可以用`Paint`指定一些非常高级的绘图参数，但是我们并不真的需要这些。

另外还有一种方法会派上用场:

`Canvas.drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint);`

这个方法超级牛逼。它允许我们通过第二个参数指定要绘制的`Bitmap`的一部分。`Rect`类保存一个矩形的左上角和右下角坐标。当我们通过`src`指定`Bitmap`的一部分时，我们在`Bitmap`的坐标系中完成。如果我们指定`null`，将使用完整的`Bitmap`。

第三个参数定义了在哪里绘制`Bitmap`的一部分，也是以`Rect`实例的形式。这一次，拐角坐标是在`Canvas`目标的坐标系中给出的(一个`View`或另一个`Bitmap`)。令人惊讶的是，这两个矩形不一定要一样大。如果我们指定目标矩形的尺寸小于源矩形，那么`Canvas`将自动为我们缩放。当然，如果我们指定一个更大的目标矩形，情况也是如此。我们通常会再次将最后一个参数设置为`null`。但是，请注意，这种缩放操作非常昂贵。我们应该只在绝对必要的时候使用它。

因此，您可能会想:如果我们有不同颜色格式的`Bitmap`实例，我们需要在通过`Canvas`绘制它们之前将它们转换成某种标准格式吗？答案是否定的。`Canvas`会自动为我们做这件事。当然，如果我们使用与本地帧缓冲区格式相同的颜色格式，速度会快一点。通常我们只是忽略这一点。

默认情况下，混合也是启用的，所以如果我们的图像每个像素包含一个 alpha 组件，它实际上是被解释的。

###### 把这一切放在一起

有了所有这些信息，我们终于可以加载和渲染一些 bob 了。[清单 4–14](#list_4_14)向您展示了我们出于演示目的而编写的`BitmapTest`活动的源代码。

**清单 4–14。***BitmapTest 活动*

`**package** com.badlogic.androidgames;

**import** java.io.IOException;
**import** java.io.InputStream;

**import** android.app.Activity;
**import** android.content.Context;
**import** android.content.res.AssetManager;
**import** android.graphics.Bitmap;
**import** android.graphics.BitmapFactory;
**import** android.graphics.Canvas;
**import** android.graphics.Rect;
**import** android.os.Bundle;
**import** android.util.Log;
**import** android.view.View;
**import** android.view.Window;
**import** android.view.WindowManager;`

`**public class** BitmapTest **extends** Activity {
    **class** RenderView **extends** View {
        Bitmap bob565;
        Bitmap bob4444;
        Rect dst = **new** Rect();

        **public** RenderView(Context context) {
            **super**(context);

            **try** {
                AssetManager assetManager = context.getAssets();
                InputStream inputStream = assetManager.open("bobrgb888.png");
                bob565 = BitmapFactory.*decodeStream*(inputStream);
                inputStream.close();
                Log.*d*("BitmapText",
                        "bobrgb888.png format: " + bob565.getConfig());

                inputStream = assetManager.open("bobargb8888.png");
                BitmapFactory.Options options = **new** BitmapFactory.Options();
                options.inPreferredConfig = Bitmap.Config.*ARGB_4444*;
                bob4444 = BitmapFactory
                        .*decodeStream*(inputStream, **null**, options);
                inputStream.close();
                Log.*d*("BitmapText",
                        "bobargb8888.png format: " + bob4444.getConfig());

            } **catch** (IOException e) {
                // silently ignored, bad coder monkey, baaad!
            } **finally** {
                // we should really close our input streams here.
            }
        }

        **protected void** onDraw(Canvas canvas) {
            dst.set(50, 50, 350, 350);
            canvas.drawBitmap(bob565, **null**, dst, **null**);
            canvas.drawBitmap(bob4444, 100, 100, **null**);
            invalidate();
        }
    }

    @Override
    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        requestWindowFeature(Window.*FEATURE_NO_TITLE*);
        getWindow().setFlags(WindowManager.LayoutParams.*FLAG_FULLSCREEN*,
                WindowManager.LayoutParams.*FLAG_FULLSCREEN*);
        setContentView(**new** RenderView(**this**));
    }
}`

我们活动的`onCreate()`方法是旧的，所以让我们继续我们的习俗`View`。

它有两个`Bitmap`成员，一个以 RGB565 格式存储鲍勃(在[第三章](03.html#ch3)中介绍)的图像，另一个以 ARGB4444 格式存储鲍勃。我们还有一个`Rect`成员，在那里我们存储了用于渲染的目标矩形。

在`RenderView`类的构造函数中，我们首先将 Bob 加载到`View`的`bob565`成员中。请注意，图像是从 RGB888 PNG 文件加载的，并且`BitmapFactory`会自动将其转换为 RGB565 图像。为了证明这一点，我们还将`Bitmap`的`Bitmap.Config`输出到 LogCat。鲍勃的`RGB888`版本有一个不透明的白色背景，所以不需要进行混合。

接下来，我们从存储在`assets/`目录中的 ARGB8888 PNG 文件加载 Bob。为了节省一些内存，我们还告诉`BitmapFactory`将 Bob 的图像转换为 ARGB4444 位图。工厂可能不会遵守这一要求(原因不明)。为了看看它对我们是否友好，我们也将这个`Bitmap`的`Bitmap.Config`文件输出到 LogCat。

方法是微不足道的。我们所做的就是将`bob565`缩放到 250×250 像素(从他的原始尺寸 160×183 像素)并在他上面绘制`bob4444`，未缩放但已混合(这是由`Canvas`自动完成的)。[图 4–14](#fig_4_14)向你展示了这两个 bob 的荣耀。

![images](images/0414.jpg)

**图 4–14。**

 *LogCat 报告说`bob565`确实有颜色格式`Config.RGB_565`，并且`bob4444`被转换成了`Config.ARGB_4444`。`BitmapFactory`号没有辜负我们！

这里有一些你应该从这一部分学到的东西:

*   使用尽可能少的颜色格式来节省内存。但是，这可能会降低视觉质量和渲染速度。
*   除非绝对必要，否则不要绘制缩放的位图。如果您知道它们的缩放大小，请离线或在加载时预缩放它们。
*   如果不再需要`Bitmap`，一定要确保调用`Bitmap.recycle()`方法。否则，你会得到一些内存泄漏或运行内存不足。

一直使用 LogCat 进行文本输出有点乏味。让我们看看如何通过`Canvas`呈现文本。

**注意:**和其他类一样，`Bitmap`有比我们在这几页中描述的更多的东西。我们涵盖了给诺姆先生写信所需的最低限度。如果你想了解更多，可以查看 Android 开发者网站上的文档。

##### 呈现文本

虽然我们将在 Mr. Nom 游戏中输出的文本将由手工绘制，但了解如何通过 TrueType 字体绘制文本并没有坏处。让我们从从`assets/`目录加载一个定制的 TrueType 字体文件开始。

###### 加载字体

Android API 为我们提供了一个名为`Typeface`的类，它封装了一种 TrueType 字体。它提供了一个简单的静态方法来从`assets/`目录加载这样一个字体文件:

`Typeface font = Typeface.*createFromAsset*(context.getAssets(), "font.ttf");`

有趣的是，如果字体文件无法加载，这个方法不会抛出任何类型的`Exception`。相反，会抛出一个`RuntimeException`。为什么这个方法没有显式抛出异常是一个谜。

###### 用字体绘制文本

一旦我们有了自己的字体，我们就将其设置为一个`Paint`实例的`Typeface`:

`paint.setTypeFace(font);`

通过`Paint`实例，我们还指定了想要呈现字体的大小:

`paint.setTextSize(30);`

这种方法的文档也很少。它没有告诉我们文本大小是以磅还是像素给出的。我们只是假设后者。

最后，我们可以通过下面的`Canvas`方法用这种字体绘制文本:

`canvas.drawText("This is a test!", 100, 100, paint);`

第一个参数是要绘制的文本。接下来的两个参数是应该绘制文本的坐标。最后一个参数我们很熟悉:它是指定要绘制的文本的颜色、字体和大小的`Paint`实例。通过设置`Paint`的颜色，您还可以设置要绘制的文本的颜色。

###### 文本对齐和边界

现在，您可能想知道前面方法的坐标如何与文本字符串填充的矩形相关联。它们是否指定了包含文本的矩形的左上角？答案有点复杂。`Paint`实例有一个名为*对齐设置*的属性。它可以通过`Paint`类的这个方法来设置:

`Paint.setTextAlign(Paint.Align align);`

`Paint.Align`枚举有三个值:`Paint.Align.LEFT`、`Paint.Align.CENTER`和`Paint.Align.RIGHT`。根据设置的对齐方式，传递给`Canvas.drawText()`方法的坐标被解释为矩形的左上角、矩形的中上像素或矩形的右上角。标准对准是`Paint.Align.LEFT`。

有时知道特定字符串的边界(以像素为单位)也很有用。为此，`Paint`类提供了以下方法:

`Paint.getTextBounds(String text, int start, int end, Rect bounds);`

第一个参数是我们想要得到界限的字符串。第二个和第三个参数指定应该测量的字符串中的开始字符和结束字符。end 参数是排他的。最后一个参数`bounds`，是我们自己分配并传递给方法的一个`Rect`实例。该方法将把边框的宽度和高度写入`Rect.right`和`Rect.bottom`字段。为了方便起见，我们可以调用`Rect.width()`和`Rect.height()`来获得相同的值。

请注意，所有这些方法都只适用于单行文本。如果要渲染多行，就得自己做布局。

###### 把这一切放在一起

说够了:让我们做更多的编码。[清单 4–15](#list_4_15)向您展示了实际的文本呈现。

**清单 4–15。** *方特活动*

`**package** com.badlogic.androidgames;

**import** android.app.Activity;
**import** android.content.Context;
**import** android.graphics.Canvas;
**import** android.graphics.Color;
**import** android.graphics.Paint;
**import** android.graphics.Rect;
**import** android.graphics.Typeface;
**import** android.os.Bundle;`
`**import** android.view.View;
**import** android.view.Window;
**import** android.view.WindowManager;

**public class** FontTest **extends** Activity {
    **class** RenderView **extends** View {
        Paint paint;
        Typeface font;
        Rect bounds = **new** Rect();

        **public** RenderView(Context context) {
            **super**(context);
            paint = **new** Paint();
            font = Typeface.*createFromAsset*(context.getAssets(), "font.ttf");
        }

        **protected void** onDraw(Canvas canvas) {
            paint.setColor(Color.*YELLOW*);
            paint.setTypeface(font);
            paint.setTextSize(28);
            paint.setTextAlign(Paint.Align.*CENTER*);
            canvas.drawText("This is a test!", canvas.getWidth() / 2, 100,
                    paint);

            String text = "This is another test o_O";
            paint.setColor(Color.*WHITE*);
            paint.setTextSize(18);
            paint.setTextAlign(Paint.Align.*LEFT*);
            paint.getTextBounds(text, 0, text.length(), bounds);
            canvas.drawText(text, canvas.getWidth() - bounds.width(), 140,
                    paint);
            invalidate();
        }
    }

    @Override
    **publicvoid** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        requestWindowFeature(Window.*FEATURE_NO_TITLE*);
        getWindow().setFlags(WindowManager.LayoutParams.*FLAG_FULLSCREEN*,
                WindowManager.LayoutParams.*FLAG_FULLSCREEN*);
        setContentView(**new** RenderView(**this**));
    }
}`

我们不会讨论活动的`onCreate()`方法，因为我们之前已经看过了。

我们的`RenderView`实现有三个成员:一个`Paint`、一个`Typeface`和一个`Rect`，稍后我们将在其中存储文本字符串的边界。

在构造函数中，我们创建一个新的`Paint`实例，并从`assets/`目录下的文件`font.ttf`中加载一个字体。

在`onDraw()`方法中，我们将`Paint`设置为黄色，设置字体及其大小，并指定在解释对 `Canvas.drawText()`的调用中的坐标时要使用的文本对齐方式。实际的绘图调用呈现字符串`This is a test!`，在 y 轴上的坐标 100 处水平居中。

对于第二个文本呈现调用，我们做了其他事情:我们希望文本与屏幕的右边缘右对齐。我们可以通过使用`Paint.Align.RIGHT`和 x 坐标`Canvas.getWidth()`–1 来做到这一点。相反，我们通过使用字符串的边界来练习非常基本的文本布局。我们还改变了颜色和字体的大小。[图 4–15](#fig_4_15)显示了此活动的输出。

![images](images/0415.jpg)

**图 4–15。** *文字趣味(480×800 像素分辨率)*

`Typeface`类的另一个神秘之处是，它没有明确允许我们释放它的所有资源。我们不得不依靠垃圾收集者来为我们做脏活。

**注意:**我们在这里只触及了文本渲染的皮毛。如果你想知道更多…那么，现在你知道去哪里找了。

##### 使用表面视图进行连续渲染

这是我们成为真正的男人和女人的部分。它涉及到线程，以及与之相关的所有痛苦。我们会活着度过的。我保证！

###### 动机

当我们第一次尝试连续渲染时，我们用了错误的方法。霸占 UI 线程是不可接受的；我们需要一个在单独的线程中完成所有脏活的解决方案。输入`SurfaceView`。

顾名思义，`SurfaceView`类是一个处理另一个 Android API 类`Surface`的`View`。什么是`Surface`？它是一个原始缓冲区的抽象，由屏幕合成器用来渲染特定的`View`。屏幕合成器是 Android 上所有渲染背后的主谋，它最终负责将所有像素推送到 GPU。在某些情况下，`Surface`可以通过硬件加速。不过，我们并不太关心这个事实。我们只需要知道，这是一种更直接的将事物渲染到屏幕上的方式。

我们的目标是在一个单独的线程中执行渲染，这样我们就不会占用忙于其他事情的 UI 线程。`SurfaceView`类为我们提供了一种从一个线程而不是 UI 线程来渲染它的方法。

###### 表面夹具和锁定

为了从不同于 UI 线程的线程渲染到`SurfaceView`，我们需要获取`SurfaceHolder`类的一个实例，如下所示:

`SurfaceHolder holder = surfaceView.getHolder();`

`SurfaceHolder`是`Surface`的包装器，为我们做一些簿记工作。它为我们提供了两种方法:

`Canvas SurfaceHolder.lockCanvas();
SurfaceHolder.unlockAndPost(Canvas canvas);`

第一种方法锁定`Surface`进行渲染，并返回一个我们可以使用的好的`Canvas`实例。第二种方法再次解锁`Surface`，并确保我们通过`Canvas`绘制的内容显示在屏幕上。我们将在渲染线程中使用这两种方法来获取`Canvas`，使用它进行渲染，最终使我们刚刚渲染的图像在屏幕上可见。我们必须传递给`SurfaceHolder.unlockAndPost()`方法的`Canvas`必须是我们从`SurfaceHolder.lockCanvas()`方法收到的。

在实例化`SurfaceView`时，不会立即创建`Surface`。相反，它是异步创建的。每次暂停活动时都会破坏表面，当活动恢复时会重新创建表面。

###### 表面创建和有效性

只要`Surface`尚未生效，我们就无法从`SurfaceHolder`获取`Canvas`。但是，我们可以通过下面的语句检查`Surface`是否已经创建:

`boolean isCreated = surfaceHolder.getSurface().isValid();`

如果这个方法返回`true`，我们就可以安全地锁定表面，并通过我们接收到的`Canvas`来绘制表面。我们必须绝对确保在调用`SurfaceHolder.lockCanvas()`后再次解锁`Surface`，否则我们的活动可能会锁定手机！

###### 把这一切放在一起

那么，我们如何将所有这些与单独的渲染线程以及活动生命周期集成在一起呢？解决这个问题的最好方法是查看一些实际的代码。[清单 4–16](#list_4_16)展示了一个完整的例子，它在一个`SurfaceView`上的单独线程中执行渲染。

**清单 4–16。***SurfaceViewTest 活动*

`**package** com.badlogic.androidgames;

**import** android.app.Activity;
**import** android.content.Context;
**import** android.graphics.Canvas;
**import** android.os.Bundle;
**import** android.view.SurfaceHolder;
**import** android.view.SurfaceView;
**import** android.view.Window;
**import** android.view.WindowManager;

**public class** SurfaceViewTest **extends** Activity {
    FastRenderView renderView;

    **public void** onCreate(Bundle savedInstanceState) {
        **super**.onCreate(savedInstanceState);
        requestWindowFeature(Window.*FEATURE_NO_TITLE*);
        getWindow().setFlags(WindowManager.LayoutParams.*FLAG_FULLSCREEN*,
                             WindowManager.LayoutParams.*FLAG_FULLSCREEN*);
        renderView = **new** FastRenderView(**this**);
        setContentView(renderView);
    }

    **protected void** onResume() {
        **super**.onResume();
        renderView.resume();
    }

    **protected void** onPause() {
        **super**.onPause();
        renderView.pause();
    }

    **class** FastRenderView **extends** SurfaceView **implements** Runnable {
        Thread renderThread = **null**;
        SurfaceHolder holder;
        **volatileboolean** running = **false**;

        **public** FastRenderView(Context context) {
            **super**(context);
            holder = getHolder();`
`        }

        **public void** resume() {
            running = **true**;
            renderThread = **new** Thread(**this**);
            renderThread.start();
        }

        **public void** run() {
            **while**(running) {
                **if**(!holder.getSurface().isValid())
                    **continue**;

                Canvas canvas = holder.lockCanvas();
                canvas.drawRGB(255, 0, 0);
                holder.unlockCanvasAndPost(canvas);
            }
        }

        **public void** pause() {
            running = **false**;
            **while**(**true**) {
                **try** {
                    renderThread.join();
                } **catch** (InterruptedException e) {
                    // retry
                }

    }
}`

这看起来没那么吓人，对吧？我们的活动将一个`FastRenderView`实例作为成员。这是一个自定义的`SurfaceView`子类，将为我们处理所有的线程业务和表面锁定。来活动一下，看起来像是一个朴素的`View`。

在`onCreate()`方法中，我们启用全屏模式，创建`FastRenderView`实例，并将其设置为活动的内容视图。

这次我们也覆盖了`onResume()`方法。在这个方法中，我们将通过调用`FastRenderView.resume()`方法间接启动我们的渲染线程，这个方法在内部完成所有的魔法。这意味着线程将在最初创建活动时启动(因为`onCreate()`后面总是跟着一个对`onResume()`的调用)。当活动从暂停状态恢复时，它也会重新启动。

这当然意味着我们必须在某个地方停止线程；否则，我们会在每次调用`onResume()`时创建一个新线程。这就是`onPause()`的用武之地。它调用`FastRenderView.pause()`方法，这将完全停止线程。在线程完全停止之前，该方法不会返回。

所以我们来看看这个例子的核心类:`FastRenderView`。它类似于我们在前几个例子中实现的`RenderView`类，因为它从另一个`View`类派生而来。在这种情况下，我们直接从`SurfaceView`类中派生出来。它还实现了`Runnable`接口，因此我们可以将它传递给渲染线程，以便它运行渲染线程逻辑。

`FastRenderView`类有三个成员。`renderThread`成员只是对负责执行渲染线程逻辑的`Thread`实例的引用。`holder`成员是对`SurfaceHolder`实例的引用，该实例是从我们派生的`SurfaceView`超类中获得的。最后，`running`成员是一个简单的布尔标志，我们将使用它来通知渲染线程它应该停止执行。修饰词有一个特殊的含义，我们一会儿就会讲到。

我们在构造函数中所做的就是调用超类构造函数，并将对`SurfaceHolder`的引用存储在`holder`成员中。

接下来是`FastRenderView.resume()`方法。它负责启动渲染线程。注意，每次调用这个方法时，我们都会创建一个新的`Thread`。这与我们讨论活动的`onResume()`和`onPause()`方法时所讨论的一致。我们还将`running`标志设置为`true`。一会儿你会看到它是如何在渲染线程中使用的。最后要做的是，我们将`FastRenderView`实例本身设置为线程的`Runnable`。这将在新线程中执行`FastRenderView`的下一个方法。

`FastRenderView.run()`方法是我们定制的`View`类的主力。它的主体在渲染线程中执行。正如你所看到的，它仅仅由一个循环组成，一旦`running`标志被设置为`false`，这个循环就会停止执行。当这种情况发生时，线程也会停止并死亡。在`while`循环中，我们首先检查以确保`Surface`有效，如果有效，我们锁定它，渲染它，并再次解锁它，如前所述。在这个例子中，我们简单地用红色填充`Surface`。

这个`FastRenderView.pause() method`看起来有点奇怪。首先，我们将`running`标志设置为`false`。如果你稍微向上看，你会看到`FastRenderView.run()`方法中的`while`循环最终会因此而终止，从而停止渲染线程。在接下来的几行中，我们调用`Thread.join()`，等待线程完全死亡。这个方法将等待线程死亡，但是可能在线程实际死亡之前抛出一个`InterruptedException`。因为在从那个方法返回之前，我们必须绝对确定线程是死的，所以我们在一个无限循环中执行 join，直到它成功。

让我们回到`running`标志的`volatile`修饰符。我们为什么需要它？原因很微妙:如果编译器认识到`FastRenderView.pause()`方法中的第一行和`while`块之间没有依赖关系，它可能会决定对该方法中的语句重新排序。如果它认为这样做会使代码执行得更快，它是被允许这样做的。然而，我们依赖于在该方法中指定的执行顺序。想象一下，如果在我们尝试加入线程后设置了`running`标志。我们会进入一个无限循环，因为线程永远不会终止。

`volatile`修改器防止这种情况发生。引用该成员的任何语句都将按顺序执行。这让我们远离了讨厌的海森堡——一个来来去去却无法持续复制的 bug。

还有一件事你可能认为会导致代码爆炸。如果在调用`SurfaceHolder.getSurface().isValid()`和`SurfaceHolder.lock()`之间表面被破坏了怎么办？嗯，我们很幸运——这种事永远不会发生。要理解为什么，我们必须后退一步，看看`Surface`的生命周期是如何运作的。

我们知道`Surface`是异步创建的。很可能我们的渲染线程会在`Surface`有效之前执行。我们通过不锁定`Surface`来防止这种情况，除非它是有效的。这涵盖了曲面创建的情况。

在有效性检查和锁定之间，渲染线程代码不会从被销毁的`Surface`开始爆炸的原因与`Surface`被销毁的时间点有关。从活动的`onPause()`方法返回后，`Surface`总是被销毁。因为我们通过调用`FastRenderView.pause()`来等待线程在那个方法中死亡，所以当`Surface`被实际销毁时，渲染线程将不再活着。很性感，不是吗？但也很混乱。

我们现在以正确的方式进行连续渲染。我们不再独占 UI 线程，而是使用单独的渲染线程。我们还让它遵守活动生命周期，这样它就不会在后台运行，在活动暂停时消耗电池。整个世界又是一个快乐的地方。当然，我们需要将 UI 线程中输入事件的处理与渲染线程同步。但是这将会变得非常容易，你会在下一章看到，当我们基于你在这一章中理解的所有信息实现我们的游戏框架时。

##### 使用 Canvas 的硬件加速渲染

Android 3.0 Honeycomb 增加了一个显著的功能，即支持标准 2D 画布绘制调用的 GPU 硬件加速。此功能的价值因应用和设备而异，因为一些设备实际上在 2D 利用 CPU 时性能会更好，而其他设备将受益于 GPU。硬件加速在幕后所做的是，它分析绘制调用，并将它们转换为 OpenGL。例如，如果我们指定应该从 0，0 到 100，100 绘制一条线，那么硬件加速将使用 OpenGL 组织一个特殊的画线调用，并将它绘制到一个硬件缓冲区，稍后将合成到屏幕上。

启用这种硬件加速非常简单，只需在`<application />`标签下的`AndroidManifest.xml`中添加以下内容:

`android:hardwareAccelerated="true"`

请确保在各种设备上打开和关闭加速来测试您的游戏，以确定它是否适合您。将来，让它一直开着可能没什么问题，但是和任何事情一样，我们建议你自己采取测试和决定的方法。当然，有更多的配置选项可以让你为特定的应用程序、活动、窗口或视图设置硬件加速，但因为我们是在做游戏，所以我们只计划每种都有一个，所以通过应用程序全局设置它将是最有意义的。

Android 这一功能的开发者 Romain Guy 在博客上发表了一篇非常详细的文章，介绍了硬件加速的注意事项，以及使用硬件加速获得良好性能的一些通用指南。博客条目的网址是:`[http://android-developers.blogspot.com/2011/03/android-30-hardware-acceleration.html](http://android-developers.blogspot.com/2011/03/android-30-hardware-acceleration.html)`

### 最佳实践

Android(或者更确切地说是 Dalvik)有时会有一些奇怪的性能特征。为了圆满完成这一章，我们将向您展示一些最重要的最佳实践，您应该遵循这些实践来使您的游戏像丝绸一样流畅。

*   垃圾收集者是你最大的敌人。一旦它获得 CPU 时间来做它的脏工作，它将停止世界长达 600 毫秒。这是半秒钟，你的游戏将不会更新或渲染。用户会抱怨。尽可能避免创建对象，尤其是在内部循环中。
*   对象可能被创建在一些不太明显的地方，而这些地方是你想要避免的。不要使用迭代器，因为它们会创建新的对象。不要使用任何标准的`Set`或`Map`集合类，因为它们会在每次插入时创建新的对象；相反，使用 Android API 提供的`SparseArray`类。使用`StringBuffer` s，而不是用`+`操作符连接字符串。这将每次创建一个新的`StringBuffer`。为了这个世界上所有美好的事物，不要使用装箱的原语！
*   与其他虚拟机相比，Dalvik 中的方法调用具有更大的关联成本。如果可以的话，使用静态方法，因为静态方法的性能最好。静态方法通常被认为是邪恶的，就像静态变量一样，因为它们促进了糟糕的设计，所以尽量保持你的设计整洁。也许你也应该避免 getters 和 setters。直接字段访问比不使用 JIT 的方法调用快三倍，使用 JIT 快七倍。然而，在移除所有的 getters 和 setters 之前，请考虑您的设计。
*   浮点运算是在没有 JIT 的旧设备和 Dalvik 版本(Android 版之前的任何版本)上的软件中实现的。守旧派游戏开发者会立即退回到定点数学。也不要这样做，因为整数除法也很慢。大多数情况下，您可以使用浮点，新的设备支持浮点单元(fpu ),一旦 JIT 开始运行，速度会加快很多。
*   尝试将频繁访问的值塞进方法内部的局部变量中。访问局部变量比访问成员或调用 getters 更快。

当然，你需要小心许多其他的事情。在上下文允许的情况下，我们将在本书的其余部分加入一些性能提示。如果你遵循前面的建议，你应该是安全的。别让收垃圾的赢了就行！

### 总结

这一章涵盖了为 Android 写一个像样的小 2D 游戏所需要知道的一切。我们看到了用一些默认设置建立一个新的游戏项目是多么容易。我们讨论了神秘的活动生命周期以及如何与之共存。我们与触摸(更重要的是多点触摸)事件进行了斗争，处理了按键事件，并通过加速度计检查了设备的方向。我们探索了如何读写文件。在 Android 上输出音频被证明是轻而易举的事情，除了`SurfaceView`的线程问题，在屏幕上画东西也不是很难。诺姆先生现在可以成为现实了——一个可怕的、饥饿的现实！*