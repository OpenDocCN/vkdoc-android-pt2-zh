## 第八章

## 2D 游戏编程技巧

第 7 章展示了 OpenGL ES 为 2D 图形编程提供了相当多的特性，比如简单的旋转和缩放，以及视见区的自动拉伸。它还提供了优于使用`Canvas`的性能优势。

现在是时候看看 2D 游戏编程的一些更高级的主题了。你在写《提名先生》的时候直观地使用了其中的一些概念，包括基于时间的状态更新和图像地图集。接下来的许多事情也确实是非常直观的，并且很有可能你迟早会想出同样的解决方案。但是明确地了解这些东西也无妨。

对于 2D 游戏编程来说，有一些至关重要的概念。其中一些将与图形相关，其他的将处理你如何表现和模拟你的游戏世界。所有这些都有一个共同点:它们依赖于一点线性代数和三角学。不用担心，编写像《超级马里奥兄弟》这样的游戏所需的数学水平并不令人惊讶。你可以从复习 2D 线性代数和三角学的一些概念开始。

### 开始之前

与前面的“理论”章节一样，您将创建几个示例来感受正在发生的事情。对于这一章，您可以重用您在上一章中开发的内容，主要是`GLGame`、`GLGraphics`、`Texture`和`Vertices`类，以及其余的框架类。

您的演示项目包含一个名为`GameDev2DStarter`的启动器，它提供了一个要运行的测试列表。重用`GLBasicsStarter`的代码，简单地替换测试的类名。以`<activity>`元素的形式将每个测试添加到清单中。

每个测试都是`Game`接口的一个实例，实际的测试逻辑以`Screen`的形式实现，包含在测试的`Game`实现中，如前一章所述。只有`Screen will be presented`的相关部分才能保留一些页面。每个测试的`GLGame`和`Screen`实现的命名约定也是`XXXTest`和`XXXScreen`。

既然这样，是时候谈谈向量了。

### 开始时...有一个向量

在上一章中，你学到了向量不应该和位置混在一起。这并不完全正确，因为你可以(也愿意)通过一个向量来表示某些空间中的位置。一个向量实际上可以有多种解释:

*   *Position* :你已经在前面的章节中使用它来编码我们的实体相对于坐标系原点的坐标。
*   速度和加速度:这些是你将在下一节听到的物理量。虽然您可能习惯于认为速度和加速度是一个单一的值，但它们实际上应该表示为 2D 或 3D 向量。它们不仅编码实体的速度(例如，以 100 km/h 行驶的汽车)，还编码实体行进的方向。注意，这种向量解释并没有说明向量是相对于原点给出的。这是有意义的，因为汽车的速度和方向与其位置无关。想象一辆车以 100 km/h 的速度在直线公路上向西北方向行驶，只要它的速度和方向不变，速度矢量也不会变。
*   *方向和距离*:方向类似于速度，但一般缺少物理量。你可以用这样的矢量解释来编码状态，比如*这个实体指向东南*。距离只是告诉我们一个位置离另一个位置有多远，在什么方向。

[图 8–1](#fig_8_1)展示了这些解释的实际应用。

![images](img/0801.jpg)

**图 8–1。** *鲍勃，用矢量表示位置、速度、方向和距离*

[图 8–1](#fig_8_1)当然并不详尽。向量可以有更多的解释。然而，对于你的游戏开发需求，这四个基本解释就足够了。

从[图 8–1](#fig_8_1)中省略的一件事是矢量分量的单位。确保这些是合理的(例如，Bob 的速度可以是米每秒，因此他在 1 秒内向左移动 2 米，向上移动 3 米)。位置和距离也是如此，它们也可以用米来表示。然而，鲍勃的方向是一个特例——它是无单位的。如果您想要指定对象的大致方向，同时保持方向的物理特征独立，这将非常方便。对于 Bob 的速度，您可以这样做，将他的速度方向存储为一个方向向量，将他的速度存储为一个值。单值也被称为*标量*。方向向量的长度必须是 1，这将在后面讨论。

#### 使用矢量

向量的力量源于你可以很容易地操作和组合它们。但是，在这之前，您需要定义如何表示向量:

v = (x，y)

现在，这不是一个大惊喜；你已经做过无数次了。在 2D 空间中，每个矢量都有一个 x 和一个 y 分量。(是的，在这一章中，你将停留在二维空间。)还可以添加两个向量:

c = a + b = (a.x，a.y) + (b.x，b.y) = (a.x + b.x，a.y + b.y)

你所要做的就是把这些分量加在一起，得到最终的矢量。用[图 8–1](#fig_8_1)中给出的矢量进行试验。假设你取鲍勃的位置， *p* = (3，2)，加上他的速度，*v*=(2，3)。你到达一个新的位置，*p*' =(3+2，2 + 3)=(1，5)。不要被这里的 *p* 后面的撇号搞糊涂了；它只是表示你有了一个新的向量。当然，这个小操作只有在位置和速度的单位吻合时才有意义。在这种情况下，假设位置以米(m)为单位给出，速度以米每秒(m/s)为单位给出，这非常合适。

当然，你也可以减去向量:

c = a–b =(a . x，a . y)–(b . x，b . y)=(a . x–b . x，a . y–b . y)

同样，你要做的就是把两个向量的分量结合起来。但是，请注意，从一个向量中减去另一个向量的顺序很重要。以[图 8–1](#fig_8_1)中最右边的图像为例。在 pg = (1，4)处有一个绿色 Bob，在 pr = (6，1)处有一个红色 Bob，其中 pg 和 pr 分别代表位置绿色和位置红色。当您获取从绿色 Bob 到红色 Bob 的距离矢量时，您可以计算以下内容:

d = pg–pr =(1.4)-(6.1)=(-5.3)

这很奇怪。这个矢量实际上是从红 Bob 指向绿 Bob！要获得从绿色 Bob 到红色 Bob 的方向向量，必须颠倒减法的顺序:

d = pr–pg =(6.1)-(1.4)=(5，-3)

如果你想找到从位置 *a* 到位置 *b* 的距离矢量，使用以下通用公式:

d = b–a

换句话说，总是从结束位置减去开始位置。这一开始有点令人困惑，但如果你仔细想想，这绝对有道理。在一些图表纸上尝试一下吧！

你也可以将一个向量乘以一个标量(记住，标量只是一个单一的值):

a' = a *标量= (a.x *标量，a.y *标量)

你把向量的每一个分量都乘以标量。这允许您缩放向量的长度。以[图 8–1](#fig_8_1)中的方向向量为例。规定为 *d* =(0，1)。如果你把它乘以标量 *s* =2，你实际上是把它的长度翻倍: *d* × *s* = (0，1 × 2) = (0，2)。当然，你可以通过使用一个小于 1 的标量使它变得更小——例如， *d* 乘以 *s* =0.5 创建一个新的向量 *d* '=(0，0.5)。

说到长度，你也可以计算一个向量的长度(用它给出的单位):

|a| = sqrt(a.x*a.x + a.y*a.y)

符号简单的解释了这代表了向量的长度。如果你在学校的线性代数课上没有睡觉，你可能知道向量长度的公式。这只是勾股定理应用于你想象中的 2D 向量。向量的 x 和 y 分量形成直角三角形的两条边，第三条边是向量的长度。[图 8–2](#fig_8_2)对此进行了说明。

![images](img/0802.jpg)

**图 8–2。** *毕达哥拉斯将爱矢太*

给定平方根的属性，向量长度总是正的或零。如果将此应用于红色和绿色 Bob 之间的距离向量，您可以计算出它们之间的距离(如果它们的位置以米为单位):

| pr–pg | = sqrt(5 * 5+-3 *-3)= sqrt(25+9)= sqrt(34)~ = 5.83m

注意，如果你计算|*pg*–*pr*|，你会得到相同的值，因为长度与向量的方向无关。这个新知识还有另一层含义:当你把一个向量乘以一个标量时，它的长度会相应地改变。给定一个向量 *d* =(0，–1)，原始长度为 1 个单位，可以乘以 2.5，得到一个新的向量，长度为 2.5 个单位。

方向向量通常没有任何相关的单位。你可以通过把它们乘以一个标量来给它们一个单位——比如你可以把一个方向向量 *d* = (0，1)乘以一个速度常数 *s* = 100 m/s 得到一个速度向量 *v* = (0 × 100，1 × 100) = (0，100)。让方向向量的长度为 1 总是一个好主意。长度为 1 的向量称为*单位向量*。你可以把任何一个向量的每个分量除以它的长度，使它成为单位向量:

d' = (d.x/|d|，d.y/|d|)

记住|d|只是表示向量的长度 *d* 。试试看。假设你想要一个指向东北的方向向量: *d* = (1，1)。看起来这个向量已经是一个单位长度了，因为两个分量都是 1，对吗？错误:

| d | = sqrt(1 * 1+1 * 1)= sqrt(2)~ = 1.44

你可以通过把向量变成单位向量来解决这个问题:

d' = (d.x/|d|，d.y/|d|) = (1/|d|，1/|d|) ~= (1/1.44，1/1.44) = (0.69，0.69)

这也被称为*规范化*一个向量，这只是意味着你要确保它的长度为 1。用这个小技巧，你可以，例如，从一个距离向量创建一个单位长度的方向向量。当然，您必须小心零长度向量，因为在这种情况下，您必须除以零！

#### 一点三角学

现在我们来看一下三角学。三角学中有两个必不可少的函数:*余弦*和*正弦*。每个都有一个参数:一个*角度*。您可能习惯于用度数来表示角度(例如，45 度或 360 度)。然而，在大多数数学库中，三角函数期望角度以弧度表示。您可以使用以下等式轻松完成角度和弧度之间的转换:

角度弧度(angle indexes)=角度弧度/ 180 * pi
半径弧度(angle) =角度弧度/ pi * 180

这里，`pi`是心爱的超常数，近似值为 3.14159265。`pi`弧度等于 180，所以前面的函数就是这么来的。

给定一个角度，余弦和正弦实际上计算什么？他们计算单位长度向量相对于原点的 x 和 y 分量。[图 8–3](#fig_8_3)对此进行了说明。

![images](img/0803.jpg)

**图 8–3。** *余弦和正弦产生一个单位矢量，其端点位于单位圆上*

给定一个角度，您可以创建一个单位长度的方向向量，如下所示:

v = (cos(角度)，sin(角度))

也可以反过来，计算矢量相对于 x 轴的角度:

角度= atan2(v.y，v.x)

atan2 函数实际上是一个人工构造。它使用反正切函数(正切函数的反函数，三角学中的另一个基本函数)来构造 180°到 180°范围内的角度(如果角度以弧度返回，则为-`pi`到`pi`)。内部有点复杂，在这个讨论中不太重要。自变量是向量的 y 和 x 分量。注意，矢量不必是 atan2 函数起作用的单位矢量。另外，请注意，通常会先给出 y 分量，然后给出 x 分量——但这取决于所选的数学库。这是一个常见的错误来源。

试举几个例子。给定一个向量 *v* =(cos(97)，sin(97))，atan2(sin(97)，cos(97))的结果是 97。太好了，很简单。使用矢量 *v* =(1，1)，得到 atan2(1，1)=–45。因此，如果矢量的 y 分量是负的，你将得到一个 0 到–180 的负角度。如果 atan2 的输出为负，您可以通过添加 360(或 2 `pi`)来解决这个问题。在前面的示例中，您将得到 315。

你希望能够应用于矢量的最后一个操作是将它们旋转一定的角度。下面的方程的推导又是相当复杂的。幸运的是，你可以直接使用这些方程，不需要知道正交基向量。(*提示:*如果你想知道幕后发生了什么，这是在网上搜索的关键词。)下面是神奇的伪代码:

v.x' = cos(角度)* v.x - sin(角度)* v.y
v.y' = sin(角度)* v.x + cos(角度)* v.y

哇，没想象中复杂。这将绕原点逆时针旋转任何矢量，不管你对矢量有什么解释。

加上向量加法、减法和标量乘法，您实际上可以自己实现所有的 OpenGL 矩阵运算。这是进一步提高上一章`BobTest`性能的解决方案的一部分。这将在下一节中讨论。现在，将注意力集中在讨论的内容上，并将其转移到代码中。

#### 实现一个矢量类

现在，您可以为 2D 向量创建一个易于使用的向量类。称之为`Vector2`。它应该有两个成员来保存向量的 x 和 y 分量。此外，它应该有几个很好的方法，允许我们:

*   加减向量
*   将向量分量与标量相乘
*   测量矢量的长度
*   标准化向量
*   计算向量和 x 轴之间的角度
*   旋转矢量

Java 缺乏操作符重载，所以您必须想出一种机制来减少使用`Vector2`类的麻烦。理想情况下，您应该拥有如下内容:

`Vector2 v = new Vector2();
v.add(10,5).mul(10).rotate(54);`

通过让每个`Vector2`方法返回一个对向量本身的引用，可以很容易地实现这一点。当然，你也想重载像`Vector2.add()`这样的方法，这样你可以传入两个浮点数或者另一个`Vector2`的一个实例。[清单 8–1](#list_8_1)展示了你的`Vector2`类的全部荣耀。

**清单 8–1。** *Vector2.java:实现一些不错的 2D 向量功能*

`**package** com.badlogic.androidgames.framework.math;

**import** android.util.FloatMath;

**public class** Vector2 {
    **public static float** *TO_RADIANS* = (1 / 180.0f) * (**float**) Math.*PI*;
    **public static float** *TO_DEGREES* = (1 / (**float**) Math.*PI*) * 180;
    **public float** x, y;

    **public** Vector2() {
    }

    **public** Vector2(**float** x, **float** y) {
        **this**.x = x;
        **this**.y = y;
    }

    **public** Vector2(Vector2 other) {
        **this**.x = other.x;
        **this**.y = other.y;
    }`

将该类放在包`com.badlogic.androidgames.framework.math`中，在那里你也将存放任何其他与数学相关的类。

首先定义两个静态常数`TO_RADIANS`和`TO_DEGREES`。要转换以弧度给出的角度，只需将其乘以`TO_DEGREES`；要将以度为单位的角度转换为弧度，将其乘以`TO_RADIANS`。您可以通过查看之前定义的控制角度到弧度转换的两个等式来仔细检查这一点。有了这个小技巧，你可以去掉一些除法，加快速度。

接下来，定义存储向量分量的成员`x`和`y,`，以及几个构造函数——不要太复杂:

`    **public** Vector2 cpy() {
        **return new** Vector2(x, y);
    }`

方法将创建一个当前向量的副本并返回它。如果您想要操作向量的副本，保留原始向量的值，这可能会很方便。

`    **public** Vector2 set(**float** x, **float** y) {
        **this**.x = x;
        **this**.y = y;
        **return this**;
    }

    **public** Vector2 set(Vector2 other) {
        **this**.x = other.x;
        **this**.y = other.y;
        **return this**;
    }`

`set()`方法允许你基于两个浮点参数或者另一个向量来设置向量的 x 和 y 分量。这些方法返回一个对这个向量的引用，因此您可以像前面讨论的那样链接操作。

`**public** Vector2 add(**float** x, **float** y) {
        **this**.x += x;
        **this**.y += y;
        **return this**;
    }

    **public** Vector2 add(Vector2 other) {
        **this**.x += other.x;
        **this**.y += other.y;
        **return this**;
    }

    **public** Vector2 sub(**float** x, **float** y) {
        **this**.x -= x;
        **this**.y -= y;
        **return this**;
    }

    **public** Vector2 sub(Vector2 other) {` `        **this**.x -= other.x;
        **this**.y -= other.y;
        **return this**;
    }`

`add()`和`sub()`方法有两种风格:在一种情况下，它们使用两个浮点参数，而在另一种情况下，它们使用另一个`Vector2`实例。所有这四个方法都返回对这个向量的引用，以便您可以链接操作。

`    **public** Vector2 mul(**float** scalar) {
        **this**.x *= scalar;
        **this**.y *= scalar;
        **return this**;
    }`

`mul()`方法简单地将向量的 x 和 y 分量乘以给定的标量值，并返回对向量本身的引用，用于链接。

`    **public float** len() {
        **return** FloatMath.*sqrt*(x * x + y * y);
    }`

如前所述，`len()`方法精确计算向量的长度。注意，您使用的是`FastMath`类，而不是 Java SE 提供的常见的`Math`类。这是一个特殊的 Android API 类，使用 floats 而不是 doubles，并且比等价的`Math`要快一点。

`    **public** Vector2 nor() {
        **float** len = len();
        **if** (len != 0) {
            **this**.x /= len;
            **this**.y /= len;
        }
        **return this**;
    }`

`nor()`方法将向量归一化为单位长度。您在内部使用`len()`方法首先计算长度。如果是零，你可以早点退出，避免被零除。否则，将向量的每个分量除以其长度，得到一个单位长度的向量。对于链接，您再次返回对这个向量的引用。

`    **public float** angle() {
        **float** angle = (**float**) Math.*atan2*(y, x) * *TO_DEGREES*;
        **if** (angle < 0)
            angle += 360;
        **return** angle;
    }`

如前所述，`angle()`方法使用`atan2()`方法计算矢量和 x 轴之间的角度。你必须使用`Math.atan2()`方法，因为`FastMath`类没有这个方法。返回的角度以弧度给出，所以通过乘以`TO_DEGREES`将其转换为角度。如果该角度小于零，则向其添加 360，以便可以返回 0 到 360 范围内的值。

`**public** Vector2 rotate(**float** angle) {` `        **float** rad = angle * *TO_RADIANS*;
        **float** cos = FloatMath.*cos*(rad);
        **float** sin = FloatMath.*sin*(rad);

        **float** newX = **this**.x * cos - **this**.y * sin;
        **float** newY = **this**.x * sin + **this**.y * cos;

        **this**.x = newX;
        **this**.y = newY;

        **return this**;
    }`

`rotate()`方法简单地将向量围绕原点旋转给定的角度。因为`FastMath.cos()`和`FastMath.sin()`方法期望角度以弧度给出，所以首先将它们从角度转换成弧度。接下来，使用之前定义的等式来计算向量的新 x 和 y 分量，然后返回向量本身，再次用于链接。

`    **public float** dist(Vector2 other) {
        **float** distX = **this**.x - other.x;
        **float** distY = **this**.y - other.y;
        **return** FloatMath.*sqrt*(distX * distX + distY * distY);
    }

    **public float** dist(**float** x, **float** y) {
        **float** distX = **this**.x - x;
        **float** distY = **this**.y - y;
        **return** FloatMath.*sqrt*(distX * distX + distY * distY);
    }
}`

最后，有两种方法可以计算这个向量和另一个向量之间的距离。

这就是你闪亮的`Vector2`类，你可以用它在接下来的代码中表示位置、速度、距离和方向。要对新类有所了解，请在一个简单的例子中使用它。

#### 一个简单的用法示例

这里有一个简单测试的建议:

*   创建一种由三角形代表的大炮，它在你的世界中有一个固定的位置。三角形的中心将位于(2.4，0.5)。
*   每次触摸屏幕时，您都希望旋转三角形以面对触摸点。
*   您的视图截锥将向我们显示(0，0)和(4.8，3.2)之间的区域。您不在像素坐标中操作，而是定义自己的坐标系，其中一个单位等于一米。此外，您将在横向模式下工作。

有几件事你需要考虑。您已经知道如何在模型空间中定义一个三角形——您可以使用一个`Vertices`实例来实现。你的加农炮应该以默认的 0 度角指向右边。[图 8–4](#fig_8_4)显示了模型空间中的大炮三角形。

![images](img/0804.jpg)

**图 8–4。** *模型空间中的大炮三角*

当你渲染三角形时，只需使用`glTranslatef()`将它移动到它在世界上的位置(2.4，0.5)。

您还希望旋转加农炮，使其尖端指向屏幕上您最后触摸的点的方向。为此，您需要找出您的世界中最后一次触摸事件的位置。`GLGame.getInput().getTouchX()`和`getTouchY()`方法将返回屏幕坐标中的触摸点，原点在左上角。`Input`实例不会像在《提名先生》中那样，将事件缩放到一个固定的坐标系中。相反，你将通过触摸 Hero 或 Nexus One(分别为 479，319 和 799，479)屏幕的右下角来接收坐标。您需要将这些触摸坐标转换为世界坐标。你已经在 Nom 先生的触摸处理程序和基于`Canvas`的游戏框架中做到了这一点；这次唯一的不同是坐标系范围稍微小了一点，您的世界的 y 轴指向上方。下面的伪代码展示了如何在一般情况下实现转换，这与《T4》第五章中的触摸处理程序几乎相同:

`worldX = (touchX / Graphics.getWidth()) * viewFrustmWidth
worldY = (1 - touchY / Graphics.getHeight()) * viewFrustumHeight`

通过将触摸坐标除以屏幕分辨率，将触摸坐标归一化到范围(0，1)。在 y 坐标的情况下，从 1 中减去触摸事件的归一化 y 坐标来翻转 y 轴。剩下的就是通过视见体的宽度和高度缩放 x 和 y 坐标——在您的例子中，是 4.8 和 3.2。从`worldX`和`worldY,`你可以构建一个`Vector2`,在你的世界坐标中存储触摸点的位置。

你需要做的最后一件事是计算佳能旋转的角度。让我们看看[图 8–5](#fig_8_5)，它显示了你的大炮和世界坐标中的一个接触点。

![images](img/0805.jpg)

**图 8–5。** *你的加农炮在默认状态下，指向右边(角度= 0)，一个触摸点，以及你需要旋转加农炮的角度。矩形是你的视图截锥将在屏幕上显示的世界区域:(0，0)到(4.8，3.2)。*

你需要做的就是创建一个从大炮中心(2.4，0.5)到接触点的距离向量(记住，你必须从接触点减去大炮中心，而不是相反)。一旦有了距离向量，就可以用`Vector2.angle()`方法计算角度。这个角度可以用来通过`glRotatef()`旋转你的模型。

让我们编码。[清单 8–2](#list_8_2)显示了`CannonScreen`的相关部分，是`CannonTest`类的一部分。

**清单 8–2。** *摘自 CannonTest.java；触摸屏幕会旋转大炮*

`**class** CannonScreen **extends** Screen {
    **float** FRUSTUM_WIDTH = 4.8f;
    **float** FRUSTUM_HEIGHT = 3.2f;
    GLGraphics glGraphics;
    Vertices vertices;
    Vector2 cannonPos = **new** Vector2(2.4f, 0.5f);
    **float** cannonAngle = 0;
    Vector2 touchPos = **new** Vector2();`

如前所述，从定义平截头体的宽度和高度的两个常数开始。接下来，有一个`GLGraphics`实例，以及一个`Vertices`实例。将加农炮的位置存储在一个`Vector2`中，将角度存储在一个浮点数中。最后，我们还有另一个`Vector2`，你可以用它来计算从原点到触摸点的向量和 x 轴之间的角度。

为什么将`Vector2`实例存储为类成员？你可以在每次需要的时候实例化它们，但是那会让垃圾收集器生气。一般来说，尝试一次实例化所有的`Vector2`实例，然后尽可能频繁地重用它们。

`    **public** CannonScreen(Game game) {
        **super**(game);
        glGraphics = ((GLGame) game).getGLGraphics();
        vertices = **new** Vertices(glGraphics, 3, 0, **false**, **false**);
        vertices.setVertices(**newfloat**[] {  -0.5f, -0.5f,
                                            0.5f, 0.0f,
                                           -0.5f, 0.5f }, 0, 6);
    }`

在构造器中，取`GLGraphics`实例，根据[图 8–4](#fig_8_4)创建三角形。

`    @Override
    **public void** update(**float** deltaTime) {
        List<TouchEvent> touchEvents = game.getInput().getTouchEvents();
        game.getInput().getKeyEvents();

        **int** len = touchEvents.size();
        **for** (**int** i = 0; i < len; i++) {
            TouchEvent event = touchEvents.get(i);

            touchPos.x = (event.x / (**float**) glGraphics.getWidth())
                    * FRUSTUM_WIDTH;
            touchPos.y = (1 - event.y / (**float**) glGraphics.getHeight())
                    * FRUSTUM_HEIGHT;
            cannonAngle = touchPos.sub(cannonPos).angle();
        }
    }`

接下来是`update()`方法。简单地循环所有的`TouchEvent`并计算大炮的角度。这可以分两步完成。首先，如前所述，将触摸事件的屏幕坐标转换到世界坐标系。将触摸事件的世界坐标存储在`touchPoint`成员中。然后你从`touchPoint`向量中减去大炮的位置，这将产生在[图 8–5](#fig_8_5)中描述的向量。然后计算这个向量和 x 轴之间的角度。这就是全部了！

`    @Override
    **public void** present(**float** deltaTime) {

        GL10 gl = glGraphics.getGL();
        gl.glViewport(0, 0, glGraphics.getWidth(), glGraphics.getHeight());
        gl.glClear(GL10.*GL_COLOR_BUFFER_BIT*);
        gl.glMatrixMode(GL10.*GL_PROJECTION*);
        gl.glLoadIdentity();
        gl.glOrthof(0, FRUSTUM_WIDTH, 0, FRUSTUM_HEIGHT, 1, -1);
        gl.glMatrixMode(GL10.*GL_MODELVIEW*);
        gl.glLoadIdentity();

        gl.glTranslatef(cannonPos.x, cannonPos.y, 0);
        gl.glRotatef(cannonAngle, 0, 0, 1);
        vertices.bind();
        vertices.draw(GL10.*GL_TRIANGLES*, 0, 3);
        vertices.unbind();
    }`

方法做的事情和以前一样无聊。设置视口，清空屏幕，使用平截头体的宽度和高度设置正交投影矩阵，并告诉 OpenGL ES 所有后续矩阵操作都将在模型-视图矩阵上进行。将一个单位矩阵加载到模型-视图矩阵中以“清除”它。接下来，将(身份)模型-视图矩阵乘以平移矩阵，这将把三角形的顶点从模型空间移动到世界空间。用你在`update()`方法中计算出的角度调用`glRotatef()`，这样你的三角形在被转换之前就在模型空间中旋转了。请记住，变换是以相反的顺序应用的，即首先应用最后指定的变换。最后绑定三角形的顶点，渲染，解除绑定。

`    @Override
    **public void** pause() {

    }

    @Override
    **public void** resume() {

    }

    @Override
    **public void** dispose() {

    }
}`

现在你有了一个会跟随你每次触摸的三角形。[图 8–6](#fig_8_6)显示触摸屏幕左上角后的输出。

![images](img/0806.jpg)

**图 8–6。** *你的三角炮对左上角的触摸事件做出反应*

请注意，无论您是在大炮位置渲染三角形还是将矩形纹理映射到大炮的图像，这都无关紧要——OpenGL ES 并不在乎。在`present()`方法中也有所有的矩阵运算。事实是，这样更容易跟踪 OpenGL ES 状态，并且您可以在一个`present()`调用中使用多个视图截锥(例如，一个视图截锥以米为单位设置世界，用于呈现您的世界，另一个视图截锥以像素为单位设置世界，用于呈现 UI 元素)。正如上一章所描述的，对性能的影响并不是那么大，所以大多数时候这样做是可以接受的。请记住，如果需要的话，您可以对此进行优化。

从现在开始，Vectors 将是你最好的朋友。您可以使用它们来指定您世界中的几乎所有东西。你也将能够用向量做一些非常基本的物理。如果大炮不能发射，那它有什么用，对吗？

### 2D 的一点物理

在本节中，您将使用一个非常简单且有限的物理学版本。游戏就是要做好假货。他们尽可能作弊，以避免潜在的繁重计算。游戏中物体的行为不需要 100%物理准确；它只需要足够好，看起来可信。有时你甚至不想要物理上准确的行为(也就是说，你可能想让一组物体向下坠落，而另一组更疯狂的物体向上坠落)。

即使是最初的超级马里奥兄弟也至少使用了一些牛顿物理学的基本原理。这些原则真的很简单，也很容易实现。我们将只讨论为你的游戏对象实现一个简单的物理模型所需的绝对最小值。

#### 牛顿和欧拉，永远的好朋友

你主要关心的是所谓的*点质量*的运动物理学，点质量指的是物体的位置、速度和加速度随时间的变化。点质量意味着你用一个具有相关质量的无穷小的点来近似所有的物体。你不必处理像扭矩这样的东西——物体围绕其质心的旋转速度——因为这是一个复杂的问题领域，已经有不止一本完整的书写了。只需看看对象的这三个属性:

*   一个物体的位置只是某个空间中的一个向量——在你的例子中，是一个 2D 空间。你把它表示成一个矢量。通常位置以米为单位。
*   物体的速度是它每秒钟位置的变化。速度以 2D 速度矢量的形式给出，它是物体前进方向的单位长度方向矢量和物体移动速度的组合，以米/秒为单位给出。注意，速度只是决定了速度向量的长度；如果你用速度归一化速度向量，你会得到一个很好的单位长度方向向量。
*   物体的加速度是它每秒钟的速度变化。你可以把它表示为一个只影响速度的标量(速度向量的长度)，或者表示为一个 2D 向量，这样你就可以在 x 轴和 y 轴上有不同的加速度。这里你会选择后者，因为它允许你更容易地使用弹道学之类的东西。加速度通常以米每秒每秒(米/秒 <sup>2</sup> 给出。不，这不是打字错误，你改变了速度，以米每秒为单位。

当你知道一个物体在某一给定时间点的属性时，你可以对它们进行积分，以模拟该物体在世界上随时间变化的路径。这听起来可能很吓人，但是你已经用 Nom 先生和你的 Bob 测试做到了。在那些情况下，你没有使用加速度；你只需将速度设为一个固定的矢量。以下是如何综合物体的加速度、速度和位置:

`Vector2 position = **new** Vector2();
Vector2 velocity = **new** Vector2();
Vector2 acceleration = **new** Vector2(0, -10);
**while**(simulationRuns) {
   **float** deltaTime = getDeltaTime();
   velocity.add(acceleration.x * deltaTime, acceleration.y * deltaTime);
   position.add(velocity.x * deltaTime, velocity.y * deltaTime);
}`

这叫*数值欧拉积分*，是游戏中使用的最直观的积分方法。开始时，位置为(0，0)，速度为(0，0)，加速度为(0，10)，这意味着 y 轴上的速度将增加 1 m/s。在 x 轴上没有运动。在你进入积分循环之前，你的物体是静止的。在循环中，首先根据加速度乘以增量时间来更新速度，然后根据速度乘以增量时间来更新位置。这就是“整合 T2”这个可怕的大词的全部含义。

**注:**和往常一样，这还不到故事的一半。欧拉积分是一种“不稳定”的积分方法，应尽可能避免。通常，人们会使用所谓的 *verlet integration* 的变体，只是稍微复杂一点。然而，对于你的目的，更简单的欧拉积分就足够了。

#### 力和质量

你可能想知道加速度从何而来。这个问题问得好，答案很多。汽车的加速度来自发动机。发动机给汽车施加一个力，使它加速。但这还不是全部。由于重力，汽车也会加速向地心运动。唯一阻止它坠入地心的是地面，它无法穿过地面。地面抵消了这种重力。总的想法是这样的:

力=质量×加速度

您可以将其重新整理为以下等式:

加速度=力/质量

力的单位是国际单位制*牛顿。*(猜猜这是谁想出来的。)如果你指定加速度为矢量，那么你也必须指定力为矢量。因此，力可以有方向。例如，重力沿方向(0，1)向下拉。加速度也取决于物体的质量。一个物体的质量越大，你需要施加越大的力才能使它加速到和一个质量较小的物体一样快。这是前面方程的直接结果。

然而，对于简单的游戏，你可以忽略质量和力，直接处理速度和加速度。在前面的伪代码中，您将加速度设置为每秒(0，10)米/秒(同样，不是打字错误)，这大致是一个物体向地球下落时的加速度，无论其质量如何(忽略空气阻力等因素)。是真的，问问伽利略！

#### 理论上来说，是在玩

用前面的例子来玩一个向地球坠落的物体。让我们假设你让循环迭代 10 次，并且`getDeltaTime()`将总是返回 0.1 s。你将得到每次迭代的以下位置和速度:

`time=0.1, position=(0.0,-0.1), velocity=(0.0,-1.0)
time=0.2, position=(0.0,-0.3), velocity=(0.0,-2.0)
time=0.3, position=(0.0,-0.6), velocity=(0.0,-3.0)
time=0.4, position=(0.0,-1.0), velocity=(0.0,-4.0)
time=0.5, position=(0.0,-1.5), velocity=(0.0,-5.0)
time=0.6, position=(0.0,-2.1), velocity=(0.0,-6.0)
time=0.7, position=(0.0,-2.8), velocity=(0.0,-7.0)
time=0.8, position=(0.0,-3.6), velocity=(0.0,-8.0)
time=0.9, position=(0.0,-4.5), velocity=(0.0,-9.0)
time=1.0, position=(0.0,-5.5), velocity=(0.0,-10.0)`

1 秒钟后，你的物体将下落 5.5 米，速度为(0，10)米/秒，直接向下移动到地核(当然，直到它撞到地面)。

你的物体会无止境地增加向下的速度，因为你没有考虑空气阻力。(如前所述，你很容易骗过自己的系统。)你可以简单地通过检查当前速度长度来强制一个最大速度，它等于物体的速度。

无所不知的维基百科指出，一个自由落体的人的最大速度或极限速度大约是每小时 125 英里。将其转换为米/秒(125 × 1.6 × 1000 / 3600)，得到 55.5 米/秒。为了使模拟更加真实，可以修改循环，如下所示:

`**while**(simulationRuns) {
   **float** deltaTime = getDeltaTime();
   **if**(velocity.len()< 55.5)
      velocity.add(acceleration.x * deltaTime, acceleration.y * deltaTime);
   position.add(velocity.x * deltaTime, velocity.y * deltaTime);
}`

只要物体的速度(速度向量的长度)小于 55.5 m/s，就可以通过加速度来增加速度。当你达到终极速度时，你只需停止用加速度来增加它。这种简单的速度上限是许多游戏中经常使用的技巧。

你可以通过在 x 方向增加另一个加速度，比如说(–1，0)米/秒，将风加入到方程式中。为此，在将重力加速度加入速度之前，先将重力加速度加入到风加速度中:

`Vector2 gravity = **new** Vector2(0,-10);
Vector2 wind = **new** Vector2(-1,0);
**while**(simulationRuns) {
   **float** deltaTime = getDeltaTime();
   acceleration.set(gravity).add(wind);
   **if**(velocity.len()< 55.5)
      velocity.add(acceleration.x * deltaTime, acceleration.y * deltaTime);
   position.add(velocity.x * deltaTime, velocity.y * deltaTime);
}`

你也可以完全忽略加速度，让你的物体有一个固定的速度。你在`BobTest`中就是这么做的。只有当每个摆锤碰到边缘时，你才改变它的速度，而且你是立即这样做的。

#### 实际上是在玩

即使是这个简单的模型，可能性也是无穷无尽的。让我们延伸你的小`CannonTest`让你真的可以发射炮弹。这是你想做的:

*   只要用户在屏幕上拖动他或她的手指，佳能就会跟随它。这就是你如何指定击球的角度。
*   一旦收到触发事件，您就可以向大炮指向的方向发射炮弹。炮弹的初速度将是大炮的方向和炮弹从开始就有的速度的组合。速度等于大炮和接触点之间的距离。摸的越远，炮弹飞的越快。
*   只要没有新的修饰事件，炮弹就会飞起来。
*   你可以把你的视见体的大小加倍到(0，0)到(9.6，6.4)，这样你可以看到你的世界的更多部分。此外，您可以将大炮放置在(0，0)处。注意，现在世界上所有的单位都是米。
*   您可以将炮弹渲染为大小为 0.2×0.2 米或 20×20 厘米的红色矩形，这与真实的炮弹非常接近。当然，你们当中的海盗可能会选择更真实的尺寸。

最初，炮弹的位置将是(0，0)—与大炮的位置相同。速度也将是(0，0)。因为你在每次更新中应用重力，炮弹将简单地垂直落下。

一旦接收到触发事件，将球的位置设置回(0，0)并将其初始速度设置为(`Math.cos(cannonAngle)`、`Math.sin(cannonAngle)`)。这将确保炮弹沿着大炮指向的方向飞行。同样，简单地通过将速度乘以接触点和大炮之间的距离来设置速度。接触点离大炮越近，炮弹飞得越慢。

听起来很简单，所以现在你可以尝试实现它。将代码从`CannonTest`复制到一个名为`CannonGravityTest.java`的新文件中。将该文件中包含的类重命名为`CannonGravityTest`和`CannonGravityScreen`。[清单 8–3](#list_8_3)显示了`CannonGravityScreen`。

**清单 8–3。** *摘自炮弹重量测试*

`**class** CannonGravityScreen **extends** Screen {
    **float** FRUSTUM_WIDTH = 9.6f;
    **float** FRUSTUM_HEIGHT = 6.4f;
    GLGraphics glGraphics;
    Vertices cannonVertices;
    Vertices ballVertices;
    Vector2 cannonPos = **new** Vector2();
    **float** cannonAngle = 0;
    Vector2 touchPos = **new** Vector2();
    Vector2 ballPos = **new** Vector2(0,0);
    Vector2 ballVelocity = **new** Vector2(0,0);
    Vector2 gravity = **new** Vector2(0,-10);`

没什么变化。您简单地将视见体的大小增加了一倍，并通过将`FRUSTUM_WIDTH`和`FRUSTUM_HEIGHT`分别设置为 9.6 和 6.2 来反映这一点。这意味着你可以看到一个 9.2×6.2 米的长方形的世界。因为您也想绘制炮弹，所以添加另一个名为`ballVertices`的`Vertices`实例，它将保存炮弹矩形的四个顶点和六个索引。新成员`ballPos`和`ballVelocity`存储炮弹的位置和速度，成员`gravity`是重力加速度，它将在程序的生命周期内保持恒定(0，10) m/s。

`    **public** CannonGravityScreen(Game game) {
        **super**(game);
        glGraphics = ((GLGame) game).getGLGraphics();
        cannonVertices = **new** Vertices(glGraphics, 3, 0, **false**, **false**);
        cannonVertices.setVertices(**new float**[] { -0.5f, -0.5f,
                                           0.5f, 0.0f,
                                          -0.5f, 0.5f }, 0, 6);
        ballVertices = **new** Vertices(glGraphics, 4, 6, **false**, **false**);
        ballVertices.setVertices(**new float**[]  { -0.1f, -0.1f,
                                                0.1f, -0.1f,
                                                0.1f,  0.1f,
                                               -0.1f,  0.1f }, 0, 8);
        ballVertices.setIndices(**new short**[] {0,  1, 2, 2, 3, 0}, 0, 6);

    }`

在构造函数中，只需为炮弹的矩形创建额外的`Vertices`实例。用顶点(0.1、0.1)、(0.1、0.1)、(0.1、0.1)和(0.1、0.1)在模型空间中定义它。使用索引绘图，因此在这种情况下指定六个顶点。

`@Override
    **public void** update(**float** deltaTime) {
        List<TouchEvent> touchEvents = game.getInput().getTouchEvents();
        game.getInput().getKeyEvents();` `        **int** len = touchEvents.size();
        **for** (**int** i = 0; i < len; i++) {
            TouchEvent event = touchEvents.get(i);

            touchPos.x = (event.x / (**float**) glGraphics.getWidth())
                    * FRUSTUM_WIDTH;
            touchPos.y = (1 - event.y / (**float**) glGraphics.getHeight())
                    * FRUSTUM_HEIGHT;
            cannonAngle = touchPos.sub(cannonPos).angle();

            **if**(event.type == TouchEvent.*TOUCH_UP*) {
                **float** radians = cannonAngle * Vector2.*TO_RADIANS*;
                **float** ballSpeed = touchPos.len();
                ballPos.set(cannonPos);
                ballVelocity.x = FloatMath.*cos*(radians) * ballSpeed;
                ballVelocity.y = FloatMath.*sin*(radians) * ballSpeed;
            }
        }

        ballVelocity.add(gravity.x * deltaTime, gravity.y * deltaTime);
        ballPos.add(ballVelocity.x * deltaTime, ballVelocity.y * deltaTime);
    }`

`update()`方法仅略有改变。世界坐标中接触点的计算和加农炮的角度仍然相同。第一个添加是事件处理循环中的`if`语句。万一你得到了一个润色事件，你就准备好要射的炮弹。将加农炮的瞄准角度转换为弧度，稍后你会用到`FastMath.cos()`和`FastMath.sin()`。接下来，计算大炮和接触点之间的距离。这将是炮弹的速度。将球的位置设置为大炮的位置。最后，计算炮弹的初速度。使用正弦和余弦，如前一节所述，从加农炮的角度构建一个方向向量。将这个方向向量乘以炮弹的速度，得到最终的炮弹速度。这很有趣，因为炮弹从一开始就有这个速度。在现实世界中，在给定空气阻力、重力和大炮施加的力的情况下，炮弹当然会从 0 米/秒加速到它所能达到的任何速度。不过，您可以在这里作弊，因为加速将发生在一个非常小的时间窗口内(几百毫秒)。在`update()`方法中你做的最后一件事是更新炮弹的速度，并基于此调整它的位置。

`@Override
    **public void** present(**float** deltaTime) {

        GL10 gl = glGraphics.getGL();
        gl.glViewport(0, 0, glGraphics.getWidth(), glGraphics.getHeight());
        gl.glClear(GL10.*GL_COLOR_BUFFER_BIT*);
        gl.glMatrixMode(GL10.*GL_PROJECTION*);
        gl.glLoadIdentity();
        gl.glOrthof(0, FRUSTUM_WIDTH, 0, FRUSTUM_HEIGHT, 1, -1);
        gl.glMatrixMode(GL10.*GL_MODELVIEW*);

        gl.glLoadIdentity();
        gl.glTranslatef(cannonPos.x, cannonPos.y, 0);` `        gl.glRotatef(cannonAngle, 0, 0, 1);
        gl.glColor4f(1,1,1,1);
        cannonVertices.bind();
        cannonVertices.draw(GL10.*GL_TRIANGLES*, 0, 3);
        cannonVertices.unbind();

        gl.glLoadIdentity();
        gl.glTranslatef(ballPos.x, ballPos.y, 0);
        gl.glColor4f(1,0,0,1);
        ballVertices.bind();
        ballVertices.draw(GL10.*GL_TRIANGLES*, 0, 6);
        ballVertices.unbind();
    }`

在`present()`方法中，简单添加炮弹矩形的渲染。您可以在渲染 cannon 的三角形之后执行此操作，这意味着您必须在渲染矩形之前“清理”模型视图矩阵。用`glLoadIdentity()`做这件事，然后用`glTranslatef()`在球的当前位置将炮弹的矩形从模型空间转换到世界空间。

`    @Override
    **public void** pause() {

    }

    @Override
    **public void** resume() {

    }

    @Override
    **public void** dispose() {

    }        
}`

如果你运行这个例子并触摸几次屏幕，你会对炮弹的飞行有很好的感觉。[Figure 8–7](#fig_8_7)显示了输出结果(这并不令人印象深刻，因为它是静态图像)。

![images](img/0807.jpg)

**图 8–7。** *射出红色长方形的三角炮。印象深刻！*

对你的目的来说，这些物理知识已经足够了。有了这个简单的模型，你可以模拟的远不止炮弹。例如，超级马里奥也可以用同样的方式模拟。如果你曾经玩过超级马里奥兄弟，那么你会注意到马里奥需要一点时间才能达到他奔跑时的最大速度。这可以通过非常快的加速度和速度上限来实现，如前面的伪代码所示。跳跃的实现方式与发射炮弹非常相似。马里奥的当前速度将由 y 轴上的初始跳跃速度来调整(请记住，您可以像添加任何其他向量一样添加速度)。你总是施加一个负的 y 加速度(重力)，这使得他在跳跃后回到地面，或者掉进一个坑里。x 方向的速度不受 y 轴上发生的事情的影响。您仍然可以按左右键来更改 x 轴的速度。这个简单模型的美妙之处在于，它允许您用很少的代码实现非常复杂的行为。当你写下一个游戏时，你可以使用这种类型的物理学。

简单地发射炮弹并不好玩。你希望能够用炮弹击中物体。为此，您需要一种叫做碰撞检测的东西，这可以在下一节中研究。

### 2D 的碰撞检测和物体显示

一旦你的世界中有了移动的物体，你希望它们相互作用。一种这样的交互模式是简单的*碰撞检测*。当两个物体以某种方式重叠时，就说它们在碰撞。当您检查 Nom 先生是咬了自己还是吃了墨迹时，您已经在 Nom 先生中进行了一点碰撞检测。

碰撞检测伴随着*碰撞响应*:一旦你确定两个物体发生了碰撞，你需要通过以合理的方式调整物体的位置和/或移动来对碰撞做出响应。例如，当超级马里奥跳到古姆巴上时，古姆巴会去古姆巴天堂，马里奥会再跳一小段。一个更详细的例子是两个或更多的台球的碰撞和响应。您现在不需要进入这种冲突响应，因为它对您的目的来说是多余的。您的碰撞响应通常包括更改对象的状态(例如，让对象爆炸或死亡，收集硬币，设置分数，等等)。这种类型的反应是依赖于游戏的，所以不会在这一节讨论。

那么，如何判断两个物体是否发生了碰撞呢？首先你需要考虑什么时候检查碰撞。如果您的对象遵循一个简单的物理模型，如上一节所述，您可以在移动当前帧和时间步长的所有对象后检查碰撞。

#### 边界形状

一旦获得了对象的最终位置，就可以执行碰撞测试，这归结为重叠测试。但是重叠的是什么呢？你的每一个对象都需要有某种数学定义的形式或形状来为它提供边界。在这种情况下，正确的术语是*边界形状*。[Figure 8–8](#fig_8_8)显示了一些边界形状的选择。

![images](img/0808.jpg)

**图 8–8。** *鲍勃周围的各种跳跃形状*

图 8–8 中的三种边界形状的属性如下:

*   *三角形网格*:通过用几个三角形近似物体的轮廓，尽可能紧密地限制物体。它需要最大的存储空间，而且很难构建，测试起来也很昂贵。然而，它给出了最精确的结果。您不一定要使用相同的三角形进行渲染，而是简单地存储它们以进行碰撞检测。网格可以存储为顶点列表，每三个后续的顶点形成一个三角形。为了节省内存，还可以使用索引顶点列表。
*   *轴对齐边界框*:通过一个轴对齐的矩形来限制对象，这意味着底部和顶部边缘总是与 x 轴对齐，而左侧和右侧边缘与 y 轴对齐。测试起来也很快，但不如三角形网格精确。边界框通常以其左下角位置加上其宽度和高度的形式存储。(在 2D 的情况下，这些也被称为*边界矩形*)。
*   *包围圆*:用能包含对象的最小圆来包围对象。它的测试速度非常快，但它是最不精确的边界形状。圆通常以圆心位置和半径的形式存储。

除了位置、比例和方向，游戏中的每个对象都有一个包围它的边界形状。当然，当您移动对象时，例如在物理集成步骤中，您需要根据对象的位置、比例和方向来调整边界形状的位置、比例和方向。

调整位置变化很容易:您只需相应地移动边界形状。在三角形网格的情况下，只需移动每个顶点；在边框的情况下，移动左下角；在边界圆的情况下，只需移动圆心。

缩放绑定图形有点困难。你需要定义你缩放的点。这通常是物体的位置，通常作为物体的中心给出。如果您使用这种约定，那么缩放就很容易。对于三角形网格，你缩放每个顶点的坐标；对于边框，缩放其宽度、高度和左下角位置。对于边界圆，缩放其半径(圆心等于对象的中心)。

旋转边界形状还取决于旋转点的定义。使用刚才提到的约定(其中对象中心是旋转点)，旋转也变得容易。在三角形网格的情况下，只需围绕对象的中心旋转所有顶点。在边界圆的例子中，你不需要做任何事情，因为无论你如何旋转你的物体，半径都保持不变。边框更复杂一些。您需要构建所有四个角点，旋转它们，然后找到包围这四个点的轴对齐的边界矩形。[图 8–9](#fig_8_9)显示了旋转后的三个边界形状。

![images](img/0809.jpg)

**图 8–9。** *旋转后的边界形状，以对象的中心为旋转点*

虽然旋转三角形网格或边界圆相当容易，但轴对齐边界框的结果并不令人满意。请注意，原始对象的边界框比其旋转版本更紧密。这就引出了一个问题，你最初是如何为 Bob 得到你的边界形状的。

#### 构造边界形状

在本例中，只需根据 Bob 的图像手动构建边界形状。但是如果鲍勃的图像是以像素为单位的，而你的世界是以米为单位的呢？这个问题的解决方案涉及规范化和模型空间。想象一下当你用 OpenGL 渲染 Bob 时，你在模型空间中为他使用的两个三角形。该矩形在模型空间中以原点为中心，并具有与 Bob 的纹理图像相同的纵横比(宽度/高度)(即，纹理贴图中为 32×32 像素，而模型空间中为 2×2 m)。现在，您可以应用 Bob 的纹理，并计算出模型空间中边界形状的点的位置。[Figure 8–10](#fig_8_10)展示了如何在模型空间中围绕 Bob 构建边界形状。

![images](img/0810.jpg)

**图 8–10。** *在模型空间中围绕 Bob 包围形状*

这个过程可能看起来有点麻烦，但涉及的步骤并不那么难。首先你要记住的是纹理映射是如何工作的。您在纹理空间中为 Bob 的矩形(由两个三角形组成)的每个顶点指定纹理坐标。纹理空间中纹理图像的左上角在(0，0)，左下角在(1，1)，不管图像的实际宽度和高度是多少像素。要从图像的像素空间转换到纹理空间，可以使用这个简单的转换:

`u = x / imageWidth
v = y / imageHeight`

其中`u`和`v`是由`x`和`y`给出的像素在图像空间中的纹理坐标。`imageWidth`和`imageHeight`被设置为图像的像素尺寸(在 Bob 的例子中为 32×32)。[Figure 8–11](#fig_8_11)显示了 Bob 的图像中心如何映射到纹理空间。

![images](img/0811.jpg)

**图 8–11。** *将一个像素从图像空间映射到纹理空间*

纹理被应用到你在模型空间中定义的矩形上。在[图 8–10](#fig_8_10)中，有一个左上角在(1，1)和右下角在(1，1)的例子。您可以使用米作为世界中的单位，因此矩形的宽度和高度为 2 米。此外，您知道左上角的纹理坐标为(0，0)，右下角的纹理坐标为(1，1)，因此您将完整的纹理映射到 Bob。情况并不总是这样，您将在下面的某一节中看到。

现在你需要一个通用的方法来从纹理映射到模型空间。通过在纹理和模型空间中将贴图限制为仅轴对齐的矩形，可以让您的工作变得简单一些。假设纹理空间中的轴对齐矩形区域被映射到模型空间中的轴对齐矩形。对于转换，您需要知道模型空间中矩形的宽度和高度，以及纹理空间中矩形的宽度和高度。在 Bob 示例中，模型空间中有一个 2×2 的矩形，纹理空间中有一个 1×1 的矩形(因为您将完整的纹理映射到矩形)。您还需要知道每个矩形左上角在各自空间中的坐标。对于模型空间矩形，这是(1，1)；对于纹理空间矩形，它是(0，0)(同样，因为您映射的是完整的纹理，而不仅仅是一部分)。有了这些信息以及要映射到模型空间的像素的 u 坐标和 v 坐标，您可以使用以下两个等式进行转换:

`mx = (u − minU) / (tWidth) × mWidth + minX
my = (1 − ((v − minV) / (tHeight))× mHeight - minY`

变量`u`和`v`是在最后一次从像素到纹理空间的变换中计算的坐标。变量`minU`和`minV`是你从纹理空间映射的区域左上角的坐标。变量`tWidth`和`tHeight`是你的纹理空间区域的宽度和高度。变量`mWidth`和`mHeight`是你的模型空间矩形的宽度和高度。变量`minX`和`minY`是模型空间中矩形左上角的坐标。最后，您有`mx`和`my`，它们是模型空间中的变换坐标。

这些方程采用 u 坐标和 v 坐标，将它们映射到范围 0 到 1，然后在模型空间中缩放和定位它们。[Figure 8–12](#fig_8_12)显示了纹理空间中的纹理元素，以及它如何映射到模型空间中的矩形。在侧面，你可以看到`tWidth`和`tHeight`，以及`mWidth`和`mHeight`。每个矩形的左上角对应于纹理空间中的(`minU`、`minV)`)和模型空间中的(`minX`、`minY)`)。

![images](img/0812.jpg)

**图 8–12。** *从纹理空间到模型空间的映射*

代入前两个方程，可以直接从像素空间到模型空间:

`mx = ((x/imageWidth) − minU) / (tWidth) * mWidth + minX
my = (1 − (((y/imageHeight) − minV) / (tHeight)) * mHeight − minY`

您可以使用这两个等式，根据通过纹理映射映射到矩形的图像来计算对象的边界形状。在三角形网格的情况下，这可能有点乏味；包围矩形和包围圆形的情况要容易得多。通常，你不需要走这条艰难的路，而是创建你的纹理，使边界矩形至少具有与你通过 OpenGL ES 渲染的矩形相同的纵横比。这样，您可以直接从对象的图像维度构建边框。边界圆也是如此。希望这已经向您展示了，给定一个映射到模型空间中的矩形的图像，如何构建一个任意的边界形状。

现在你应该知道如何为你的 2D 物体构造一个合适的边界形状。但是请记住，在创建图形资源时手动定义这些边界形状大小，并定义游戏世界中对象的单位和大小。然后，您可以在代码中使用这些大小来碰撞对象。

#### 游戏对象属性

鲍勃变得更胖了。除了用于渲染的网格(映射到 Bob 的图像纹理的矩形)，现在还有第二个数据结构以某种形式保存他的边界。认识到这一点很重要，当您在模型空间中对 Bob 的映射版本进行边界建模时，实际边界与 Bob 的矩形映射到的纹理区域无关。当然，在创建边界形状时，请尝试在纹理中与 Bob 图像的轮廓紧密匹配。然而，纹理图像是 32×32 还是 128×128 像素并不重要。因此，您世界中的对象有三个属性组:

*   它的位置、方向、比例、速度和加速度。有了这些，你就可以应用上一节的物理模型了。当然，有些对象可能是静态的，因此只有位置、方向和比例。通常你甚至可以忽略方向和比例。物体的位置通常与模型空间中的原点重合，如图[图 8–10](#fig_8_10)所示。这使得一些计算更容易。
*   它的边界形状(通常在围绕对象中心的模型空间中构建)，与它的位置一致，并与对象的方向和比例对齐，如图[Figure 8–10](#fig_8_10)所示。这给了你的对象一个边界，并定义了它在世界上的大小。你可以把这个形状做得尽可能复杂。例如，您可以将它做成几个边界形状的组合。
*   它的图形表示。如图[Figure 8–12](#fig_8_12)所示，你仍然使用两个三角形为 Bob 组成一个矩形，并将他的图像纹理映射到这个矩形上。矩形在模型空间中定义，但不一定等于边界形状，如图[Figure 8–10](#fig_8_10)所示。您发送到 OpenGL ES 的 Bob 的图形矩形略大于 Bob 的边界矩形。

这种属性分离允许您应用模型-视图-控制器(MVC)模式。

*   在模型端，有 Bob 的物理属性，包括他的位置、比例、旋转、速度、加速度和边界形状。Bob 的位置、比例和方向决定了他的边界形状在世界空间中的位置。
*   该视图简单地采用 Bob 的图形表示(即模型空间中定义的两个纹理映射的三角形)，并根据 Bob 的位置、旋转和缩放在它们的世界空间位置呈现它们。在这里，您可以像以前一样使用 OpenGL ES 矩阵运算。
*   控制器负责根据用户输入更新 Bob 的物理属性(例如，按下左按钮可以将他向左移动)，并根据物理力，例如重力加速度(就像您在上一节中应用于炮弹一样)。

当然，Bob 的边界形状和他在纹理中的图形表示之间有一些对应关系，因为边界形状基于该图形表示。因此，你的 MVC 模式并不完全干净，但是你可以忍受。

#### 宽相位和窄相位碰撞检测

但是，您仍然不知道如何检查对象和它们的边界形状之间的碰撞。碰撞检测有两个阶段:

> 广泛阶段:在这个阶段，你试图找出哪些物体可能会发生碰撞。想象一下，有 100 个物体可能会相互碰撞。如果您天真地选择用其他对象来测试每个对象，那么您需要执行 100 × 100 / 2 的重叠测试。这种简单的重叠测试方法具有 O( *n* )的渐近复杂度，这意味着它需要 n 个步骤才能完成(实际上它可以在一半的步骤中完成，但是渐近复杂度忽略了任何常数)。在一个良好的、非暴力的阶段，你可以试着找出哪对物体实际上有碰撞的危险。其他对(例如，两个对象相距太远而不会发生碰撞)将不会被检查。您可以通过这种方式减少计算量，因为窄阶段测试通常非常昂贵。
> 
> *窄阶段*:一旦你知道哪对物体有可能碰撞，你就通过对它们的边界形状做重叠测试来测试它们是否真的碰撞。

你可以先把注意力集中在狭窄的阶段，然后把宽广的阶段留到以后。

##### 窄相位

一旦完成了粗略阶段，你必须检查潜在碰撞物体的边界形状是否重叠。前面提到过，你有几个选择来限制形状。三角形网格是创建时计算量最大且最麻烦的。事实证明，在大多数 2D 游戏中，你可以避开包围矩形和包围圆形，所以这就是你在这里可以集中精力的地方。

###### 圆形碰撞

边界圆是检查两个物体是否碰撞的最便宜的方法。让我们定义一个简单的`Circle`类。[清单 8–4](#list_8_4)显示了代码。

**清单 8–4。**Circle.java*一个简单的圆类*

`**package** com.badlogic.androidgames.framework.math;

**public class** Circle {
    **public final** Vector2 center = **new** Vector2();
    **public float** radius;

    **public** Circle(**float** x, **float** y, **float** radius) {
        **this**.center.set(x,y);
        **this**.radius = radius;
    }
}`

您将中心存储为一个`Vector2`并将半径存储为一个简单的浮点数。如何检查两个圆是否重叠？看[图 8–13](#fig_8_13)。

![images](img/0813.jpg)

**图 8–13。** *两个圆重叠(左)，两个圆不重叠(右)*

它非常简单，计算效率高。你需要做的就是算出两个中心之间的距离。如果距离大于两个半径之和，那么你知道这两个圆不重叠。在代码中，这将如下所示:

`**public boolean** overlapCircles(Circle c1, Circle c2) {` `    **float** distance = c1.center.dist(c2.center);
    **return** distance <= c1.radius + c2.radius;
}`

首先，测量两个中心之间的距离，然后检查距离是否小于或等于半径之和。

你必须在`Vector2.dist()`方法中取一个平方根。这是不幸的，因为求平方根是一个代价很高的操作。你能快点吗？是的，你可以——你需要做的只是重新定义你的条件:

`sqrt(dist.x × dist.x + dist.y × dist.y) <= radius1 + radius2`

通过对不等式的两边取幂，可以去掉平方根，如下所示:

`dist.x × dist.x + dist.y × dist.y <= (radius1 + radius2) × (radius1 + radius2)`

你用平方根换另一个右边的加法和乘法。这个好多了。现在你可以创建一个`Vector2.distSquared()`函数来返回两个向量之间的平方距离:

`**public float** distSquared(Vector2 other) {
    **float** distX = **this**.x - other.x;
    **float** distY = **this**.y - other.y;
    **return** distX*distX + distY*distY;
}`

`overlapCircles()`方法变成如下:

`**public boolean** overlapCircles(Circle c1, Circle c2) {
    **float** distance = c1.center.distSquared(c2.center);
    **float** radiusSum = c1.radius + c2.radius;
    **return** distance <= radiusSum * radiusSum;
}`

###### 矩形碰撞

现在你可以继续矩形。首先，您需要一个可以表示矩形的类。如前所述，您希望矩形由其左下角位置加上其宽度和高度来定义。在[清单 8–5](#list_8_5)中你就是这么做的。

**清单 8–5。**Rectangle.java 的*，一个长方形类*

`**package** com.badlogic.androidgames.framework.math;

**public class** Rectangle {
    **public final** Vector2 lowerLeft;
    **public float** width, height;

    **public** Rectangle(**float** x, **float** y, **float** width, **float** height) {
        **this**.lowerLeft = **new** Vector2(x,y);
        **this**.width = width;
        **this**.height = height;
    }
}`

将左下角的位置存储在一个`Vector2`中，宽度和高度存储在两个浮点数中。如何检查两个矩形是否重叠？[图 8–14](#fig_8_14)应该给你一个提示。

![images](img/0814.jpg)

**图 8–14。** *大量重叠和不重叠的矩形*

部分重叠和不重叠的前两种情况很容易。最后一个是惊喜。当然，一个矩形可以完全包含在另一个矩形中。这也可能发生在圆的情况下。但是，如果一个圆包含在另一个圆中，您的圆重叠测试将返回正确的结果。

起初，在矩形情况下检查重叠看起来很复杂。然而，如果您使用一点逻辑，您可以创建一个非常简单的测试。下面是检查两个矩形之间重叠的最简单方法:

`**public boolean** overlapRectangles(Rectangle r1, Rectangle r2) {
    **if**(r1.lowerLeft.x< r2.lowerLeft.x + r2.width&&
       r1.lowerLeft.x + r1.width> r2.lowerLeft.x&&
       r1.lowerLeft.y< r2.lowerLeft.y + r2.height&&
       r1.lowerLeft.y + r1.height> r2.lowerLeft.y)
        **return true**;
    **else**
        **return false**;
}`

乍一看，这看起来有点混乱，所以让我们检查一下每个条件。第一个条件规定第一个矩形的左边缘必须在第二个矩形右边缘的左边。下一个条件声明第一个矩形的右边缘必须在第二个矩形左边缘的右边。其他两个条件同样适用于矩形的顶部和底部边缘。如果所有这些条件都满足，那么这两个矩形重叠。用[图 8–14](#fig_8_14)再次检查。它还涵盖了遏制情况。

###### 圆形/矩形碰撞

你能检查圆和矩形之间的重叠部分吗？是的，你可以。然而，这有点复杂。看看[图 8–15](#fig_8_15)。

![images](img/0815.jpg)

**图 8-15。**

测试圆形和矩形之间重叠的总体策略如下:

*   在距离圆心最近的矩形上或矩形内找到 x 坐标。此坐标可以是矩形左边缘或右边缘上的点，除非圆心包含在矩形中，在这种情况下，最接近的 x 坐标是圆心的 x 坐标。
*   在距离圆心最近的矩形上或矩形内找到 y 坐标。该坐标可以是矩形上边缘或下边缘上的点，除非圆心包含在矩形中，在这种情况下，最接近的 y 坐标是圆心的 y 坐标。
*   如果由最近的 x 和 y 坐标组成的点在圆内，则圆和矩形重叠。

虽然没有在[图 8–15](#fig_8_15)中描述，但该方法也适用于完全包含矩形的圆。编码:

`**public boolean** overlapCircleRectangle(Circle c, Rectangle r) {
    **float** closestX = c.center.x;
    **float** closestY = c.center.y;

    **if**(c.center.x< r.lowerLeft.x) {
        closestX = r.lowerLeft.x;
    }
    **else if**(c.center.x> r.lowerLeft.x + r.width) {
        closestX = r.lowerLeft.x + r.width;
    }

    **if**(c.center.y< r.lowerLeft.y) {
        closestY = r.lowerLeft.y;
    }
    **else if**(c.center.y> r.lowerLeft.y + r.height) {
        closestY = r.lowerLeft.y + r.height;
    }

    **return** c.center.distSquared(closestX, closestY) < c.radius *c.radius;
}`

描述看起来比实现可怕得多。您确定矩形上距离圆最近的点，然后简单地检查该点是否位于圆内。如果是这样，圆和矩形之间就有重叠。

注意，您向`Vector2`添加了一个重载的`distSquared()`方法，它采用两个浮点参数，而不是另一个`Vector2`。对`dist()`功能做同样的操作。

###### 把这一切放在一起

检查一个点是否位于圆或矩形内也很有用。您可以再编写两个方法，并将它们与您刚刚定义的其他三个方法放在一个名为`OverlapTester`的类中。[清单 8–6](#list_8_6)显示了代码。

**清单 8–6。**OverlapTester.java*；测试圆、矩形和点之间的重叠*

`**package** com.badlogic.androidgames.framework.math;

**public class** OverlapTester {
    **public static boolean** overlapCircles(Circle c1, Circle c2) {
        **float** distance = c1.center.distSquared(c2.center);
        **float** radiusSum = c1.radius + c2.radius;
        **return** distance <= radiusSum * radiusSum;
    }

    **public static boolean** overlapRectangles(Rectangle r1, Rectangle r2) {
        **if**(r1.lowerLeft.x< r2.lowerLeft.x + r2.width&&
           r1.lowerLeft.x + r1.width> r2.lowerLeft.x&&
           r1.lowerLeft.y< r2.lowerLeft.y + r2.height&&
           r1.lowerLeft.y + r1.height> r2.lowerLeft.y)
            **return true**;
        **else**
            **return false**;
    }

    **public static boolean** overlapCircleRectangle(Circle c, Rectangle r) {
        **float** closestX = c.center.x;
        **float** closestY = c.center.y;

        **if**(c.center.x < r.lowerLeft.x) {
            closestX = r.lowerLeft.x;
        }
        **else if**(c.center.x> r.lowerLeft.x + r.width) {
            closestX = r.lowerLeft.x + r.width;
        }

        **if**(c.center.y< r.lowerLeft.y) {
            closestY = r.lowerLeft.y;
        }
        **else if**(c.center.y> r.lowerLeft.y + r.height) {
            closestY = r.lowerLeft.y + r.height;
        }

        **return** c.center.distSquared(closestX, closestY) < c.radius * c.radius;
    }` `    **public static boolean** pointInCircle(Circle c, Vector2 p) {
        **return** c.center.distSquared(p) < c.radius * c.radius;
    }

    **public static boolean** pointInCircle(Circle c, **float** x, **float** y) {
        **return** c.center.distSquared(x, y) < c.radius * c.radius;
    }

    **public static boolean** pointInRectangle(Rectangle r, Vector2 p) {
        **return** r.lowerLeft.x<= p.x&& r.lowerLeft.x + r.width>= p.x&&
               r.lowerLeft.y<= p.y&& r.lowerLeft.y + r.height>= p.y;
    }

    **public static boolean** pointInRectangle(Rectangle r, **float** x, **float** y) {
        **return** r.lowerLeft.x<= x && r.lowerLeft.x + r.width>= x &&
               r.lowerLeft.y<= y && r.lowerLeft.y + r.height>= y;
    }
}`

太好了，现在你有了一个全功能的 2D 数学库，可以用于你所有的小物理模型和碰撞检测。现在，您可以更详细地了解一下广义阶段。

##### 宽相位

那么，如何才能实现 broad phase 承诺的魔力呢？看[图 8–16](#fig_8_16)，展示了一个典型的超级马里奥兄弟场景。

![images](img/0816.jpg)

**图 8–16。** *超级马里奥和他的敌人。对象周围的方框是它们的包围矩形；这些大盒子构成了一个强加于世界的网格。*

你能猜出你能做些什么来消除一些检查吗？图 8–16 中的蓝色网格代表可以用来划分你的世界的单元。每个细胞大小完全相同，整个世界都被细胞覆盖。马里奥目前在其中的两个单元中，马里奥可能与之相撞的其他物体在不同的单元中。因此，您不需要检查任何碰撞，因为马里奥与场景中的任何其他对象都不在同一个单元中。你只需要做以下事情:

*   基于物理和控制器步骤更新世界上的所有对象。
*   根据对象的位置更新每个对象的边界形状的位置。你当然也可以包括方位和尺度。
*   根据边界形状，找出每个对象包含在哪个或哪些单元格中，并将它们添加到这些单元格中包含的对象列表中。
*   检查碰撞，但只在可能碰撞的对象对之间(例如，Goombas 不会与其他 Goombas 碰撞)并且在同一单元中。

这被称为*空间散列网格*宽阶段，并且非常容易实现。你首先要定义的是每个单元格的大小。这很大程度上取决于你在游戏世界中使用的比例和单位。

#### 一个精心制作的例子

基于你上一个炮弹的例子开发一个空间散列网格。到目前为止，您将完全重写它，以包含本节中涉及的所有内容。除了大炮和球，你也要有靶子。让你的生活变得简单，只需使用 0.5×0.5 米的正方形作为目标。这些方块不会移动；它们是静态的。你的大炮也是静态的。唯一会动的是炮弹本身。你通常可以将游戏世界中的物体分为静态物体和动态物体。现在，您可以设计一个表示这些对象的类。

##### 游戏对象、动态游戏对象和大炮

让我们从清单 8–7 中的静态情况或基本情况开始。

**清单 8–7。GameObject.java***，一个有位置和边界的静态游戏对象*

`**package** com.badlogic.androidgames.gamedev2d;

**import** com.badlogic.androidgames.framework.math.Rectangle;
**import** com.badlogic.androidgames.framework.math.Vector2;

**public class** GameObject {
    **public final** Vector2 position;
    **public final** Rectangle bounds;` `    **public** GameObject(**float** x, **float** y, **float** width, **float** height) {
        **this**.position = **new** Vector2(x,y);
        **this**.bounds = **new** Rectangle(x-width/2, y-height/2, width, height);
    }
}`

游戏中的每个物体都有一个与其中心重合的位置。此外，让每个对象有一个单一的边界形状，在这种情况下是一个矩形。在构造函数中，根据参数设置位置和边框(以对象的中心为中心)。

对于动态对象(即移动的对象)，您还需要跟踪速度和加速度(如果它们实际上是自己加速的——例如，通过引擎或推进器)。[清单 8–8](#list_8_8)显示了`DynamicGameObject`类的代码。

**清单 8–8。** *DynamicGameObject.java:用速度和加速度向量扩展游戏对象*

`**package** com.badlogic.androidgames.gamedev2d;

**import** com.badlogic.androidgames.framework.math.Vector2;

**public class** DynamicGameObject **extends** GameObject {
    **public final** Vector2 velocity;
    **public final** Vector2 accel;

    **public** DynamicGameObject(**float** x, **float** y, **float** width, **float** height) {
        **super**(x, y, width, height);
        velocity = **new** Vector2();
        accel = **new** Vector2();
    }
}`

您扩展了`GameObject`类来继承位置和边界成员。此外，为速度和加速度创建向量。一个新的动态游戏对象在初始化后将会有零速度和零加速度。

在您的炮弹示例中，您有大炮、炮弹和目标。炮弹是一个`DynamicGameObject`，因为它按照你的简单物理模型移动。目标是静态的，可以使用标准`GameObject`来实现。加农炮也可以通过`GameObject`类来实现。您将从`GameObject`类派生出一个`Cannon`类，并添加一个存储加农炮当前角度的字段。[清单 8–9](#list_8_9)显示了代码。

**清单 8–9。** *Cannon.java:用角度扩展游戏对象*

`**package** com.badlogic.androidgames.gamedev2d;

**public class** Cannon **extends** GameObject {
    **public float** angle;

    **public** Cannon(**float** x, **float** y, **float** width, **float** height) {
        **super**(x, y, width, height);
        angle = 0;
    }
}`

这很好地封装了在你的加农炮世界中表现一个物体所需的所有数据。每次你需要一个特殊的物体，比如加农炮，你可以简单地从`GameObject`得到一个，如果它是一个静态物体，或者从`DynamicGameObject`得到一个，如果它有速度和加速度。

**注意:**过度使用继承会导致严重的问题和非常丑陋的代码架构。不要为了使用它而使用它。刚刚使用的简单的类层次结构是可以的，但是你不应该让它变得更深(例如，通过扩展`Cannon`)。游戏对象有不同的表现形式，通过组合来消除所有的继承。不过，对于您的目的来说，简单的继承已经足够了。如果你对其他表现感兴趣，在网上搜索“复合”或“混合”。

##### 空间散列网格

您的加农炮将以 1×1 米的矩形为边界，炮弹将以 0.2×0.2 米的矩形为边界，每个目标将以 0.5×0.5 米的矩形为边界。边界矩形以每个对象的位置为中心，以使您的生活稍微轻松一些。

当您的 cannon 示例启动时，您可以简单地在任意位置放置多个目标。以下是在您的世界中设置对象的方法:

`Cannon cannon = **new** Cannon(0, 0, 1, 1);
DynamicGameObject ball = **new** DynamicGameObject(0, 0, 0.2f, 0.2f);
GameObject[] targets = **new** GameObject[NUM_TARGETS];
**for**(**int** i = 0; i < NUM_TARGETS; i++) {
    targets[i] = **new** GameObject((**float**)Math.*random*() * WORLD_WIDTH,
                                (**float**)Math.*random*() * WORLD_HEIGHT,
                                0.5f, 0.5f);  
}`

常数`WORLD_WIDTH`和`WORLD_HEIGHT`定义了你的游戏世界的大小。一切都应该发生在由(0，0)和(`WORLD_WIDTH`、`WORLD_HEIGHT`)所围成的矩形内。[图 8–17](#fig_8_17)显示了目前为止游戏世界的一个小模型。

![images](img/0817.jpg)

**图 8–17。** *你的游戏世界的实体模型*

您的世界稍后将会是这个样子，但是现在您可以覆盖一个空间散列网格。散列网格的单元应该有多大？虽然没有灵丹妙药，但是让它们比场景中最大的物体大五倍还是有帮助的。在您的示例中，最大的对象是加农炮，但您没有用加农炮碰撞任何东西，因此您可以将网格大小基于场景中下一个最大的对象，即目标。这些尺寸是 0.5×0.5 米。因此，网格单元的大小应为 2.5×2.5 米。[Figure 8–18](#fig_8_18)显示了覆盖在您的世界上的网格。

![images](img/0818.jpg)

**图 8–18。** *你的大炮世界，覆盖着由 12 个单元组成的空间散列网格*

你有固定数量的细胞——在加农炮世界中，是 12 个。给每个单元格一个唯一的编号，从左下角的单元格开始，该单元格的 ID 为 0。请注意，顶部的单元格实际上延伸到世界之外。这不是问题；你只需要确保你所有的对象都在世界的边界之内。

你要做的是找出一个对象属于哪个(哪些)单元。理想情况下，您希望计算包含该对象的单元格的 id。这允许您使用以下简单的数据结构来存储单元格:

`List<GameObject>[] cells;`

没错；您将每个单元格表示为一组`GameObject`的列表。空间散列网格本身就是由一组`GameObject`的列表组成的。

现在，您可以计算出包含对象的单元格的 id。[Figure 8–18](#fig_8_18)显示了跨越两个单元格的几个目标。事实上，一个小对象最多可以跨越四个单元格，一个比网格单元格大的对象可以跨越四个以上的单元格。您可以通过选择网格单元大小为游戏中最大对象大小的倍数来确保这种情况不会发生。这就给我们留下了一种可能性，一个物体最多包含在四个单元格中。

要计算一个对象的单元 id，只需取边界矩形的四个角点，并检查每个角点在哪个单元中。确定一个点所在的像元很容易，只需用像元宽度除其坐标。假设在(3，4)处有一个点，像元大小为 2.5×2.5 m:该点将位于 ID 为 5 的像元中，如图[Figure 8–18](#fig_8_18)所示。

您可以将每个点的坐标除以像元大小来获得 2D 整数坐标，如下所示:

`cellX = floor(point.x / cellSize) = floor(3 / 2.5) = 1
cellY = floor(point.y / cellSize) = floor(4 / 2.5) = 1`

从这些单元格坐标中，您可以轻松获得单元格 ID:

`cellId = cellX + cellY × cellsPerRow = 1 + 1 × 4 = 5`

常数`cellsPerRow`就是在 x 轴上用单元格覆盖你的世界所需的单元格数:

`cellsPerRow = ceil(worldWidth / cellSize) = ceil(9.6 / 2.5) = 4`

您可以计算每列所需的单元格数量，如下所示:

`cellsPerColumn = ceil(worldHeight / cellSize) = ceil(6.4 / 2.5) = 3`

基于此，您可以相当容易地实现空间散列网格。你通过给它世界的大小和想要的细胞大小来设置它。假设所有的动作都发生在世界的正象限。这意味着世界上所有点的 x 和 y 坐标都是正的。这是一个你可以接受的约束。

根据参数，空间散列网格可以计算出它需要多少个单元(`cellsPerRow` × `cellsPerColumn`)。您还可以添加一个简单的方法来将对象插入到网格中，该方法将使用对象的边界来确定包含该对象的单元格。然后，该对象将被添加到它包含的每个单元格的对象列表中。如果对象边界形状的一个角点在网格之外，您可以忽略该角点。

更新位置后，将每个对象重新插入到每个帧的空间散列网格中。然而，在你的加农炮世界中有不动的物体，所以为每一帧重新插入它们是非常浪费的。通过在每个单元格中存储两个列表来区分动态对象和静态对象。一个会每帧更新一次，只有持有移动物体，另一个是静态的，只有插入新的静态物体时才会修改。

最后，您需要一个方法来返回您希望与其他对象碰撞的对象的单元格中的对象列表。这个方法所做的就是检查有问题的对象在哪些单元格中，检索这些单元格中的动态和静态对象的列表，并将它们返回给调用者。当然，您必须确保不返回任何重复项，如果一个对象位于多个单元格中，就会出现这种情况。

[清单 8–10](#list_8_10)展示了代码(嗯，大部分)。`SpatialHashGrid.getCellIds()`方法将在稍后讨论，因为它有点复杂。

**清单 8–10。** *摘自 SpatialHashGrid.java:一个空间哈希网格实现*

`**package** com.badlogic.androidgames.framework.gl;

**import** java.util.ArrayList;
**import** java.util.List;

**import** com.badlogic.androidgames.gamedev2d.GameObject;

**import** android.util.FloatMath;

**public class** SpatialHashGrid {
    List<GameObject>[] dynamicCells;
    List<GameObject>[] staticCells;
    **int** cellsPerRow;
    **int** cellsPerCol;
    **float** cellSize;
    **int**[] cellIds = **newint**[4];
    List<GameObject>foundObjects;`

如前所述，您存储了两个单元格列表，一个用于动态对象，一个用于静态对象。您还可以存储每行和每列的单元，以便以后可以决定您检查的点是在世界内部还是外部。单元大小也需要被存储。数组`cellIds`是一个工作数组，可以用来存储临时包含的四个单元格 id。如果它只包含在一个单元格中，那么只有数组的第一个元素将被设置为包含整个对象的单元格的单元格 ID。如果对象包含在两个单元格中，那么数组的前两个元素将保存单元格 ID，依此类推。为了指示单元格 id 的数量，您将数组的所有“空”元素设置为–1。`foundObjects`列表也是一个工作列表，你可以在调用`getPotentialColliders()`时返回。为什么您保留这两个成员，而不是在每次需要时实例化一个新的数组和列表？还记得垃圾收集怪物吗？

`@SuppressWarnings("unchecked")
    **public** SpatialHashGrid(**float** worldWidth, **float** worldHeight, **float** cellSize) {
        **this**.cellSize = cellSize;
        **this**.cellsPerRow = (**int**)FloatMath.*ceil*(worldWidth/cellSize);
        **this**.cellsPerCol = (**int**)FloatMath.*ceil*(worldHeight/cellSize);
        **int** numCells = cellsPerRow * cellsPerCol;
        dynamicCells = **new** List[numCells];
        staticCells = **new** List[numCells];
        **for**(**int** i = 0; i < numCells; i++) {
           dynamicCells[i] = **new** ArrayList<GameObject>(10);` `           staticCells[i] = **new** ArrayList<GameObject>(10);
        }
        foundObjects = **new** ArrayList<GameObject>(10);
    }`

该类的构造函数获取世界的大小和所需的单元格大小。根据这些参数，计算需要多少个单元格，并实例化单元格数组和保存每个单元格中包含的对象的列表。初始化`foundObjects`列表。你实例化的所有`ArrayList`的初始容量都是 10 个`GameObject`。这样做是为了避免内存分配。假设一个单元不太可能包含十个以上的`GameObjects`。只要这是真的，数组就不需要调整大小。

`    **public void** insertStaticObject(GameObject obj) {
        **int**[] cellIds = getCellIds(obj);
        **int** i = 0;
        **int** cellId = -1;
        **while**(i <= 3 && (cellId = cellIds[i++]) != -1) {
            staticCells[cellId].add(obj);
        }
    }

    **public void** insertDynamicObject(GameObject obj) {
        **int**[] cellIds = getCellIds(obj);
        **int** i = 0;
        **int** cellId = -1;
        **while**(i <= 3 && (cellId = cellIds[i++]) != -1) {
            dynamicCells[cellId].add(obj);
        }
    }`

接下来是方法`insertStaticObject()`和`insertDynamicObject()`。它们通过调用`getCellIds()`来计算包含该对象的单元格的 id，并相应地将该对象插入到适当的列表中。`getCellIds()`方法实际上将填充`cellIds`成员数组。

`    **public void** removeObject(GameObject obj) {
        **int**[] cellIds = getCellIds(obj);
        **int** i = 0;
        **int** cellId = -1;
        **while**(i <= 3 && (cellId = cellIds[i++]) != -1) {
            dynamicCells[cellId].remove(obj);
            staticCells[cellId].remove(obj);
        }
    }`

您还有一个`removeObject()`方法，可以用它来判断对象在哪个单元格中，然后相应地从动态和静态列表中删除它。例如，当一个游戏对象死亡时，这将是需要的。

`**public void** clearDynamicCells(GameObject obj) {
        **int** len = dynamicCells.length;
        **for**(**int** i = 0; i < len; i++) {
            dynamicCells[i].clear();
        }` `    }`

`clearDynamicCells()`方法将用于清除所有动态单元格列表。如前所述，您需要在重新插入动态对象之前调用这个框架。

`    **public** List<GameObject> getPotentialColliders(GameObject obj) {
        foundObjects.clear();
        **int**[] cellIds = getCellIds(obj);
        **int** i = 0;
        **int** cellId = -1;
        **while**(i <= 3 && (cellId = cellIds[i++]) != -1) {
            **int** len = dynamicCells[cellId].size();
            **for**(**int** j = 0; j < len; j++) {
                GameObject collider = dynamicCells[cellId].get(j);
                **if**(!foundObjects.contains(collider))
                   foundObjects.add(collider);
            }

            len = staticCells[cellId].size();
            **for**(**int** j = 0; j < len; j++) {
                GameObject collider = staticCells[cellId].get(j);
                **if**(!foundObjects.contains(collider))
                    foundObjects.add(collider);
            }
        }
        **return**foundObjects;
    }`

最后，还有`getPotentialColliders()`方法。它接受一个对象，并返回与该对象包含在相同单元格中的相邻对象的列表。使用工作列表`foundObjects`存储找到的对象列表。同样，您不希望每次调用该方法时都实例化一个新的列表。您需要做的就是找出传递给该方法的对象在哪个单元格中。然后，您只需将这些单元格中的所有动态和静态对象添加到`foundObjects`列表中，并确保没有重复的对象。当然，使用`foundObjects.contains()`来检查重复是次优的，但是考虑到找到的对象数量不会很大，在这种情况下使用它是可行的。如果您遇到性能问题，那么这是您优化的首选。可悲的是，这不是小事。当然，你可以使用一个`Set`，但是每次你添加一个对象时，它会在内部分配新的对象。现在，就让它保持原样，要知道如果性能方面出现任何问题，您都可以回头再来。

遗漏的方法是`SpatialHashGrid.getCellIds()`。清单 8–11 显示了它的代码。别害怕，它只是看起来很危险。

**清单 8–11。***spatialhashgrid . Java 的其余部分:实现 getCellIds()*

`**public int**[] getCellIds(GameObject obj) {
        **int** x1 = (**int**)FloatMath.*floor*(obj.bounds.lowerLeft.x / cellSize);
        **int** y1 = (**int**)FloatMath.*floor*(obj.bounds.lowerLeft.y / cellSize);
        **int** x2 = (**int**)FloatMath.*floor*((obj.bounds.lowerLeft.x + obj.bounds.width) / cellSize);
        **int** y2 = (**int**)FloatMath.*floor*((obj.bounds.lowerLeft.y + obj.bounds.height) / cellSize);` `        **if**(x1 == x2 && y1 == y2) {
            **if**(x1 >= 0 && x1 <cellsPerRow&& y1 >= 0 && y1 <cellsPerCol)
                cellIds[0] = x1 + y1 * cellsPerRow;
            **else**
                cellIds[0] = -1;
            cellIds[1] = -1;
            cellIds[2] = -1;
            cellIds[3] = -1;
        }
        **else if**(x1 == x2) {
            **int** i = 0;
            **if**(x1 >= 0 && x1 <cellsPerRow) {
                **if**(y1 >= 0 && y1 <cellsPerCol)
                    cellIds[i++] = x1 + y1 * cellsPerRow;
                **if**(y2 >= 0 && y2 <cellsPerCol)
                    cellIds[i++] = x1 + y2 * cellsPerRow;
            }
            **while**(i <= 3) cellIds[i++] = -1;
        }
        **else if**(y1 == y2) {
            **int** i = 0;
            **if**(y1 >= 0 && y1 <cellsPerCol) {
                **if**(x1 >= 0 && x1 <cellsPerRow)
                    cellIds[i++] = x1 + y1 * cellsPerRow;
                **if**(x2 >= 0 && x2 <cellsPerRow)
                    cellIds[i++] = x2 + y1 * cellsPerRow;
            }
            **while**(i <= 3) cellIds[i++] = -1;

        }
        **else** {
            **int** i = 0;
            **int** y1CellsPerRow = y1 * cellsPerRow;
            **int** y2CellsPerRow = y2 * cellsPerRow;
            **if**(x1 >= 0 && x1 <cellsPerRow&& y1 >= 0 && y1 <cellsPerCol)
                cellIds[i++] = x1 + y1CellsPerRow;
            **if**(x2 >= 0 && x2 <cellsPerRow&& y1 >= 0 && y1 <cellsPerCol)
                cellIds[i++] = x2 + y1CellsPerRow;
            **if**(x2 >= 0 && x2 <cellsPerRow&& y2 >= 0 && y2 <cellsPerCol)
                cellIds[i++] = x2 + y2CellsPerRow;
            **if**(x1 >= 0 && x1 <cellsPerRow&& y2 >= 0 && y2 <cellsPerCol)
                cellIds[i++] = x1 + y2CellsPerRow;
            **while**(i <= 3) cellIds[i++] = -1;
        }
        **return** cellIds;
    }
}`

此方法的前四行计算对象边框左下角和右上角的单元格坐标。这个计算前面已经讨论过了。要理解这个方法的其余部分，请考虑一个对象如何重叠网格单元。有四种可能性:

*   对象包含在单个单元格中。因此，边框的左下角和右上角具有相同的单元坐标。
*   对象与两个单元格水平重叠。左下角在一个单元格中，右上角在右边的单元格中。
*   该对象垂直重叠两个单元格。左下角在一个单元格中，右上角在上面的单元格中。
*   该对象与四个单元格重叠。左下角在一个单元格中，右下角在右边的单元格中，右上角在它上面的单元格中，左上角在第一个单元格上面的单元格中。

这种方法所做的只是为这些可能性中的每一个做一个特例。第一个`if`语句检查单个单元格的情况，第二个`if`语句检查水平双单元格的情况，第三个`if`语句检查垂直双单元格的情况，而`else`块处理对象重叠四个网格单元格的情况。在四个块中的每一个中，确保仅当相应的单元坐标在世界范围内时才设置单元 ID。这就是这个方法的全部内容。

现在，这个方法看起来需要大量的计算能力。的确如此，但比它的规模所暗示的要小。最常见的情况是第一种，处理起来非常便宜。你能看到进一步优化这种方法的机会吗？

##### 把这一切放在一起

让我们把你在这一节收集的所有知识放在一起，形成一个漂亮的小例子。您可以扩展上一节的 cannon 示例，就像几页前讨论的那样。为大炮使用一个`Cannon`对象，为炮弹使用一个`DynamicGameObject`，为目标使用多个`GameObjects`。每个目标的大小为 0.5×0.5 米，随机放置在世界各地。

你希望能够射击这些目标。为此，您需要碰撞检测。你可以循环所有的目标，对照炮弹检查它们，但那会很无聊。使用你新奇的新`SpatialHashGrid`类来加速为当前球位寻找潜在碰撞目标的过程。但是，不要把球或大炮放入格子中，因为那不会真正帮助你。

因为这个例子已经很大了，所以把它分成多个清单。调用测试`CollisionTest`和相应的屏幕`CollisionScreen`。一如既往，你只看屏幕。让我们从[清单 8–12](#list_8_12)中的成员和构造函数开始。

**清单 8–12。** *摘自 CollisionTest.java:成员和构造函数*

`**class** CollisionScreen **extends** Screen {
    **final int** NUM_TARGETS = 20;
    **final float** WORLD_WIDTH = 9.6f;` `    **final float** WORLD_HEIGHT = 4.8f;
    GLGraphics glGraphics;        
    Cannon cannon;
    DynamicGameObject ball;
    List<GameObject>targets;
    SpatialHashGrid grid;

    Vertices cannonVertices;
    Vertices ballVertices;
    Vertices targetVertices;

    Vector2 touchPos = **new** Vector2();
    Vector2 gravity = **new** Vector2(0,-10);

    **public** CollisionScreen(Game game) {
        **super**(game);
        glGraphics = ((GLGame)game).getGLGraphics();

        cannon = **new** Cannon(0, 0, 1, 1);
        ball = **new** DynamicGameObject(0, 0, 0.2f, 0.2f);
        targets = **new** ArrayList<GameObject>(NUM_TARGETS);
        grid = **new** SpatialHashGrid(WORLD_WIDTH, WORLD_HEIGHT, 2.5f);
        **for**(**int** i = 0; i <NUM_TARGETS; i++) {
            GameObject target = **new** GameObject((**float**)Math.*random*() * WORLD_WIDTH,
                                               (**float**)Math.*random*() * WORLD_HEIGHT,
                                               0.5f, 0.5f);  
            grid.insertStaticObject(target);
            targets.add(target);
        }

        cannonVertices = **new** Vertices(glGraphics, 3, 0, **false**, **false**);
        cannonVertices.setVertices(**new float**[] { -0.5f, -0.5f,
                                                  0.5f, 0.0f,
                                                 -0.5f, 0.5f }, 0, 6);

        ballVertices = **new** Vertices(glGraphics, 4, 6, **false**, **false**);            
        ballVertices.setVertices(**new float**[] { -0.1f, -0.1f,
                                                0.1f, -0.1f,
                                                0.1f,  0.1f,
                                               -0.1f,  0.1f }, 0, 8);
        ballVertices.setIndices(**new short** []{0, 1, 2, 2, 3, 0}, 0, 6);

        targetVertices = **new** Vertices(glGraphics, 4, 6, **false**, **false**);
        targetVertices.setVertices(**new float**[] { -0.25f, -0.25f,
                                                  0.25f, -0.25f,
                                                  0.25f,  0.25f,
                                                 -0.25f,  0.25f }, 0, 8);
        targetVertices.setIndices(**new short**[] {0, 1, 2, 2, 3, 0}, 0, 6);
    }`

你可以从`CannonGravityScreen`带回来很多。从几个恒定的定义开始，控制目标的数量和你的世界的大小。接下来，您有了`GLGraphics`实例，以及大炮、球和目标的对象，它们存储在一个列表中。你当然也有一个`SpatialHashGrid`。为了渲染你的世界，你需要几个网格:一个用于大炮，一个用于球，一个用于渲染每个目标。记住，在`BobTest`中你只需要一个矩形就可以将 100 个 bob 渲染到屏幕上。在这里重用这个原则，而不是让一个`Vertices`实例保存目标的三角形(矩形)。最后两个成员与`CannonGravityTest`中的成员相同。当用户触摸屏幕时，你用它们来击球和施加重力。

构造函数完成前面讨论的所有事情。实例化你的世界物体和网格。唯一有趣的是，您还将目标作为静态对象添加到空间散列网格中。

现在您可以检查清单 8–13 中[类的下一个方法。](#list_8_13)

**清单 8–13。** *摘自 CollisionTest.java: The update()方法*

`@Override
**public void** update(**float** deltaTime) {
    List<TouchEvent> touchEvents = game.getInput().getTouchEvents();
    game.getInput().getKeyEvents();

    **int** len = touchEvents.size();
    **for** (**int** i = 0; i < len; i++) {
        TouchEvent event = touchEvents.get(i);

        touchPos.x = (event.x / (**float**) glGraphics.getWidth())* WORLD_WIDTH;
        touchPos.y = (1 - event.y / (**float**) glGraphics.getHeight()) * WORLD_HEIGHT;

        cannon.angle = touchPos.sub(cannon.position).angle();                      

        **if**(event.type == TouchEvent.*TOUCH_UP*) {
            **float** radians = cannon.angle * Vector2.*TO_RADIANS*;
            **float** ballSpeed = touchPos.len() * 2;
            ball.position.set(cannon.position);
            ball.velocity.x = FloatMath.*cos*(radians) * ballSpeed;
            ball.velocity.y = FloatMath.*sin*(radians) * ballSpeed;
            ball.bounds.lowerLeft.set(ball.position.x - 0.1f, ball.position.y - 0.1f);
        }
    }

    ball.velocity.add(gravity.x * deltaTime, gravity.y * deltaTime);
    ball.position.add(ball.velocity.x * deltaTime, ball.velocity.y * deltaTime);
    ball.bounds.lowerLeft.add(ball.velocity.x * deltaTime, ball.velocity.y * deltaTime);

    List<GameObject> colliders = grid.getPotentialColliders(ball);
    len = colliders.size();
    **for**(**int** i = 0; i < len; i++) {
        GameObject collider = colliders.get(i);
        **if**(OverlapTester.*overlapRectangles*(ball.bounds, collider.bounds)) {
            grid.removeObject(collider);
            targets.remove(collider);
        }
    }
}`

像往常一样，首先获取触摸和按键事件，并且只迭代触摸事件。触摸事件的处理与`CannonGravityTest`中几乎相同。唯一的区别是，您使用了`Cannon`对象，而不是旧的示例中的向量，并且在触发事件后，当大炮准备发射时，您重置了球的边界矩形。

下一个变化是你如何更新球。代替直线向量，使用你为球实例化的`DynamicGameObject`的成员。忽略`DynamicGameObject.acceleration`成员，将你的重力加到球的速度上。把球的速度乘以 2，让炮弹飞得快一点。有趣的是，您不仅更新了球的位置，还更新了边框左下角的位置。这是至关重要的，因为否则你的球会移动，而其边界矩形不会。为什么不简单地用球的外接矩形来存储球的位置呢？您可能希望将多个边界形状附加到一个对象上。那么哪个边界形状会保存对象的实际位置呢？因此，将这两件事分开是有益的，并且只会引入少量的计算开销。当然，你可以通过将速度乘以时间增量来优化它。开销可以归结为两个额外的东西——这是为获得灵活性而付出的小小代价。

这个方法的最后一部分是你的碰撞检测代码。在空间散列网格中找到与您的炮弹在同一单元格中的目标。为此使用`SpatialHashGrid.getPotentialColliders()`方法。因为球所在的单元格是直接在该方法中计算的，所以不需要将球插入到网格中。接下来，遍历所有潜在碰撞器，检查球的边界矩形和潜在碰撞器的边界矩形之间是否真的有重叠。如果有，只需从目标列表中删除目标。请记住，您只能将目标作为静态对象添加到网格中。

这些就是你完整的游戏机制。拼图的最后一块是实际的渲染，这不应该真的让你吃惊。参见[清单 8–14](#list_8_14)中的代码。

**清单 8–14。** *摘自 collision test . Java:present()方法*

`@Override
**public void** present(**float** deltaTime) {
    GL10 gl = glGraphics.getGL();
    gl.glViewport(0, 0, glGraphics.getWidth(), glGraphics.getHeight());
    gl.glClear(GL10.*GL_COLOR_BUFFER_BIT*);
    gl.glMatrixMode(GL10.*GL_PROJECTION*);
    gl.glLoadIdentity();
    gl.glOrthof(0, WORLD_WIDTH, 0, WORLD_HEIGHT, 1, -1);
    gl.glMatrixMode(GL10.*GL_MODELVIEW*);

    gl.glColor4f(0, 1, 0, 1);
    targetVertices.bind();
    **int** len = targets.size();
    **for**(**int** i = 0; i < len; i++) {               
        GameObject target = targets.get(i);
        gl.glLoadIdentity();
        gl.glTranslatef(target.position.x, target.position.y, 0);
        targetVertices.draw(GL10.*GL_TRIANGLES*, 0, 6);
    }
    targetVertices.unbind();

    gl.glLoadIdentity();` `    gl.glTranslatef(ball.position.x, ball.position.y, 0);
    gl.glColor4f(1,0,0,1);
    ballVertices.bind();
    ballVertices.draw(GL10.*GL_TRIANGLES*, 0, 6);
    ballVertices.unbind();  

    gl.glLoadIdentity();
    gl.glTranslatef(cannon.position.x, cannon.position.y, 0);
    gl.glRotatef(cannon.angle, 0, 0, 1);
    gl.glColor4f(1,1,1,1);
    cannonVertices.bind();
    cannonVertices.draw(GL10.*GL_TRIANGLES*, 0, 3);
    cannonVertices.unbind();                    
}`

这里没什么新鲜的。像往常一样，设置投影矩阵和视口，并首先清除屏幕。接下来，渲染所有目标，重用存储在`targetVertices`中的矩形模型。这本质上和你在`BobTest`中做的一样，但是这次你渲染目标。接下来，渲染球和大炮，就像你在`CollisionGravityTest`中做的那样。

这里唯一要注意的是，你改变了绘制顺序，这样球将总是在目标的上方，大炮将总是在球的上方。您还可以通过调用`glColor4f()`将目标涂成绿色。

这个小测试的输出与[图 8–17](#fig_8_17)中的完全相同，因此您可以避免重复。当你发射炮弹时，它会穿过目标区域。任何被球击中的目标都将从世界中移除。

这个例子实际上可能是一个不错的游戏，如果你稍微润色一下，加入一些激励性的游戏机制。你能想到补充吗？稍微摆弄一下这个例子，感受一下你在过去几页中开发的新工具。

这一章还会讨论一些东西:相机，纹理贴图集和精灵。这些使用图形相关的技巧，独立于你的游戏世界模型。该出发了！

### 2D 的一台相机

到目前为止，你的代码中还没有照相机的概念；你只通过`glOrthof()`定义了你的视见体，就像这样:

`gl.glMatrixMode(GL10.*GL_PROJECTION*);
gl.glLoadIdentity();
gl.glOrthof(0, FRUSTUM_WIDTH, 0, FRUSTUM_HEIGHT, 1, -1);`

从[第六章](06.html#ch6)中，你知道前两个参数定义了你的平截头体左右边在世界上的 x 坐标，接下来的两个参数定义了平截头体上下边的 y 坐标，最后两个参数定义了近裁剪平面和远裁剪平面。[图 8–19](#fig_8_19)再次显示了平截头体。

![images](img/0819.jpg)

**图 8–19。**T3【视平体】为你的 2D 世界，再有

所以你只看到你的世界的区域(0，0，1)到(`FRUSTUM_WIDTH`，`FRUSTUM_HEIGHT`，–1)。如果你能移动平截头体，比如说，到左边，不是很好吗？那当然很好，而且也非常简单:

`gl.glOrthof(x, x + FRUSTUM_WIDTH, 0, FRUSTUM_HEIGHT, 1, -1);`

在这种情况下，x 只是一个你定义的偏移量。当然，您也可以在 x 轴和 y 轴上移动:

`gl.glOrthof(x, x + FRUSTUM_WIDTH, y, y +FRUSTUM_HEIGHT, 1, -1);`

[图 8–20](#fig_8_20)显示了这意味着什么。

![images](img/0820.jpg)

**图 8–20。** *左右移动圆台*

只需在世界空间中指定视图截锥的左下角。这已经足以实现自由移动的 2D 相机。但是你可以做得更好。不使用 x 和 y 指定视见体的左下角，而是指定视见体的中心，会怎么样？通过这种方式，您可以轻松地将视见体集中在某个特定位置的对象上，比如前面示例中的炮弹:

`gl.glOrthof(x – FRUSTUM_WIDTH / 2, x + FRUSTUM_WIDTH / 2, y – FRUSTUM_HEIGHT / 2, y +FRUSTUM_HEIGHT / 2, 1, -1);`

[Figure 8–21](#fig_8_21)显示了这种情况。

![images](img/0821.jpg)

**图 8–21。** *指定视见体的中心*

这还不是你能用`glOrthof()`做的全部。变焦呢？让我们想想这个。你知道，通过`glViewportf(),`你可以告诉 OpenGL ES 你希望在屏幕的哪个部分呈现你的视见体的内容。OpenGL ES 将自动拉伸和缩放输出，以与视口对齐。现在，如果你缩小视锥的宽度和高度，你将在屏幕上显示你的世界的一个更小的区域——这就是放大。如果你把平截头体变大，你可以展示你的世界的更多部分——这就是缩小。因此，您可以引入一个缩放因子，并用它乘以您的平截头体的宽度和高度来放大或缩小。系数为 1 将向您展示世界，如图 8–21 中的[所示，使用正常的平截头体宽度和高度。小于 1 的因子将放大视图平截头体的中心，而大于 1 的因子将缩小，向您显示更多的世界(例如，将缩放因子设置为 2 将显示两倍的世界)。下面是你如何使用`glOrthof()`来做到这一点:](#fig_8_21)

`gl.glOrthof(x – FRUSTUM_WIDTH / 2 * zoom, x + FRUSTUM_WIDTH / 2 * zoom, y –
FRUSTUM_HEIGHT / 2 * zoom, y +FRUSTUM_HEIGHT / 2 * zoom, 1, -1);`

非常简单！现在，您可以创建一个 camera 类，它有一个正在查看的位置(视见体的中心)，一个标准的视见体宽度和高度，以及一个使视见体变小或变大的缩放因子，从而显示您的世界的更少部分(放大)或更多部分(缩小)。[图 8–22](#fig_8_22)显示了一个缩放系数为 0.5 的视见平截头体(内部的灰色方框)，以及一个缩放系数为 1 的视见平截头体(外部的透明方框)。

![images](img/0822.jpg)

**图 8–22。** *缩放，通过操纵视锥尺寸*

为了让你的人生完整，你应该再加一件东西。想象一下，你触摸了屏幕，想知道你触摸了 2D 世界中的哪一点。在迭代改进的 cannon 示例中，您已经这样做了几次。如图 8–19 中的[图所示，使用不考虑摄像机位置和缩放的视见体配置，您有以下等式(参见您的 cannon 示例的`update()`方法):](#fig_8_19)

`worldX = (touchX / Graphics.getWidth()) × FRUSTUM_WIDTH;
worldY = (1 – touchY / Graphics.getHeight()) × FRUSTUM_HEIGHT;`

首先，通过除以屏幕的宽度和高度，将触摸的 x 和 y 坐标归一化到 0 到 1 的范围内，然后通过将它们乘以平截头体的宽度和高度来缩放它们，以便用您的世界空间来表示它们。你所需要做的就是考虑视图截锥的位置，以及缩放因子。你可以这样做:

`worldX = (touchX / Graphics.getWidth()) × FRUSTUM_WIDTH + x – FRUSTUM_WIDTH / 2;
worldY = (1 – touchY / Graphics.getHeight()) × FRUSTUM_HEIGHT + y – FRUSTUM_HEIGHT / 2;`

这里，x 和 y 是你的相机在世界空间中的位置。

#### camera 2d 类

让我们把所有这些放在一个类中。您希望它存储摄像机的位置、标准的平截头体宽度和高度以及缩放因子。您还需要一种方便的方法来正确设置视窗(总是使用整个屏幕)和投影矩阵。此外，您需要一种可以将触摸坐标转换为世界坐标的方法。[清单 8–15](#list_8_15)展示了您的新`Camera2D`类。

**清单 8–15。**Camera2D.java*，你闪亮的新相机班为 2D 渲染*

`**package** com.badlogic.androidgames.framework.gl;

**import** javax.microedition.khronos.opengles.GL10;

**import** com.badlogic.androidgames.framework.impl.GLGraphics;
**import** com.badlogic.androidgames.framework.math.Vector2;

**public** **class** Camera2D {
    **public** **final** Vector2 position;
    **public** **float** zoom;
    **public** **final** **float** frustumWidth;
    **public** **final** **float** frustumHeight;
    **final** GLGraphics glGraphics;`

如前所述，您将摄像机的位置、视锥的宽度和高度以及缩放因子作为成员进行存储。位置和缩放因子是公开的，因此您可以轻松地操作它们。您还需要一个对`GLGraphics`的引用，这样您就可以获得屏幕的最新宽度和高度(以像素为单位),以便将触摸坐标转换为世界坐标。

`    **public** Camera2D(GLGraphics glGraphics, **float** frustumWidth, **float** frustumHeight) {
        **this**.glGraphics = glGraphics;
        **this**.frustumWidth = frustumWidth;
        **this**.frustumHeight = frustumHeight;
        **this**.position = **new** Vector2(frustumWidth / 2, frustumHeight / 2);
        **this**.zoom = 1.0f;
    }`

在构造函数中，取一个`GLGraphics`实例，以及缩放因子为 1 的截锥的宽度和高度作为参数。你存储它们并初始化摄像机的位置，使其看着由(0，0，1)和(`frustumWidth`、`frustumHeight`、–1)所包围的盒子的中心，如图[图 8–19](#fig_8_19)所示。初始缩放因子设置为 1。

`    **public** **void** setViewportAndMatrices() {
        GL10 gl = glGraphics.getGL();
        gl.glViewport(0, 0, glGraphics.getWidth(), glGraphics.getHeight());
        gl.glMatrixMode(GL10.*GL_PROJECTION*);
        gl.glLoadIdentity();
        gl.glOrthof(position.x - frustumWidth * zoom / 2,
                    position.x + frustumWidth * zoom/ 2,
                    position.y - frustumHeight * zoom / 2,
                    position.y + frustumHeight * zoom/ 2,
                    1, -1);
        gl.glMatrixMode(GL10.*GL_MODELVIEW*);
        gl.glLoadIdentity();
    }`

如前所述，`setViewportAndMatrices()`方法将视口设置为横跨整个屏幕，并根据您的相机参数设置投影矩阵。在方法的最后，告诉 OpenGL ES 所有进一步的矩阵操作都是针对模型视图矩阵并加载一个单位矩阵。每一帧都调用这个方法，这样你就可以从头开始。不再需要直接调用 OpenGL ES 来设置你的视窗和投影矩阵。

`    **public** **void** touchToWorld(Vector2 touch) {
        touch.x = (touch.x / (**float**) glGraphics.getWidth()) * frustumWidth * zoom;
        touch.y = (1 - touch.y / (**float**) glGraphics.getHeight()) * frustumHeight * zoom;
        touch.add(position).sub(frustumWidth * zoom / 2, frustumHeight * zoom / 2);
    }
}`

`touchToWorld()`方法采用包含触摸坐标的`Vector2`实例，并将向量转换到世界空间。这和刚才讨论的是一样的；唯一的区别是你可以使用你喜欢的`Vector2`类。

#### 一个例子

在 cannon 示例中使用`Camera2D`类。复制`CollisionTest`文件并重命名为`Camera2DTest`。重命名文件`Camera2DTest`中的`GLGame`类，重命名`CollisionScreen`类`Camera2DScreen`。要使用新的`Camera2D`类，您需要做一些小的改动。

您要做的第一件事是向`Camera2DScreen`类添加一个新成员:

`Camera2D camera;`

您在构造函数中初始化此成员，如下所示:

`camera = new Camera2D(glGraphics, WORLD_WIDTH, WORLD_HEIGHT);`

传入您的`GLGraphics`实例和世界的宽度和高度，这是您之前在调用`glOrthof()`时使用的平截头体的宽度和高度。你现在需要做的就是在`present()`方法中替换你的直接 OpenGL ES 调用，就像这样:

`gl.glViewport(0, 0, glGraphics.getWidth(), glGraphics.getHeight());
gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
gl.glMatrixMode(GL10.GL_PROJECTION);
gl.glLoadIdentity();
gl.glOrthof(0, WORLD_WIDTH, 0, WORLD_HEIGHT, 1, -1);
gl.glMatrixMode(GL10.GL_MODELVIEW);`

你用这个替换它们:

`gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
camera.setViewportAndMatrices();`

当然，您仍然需要清除 framebuffer，但是所有其他直接的 OpenGL ES 调用都很好地隐藏在了`Camera2D.setViewportAndMatrices()`方法中。如果您运行这段代码，您会发现什么都没有改变。一切都像以前一样工作——你所做的只是让事情变得更好、更灵活。

还可以简化测试的`update()`方法。既然在 camera 类中添加了`Camera2D.touchToWorld()`方法，不妨使用它。您可以替换 update 方法中的这段代码:

`touchPos.x = (event.x / (float) glGraphics.getWidth())* WORLD_WIDTH;
touchPos.y = (1 - event.y / (float) glGraphics.getHeight()) * WORLD_HEIGHT;`

有了这个:

`camera.touchToWorld(touchPos.set(event.x, event.y));`

整洁——现在一切都被很好地封装了。但是如果你没有最大限度地利用你的相机类的特性，这将是非常无聊的。计划是这样的:只要炮弹不飞起来，你就想让摄像机以“正常”的方式观察这个世界。那很容易；你已经在做了。可以通过检查其位置的 y 坐标是否小于等于零来确定炮弹是否飞行。因为你总是对炮弹施加重力，所以即使你不发射它，它也会下落，所以这是一种廉价的检查方法。

您的新添加将在炮弹飞行时生效(当 y 坐标大于零时)。你想让摄像机跟踪炮弹。你可以通过简单地将相机的位置设置为炮弹的位置来实现这一点。这将始终保持炮弹在屏幕的中心。您还想尝试缩放功能。因此，您可以根据炮弹的 y 坐标增加缩放因子:离零越远，缩放因子越高。如果炮弹有更高的 y 坐标，这将使相机缩小。下面是您需要添加到测试屏幕中的`update()`方法末尾的内容:

`if(ball.position.y > 0) {
    camera.position.set(ball.position);
    camera.zoom = 1 + ball.position.y / WORLD_HEIGHT;
} else {
    camera.position.set(WORLD_WIDTH / 2, WORLD_HEIGHT / 2);
    camera.zoom = 1;
}`

只要你的球的 y 坐标大于零，相机就会跟着它缩小。只需在标准缩放因子 1 上增加一个值。这个值就是球的 y 位置和世界高度之间的关系。如果球的 y 坐标在`WORLD_HEIGHT`，缩放系数将是 2，所以你将看到你的世界的更多部分。这样做的方式可以是任意的；你可以在这里想出任何你想要的公式——这没什么神奇的。如果球的位置小于或等于零，你正常显示世界，就像你在前面的例子中做的那样。

### 纹理图册:因为分享是关爱

到目前为止，你在程序中只使用了一个纹理。如果你不仅想渲染鲍勃，还想渲染其他超级英雄、敌人、爆炸或硬币呢？您可以拥有多个纹理，每个纹理包含一种对象类型的图像。但是 OpenGL ES 不会太喜欢这样，因为你需要为你渲染的每个对象类型切换纹理(也就是说，绑定 Bob 的纹理，渲染 Bob，绑定 coin 纹理，渲染 coin，等等)。通过将多个图像放入一个纹理中，你可以更有效地做到这一点。这是一个纹理图谱:包含多个图像的单一纹理。你只需要绑定那个纹理一次，然后你就可以为图集里有图像的渲染任何实体类型。这节省了一些状态更改开销，并提高了性能。[图 8–23](#fig_8_23)显示了这样一个纹理图谱。

![images](img/0823.jpg)

**图 8-23。** *纹理图集*

[Figure 8–23](#fig_8_23)中有三个物体:一门大炮、一个炮弹和鲍勃。网格不是纹理的一部分；它只是为了说明你通常是如何创建纹理贴图集的。

纹理图谱大小为 64×64 像素，每个网格为 32×32 像素。大炮占了两个牢房，炮弹占了不到四分之一个牢房，鲍勃占了一个牢房。现在，如果你回头看看你是如何定义加农炮、炮弹和目标的边界(和图形矩形)的，你会注意到它们之间的大小关系与你在网格中看到的非常相似。目标在你的世界里是 0.5×0.5 m，大炮是 0.2×0.2 m，在你的纹理图谱里，Bob 占了 32×32 像素，炮弹略小于 16×16 像素。纹理地图和你的世界中的物体尺寸之间的关系应该是清楚的:地图中的 32 像素等于你的世界中的 0.5 米。在您的原始示例中，加农炮是 1×1 米，但是您当然可以更改它。根据你的纹理图集，其中大炮占用 64×32 像素，你应该让你的大炮在你的世界里有 1×0.5 m 的大小。哇，那非常容易，不是吗？

那么为什么要选择 32 像素来搭配你的世界里的 1 米呢？记住纹理的宽度和高度必须是 2 的幂。使用像 32 这样的 2 的幂像素单位来映射到你的世界中的 0.5 米是艺术家应对纹理大小限制的一种方便的方式。这也使得在像素艺术中更容易得到你的世界中不同物体的大小关系。

请注意，没有什么可以阻止你使用更多的每世界单位像素。你可以选择 64 像素或 50 像素来匹配你的世界中的 0.5 m。那么什么是好的像素到米的尺寸呢？这同样取决于游戏运行的屏幕分辨率。让我们做一些计算。

你的大炮世界以左下角的(0，0)和左上角的(9.6，4.8)为界。这映射到您的屏幕上。让我们来计算一下英雄的屏幕上每世界单位有多少像素(横向模式下为 480×320 像素):

`pixelsPerUnitX = screenWidth / worldWidth = 480 / 9.6 = 50 pixels / meter
pixelsPerUnitY = screenHeight / worldHeight = 320 / 6.4 = 50 pixels / meter`

您的加农炮现在将占用 1×0.5 m 的世界，因此将在屏幕上使用 50×25 像素。你可以在你的纹理中使用一个 64×32 像素的区域，这样你就可以在渲染加农炮的时候缩小纹理图像。这完全没问题——OpenGLES 会自动为你做这件事。根据您为纹理设置的缩小过滤器，结果将是清晰的像素化的(`GL_NEAREST`)或稍微平滑的(`GL_LINEAR`)。如果你想要一个像素完美的英雄渲染，你需要缩放你的纹理图像一点。您可以使用 25×25 像素的网格大小，而不是 32×32 像素。然而，如果你只是调整了 atlas 图像的大小(或者更确切地说是用手重新绘制)，你将得到一个 50×50 像素的图像——这在 OpenGL ES 中是不允许的。您必须在左侧和底部添加填充，以获得 64×64 的图像(因为 OpenGL ES 需要 2 的幂宽度和高度)。因此 OpenGL ES 很适合在英雄身上缩小你的纹理图像。

像 Nexus One 这种分辨率更高的设备(风景模式下 800×480)情况如何？让我们通过以下等式来计算这种屏幕配置:

`pixelsPerUnitX = screenWidth / worldWidth = 800 / 9.6 = 83 pixels / meter
pixelsPerUnitY = screenHeight / worldHeight = 480 / 6.4 = 75 pixels / meter`

x 轴和 y 轴上的每单位像素不同，因为视锥的纵横比(9.6 / 6.4 = 1.5)不同于屏幕的纵横比(800 / 480 = 1.66)。这已在第 4 章中讨论过，并概述了一些解决方案。那时，你的目标是固定的像素大小和纵横比；现在，您可以采用该方案，并以固定的平截头体宽度和高度为目标。在 Nexus One 的情况下，由于更高的分辨率和不同的纵横比，大炮、炮弹和鲍勃将被放大和拉伸。接受这个事实，因为你想让所有玩家看到你世界的同一个区域。否则，拥有更高长宽比的玩家将有优势看到更多的世界。

那么，如何使用这样的纹理图谱呢？你只需要重新映射你的矩形。不是使用所有的纹理，你只是使用它的一部分。要计算出包含在纹理图谱中的图像的角的纹理坐标，可以重用上一个例子中的公式。这里有一个快速复习:

`u = x / imageWidth
v = y / imageHeight`

这里，u 和 v 是纹理坐标，x 和 y 是像素坐标。Bob 在像素坐标中的左上角在(32，32)。如果你把它代入前面的等式，你会得到(0.5，0.5)作为纹理坐标。你可以对任何你需要的角做同样的事情，并基于此为你的矩形顶点设置正确的纹理坐标。

#### 一个例子

把这个纹理图集加到你之前的例子里，让它看起来更漂亮。鲍勃将是你的目标。

复制`Camera2DTest`并稍加修改。将副本放在名为`TextureAtlasTest.java`的文件中，并相应地重命名其中包含的两个类(`TextureAtlasTest`和`TextureAtlasScreen`)。

您要做的第一件事是向`TextureAtlasScreen`添加一个新成员:

`Texture texture;`

不是在构造函数中创建一个`Texture`，而是在`resume()`方法中创建它。记住，当你的应用程序从暂停状态返回时，纹理会丢失，所以你必须用`resume()`方法重新创建它们:

`@Override
**public** **void** resume() {
    texture = **new** Texture(((GLGame)game), "atlas.png");
}`

将[图 8–23](#fig_8_23)中的图像放到项目的`assets/`文件夹中，并将其命名为`atlas.png`。(当然不包含图中所示的网格线。)

接下来，您需要更改顶点的定义。每个实体类型(cannon、cannonball 和 Bob)都有一个`Vertices`实例，包含一个由四个顶点和六个索引组成的矩形，构成三个三角形。你需要做的就是根据纹理图谱给每个顶点添加纹理坐标。您还可以将大炮从三角形改为 1×0.5 米的矩形。下面是您用来替换构造函数中旧的顶点创建代码的内容:

`cannonVertices = **new** Vertices(glGraphics, 4, 6, **false**, **true**);
cannonVertices.setVertices(**new** **float**[] { -0.5f, -0.25f, 0.0f, 0.5f,
                                          0.5f, -0.25f, 1.0f, 0.5f,
                                          0.5f,  0.25f, 1.0f, 0.0f,
                                         -0.5f,  0.25f, 0.0f, 0.0f },
                                         0, 16);
cannonVertices.setIndices(**new** **short**[] {0, 1, 2, 2, 3, 0}, 0, 6);

ballVertices = **new** Vertices(glGraphics, 4, 6, **false**, **true**);
ballVertices.setVertices(**new** **float**[] { -0.1f, -0.1f, 0.0f, 0.75f,
                                        0.1f, -0.1f, 0.25f, 0.75f,
                                        0.1f,  0.1f, 0.25f, 0.5f,
                                       -0.1f,  0.1f, 0.0f, 0.5f },
                                        0, 16);
ballVertices.setIndices(**new** **short**[] {0, 1, 2, 2, 3, 0}, 0, 6);

targetVertices = **new** Vertices(glGraphics, 4, 6, **false**, **true**);
targetVertices.setVertices(**new** **float**[] { -0.25f, -0.25f, 0.5f, 1.0f,
                                          0.25f, -0.25f, 1.0f, 1.0f,
                                          0.25f,  0.25f, 1.0f, 0.5f,
                                         -0.25f,  0.25f, 0.5f, 0.5f },
                                         0, 16);
targetVertices.setIndices(**new** **short**[] {0, 1, 2, 2, 3, 0}, 0, 6);`

现在，每个网格都由四个顶点组成，每个顶点都有一个 2D 位置和纹理坐标。向网格添加六个索引，指定要渲染的两个三角形。大炮在 y 轴上稍微小一点。它现在的大小是 1×0.5 米，而不是 1×1 米。这也反映在构造函数前面的`Cannon`对象的构造中:

`cannon = **new** Cannon(0, 0, 1, 0.5f);`

因为你不用 cannon 本身做任何碰撞检测，所以你在构造函数中设置什么大小并不重要；只是为了一致性。

你需要改变的最后一件事是你的渲染方法。这是它最辉煌的时刻:

`@Override
**public** **void** present(**float** deltaTime) {
    GL10 gl = glGraphics.getGL();
    gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
    camera.setViewportAndMatrices();

    gl.glEnable(GL10.GL_BLEND);
    gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
    gl.glEnable(GL10.GL_TEXTURE_2D);
    texture.bind();

    targetVertices.bind();
    **int** len = targets.size();
    **for**(**int** i = 0; i < len; i++) {              
        GameObject target = targets.get(i);
        gl.glLoadIdentity();
        gl.glTranslatef(target.position.x, target.position.y, 0);
        targetVertices.draw(GL10.GL_TRIANGLES, 0, 6);
    }
    targetVertices.unbind();

    gl.glLoadIdentity();
    gl.glTranslatef(ball.position.x, ball.position.y, 0);
    ballVertices.bind();
    ballVertices.draw(GL10.GL_TRIANGLES, 0, 6);
    ballVertices.unbind();

    gl.glLoadIdentity();
    gl.glTranslatef(cannon.position.x, cannon.position.y, 0);
    gl.glRotatef(cannon.angle, 0, 0, 1);
    cannonVertices.bind();
    cannonVertices.draw(GL10.GL_TRIANGLES, 0, 6);
    cannonVertices.unbind();
}`

在这里，您可以启用混合，设置适当的混合功能，启用纹理，并绑定您的贴图集纹理。您还稍微修改了`cannonVertices.draw()`调用，现在呈现两个三角形而不是一个。仅此而已。[图 8–24](#fig_8_24)展示了你整容的结果。

![images](img/0824.jpg)

**图 8–24。** *用贴图集美化大炮的例子*

关于纹理贴图集，您还需要了解一些事情:

*   当您使用`GL_LINEAR`作为缩小和/或放大过滤器时，当图谱中的两幅图像相互接触时，可能会出现伪像。这是因为纹理映射器实际上从屏幕上的一个像素的纹理中提取了四个最近的纹理元素。当它为一个图像的边界做那件事的时候，它也将从图集的邻近图像中获取纹理元素。您可以通过在图像之间引入两个像素的空白边框来消除这个问题。更好的是，您可以复制每个图像的边框像素。第一个解决方案更简单——只要确保你的纹理保持 2 的幂。
*   没有必要把地图集里的所有图像都放在一个固定的网格里。你可以尽可能紧密地将任意大小的图像放入地图集。你所需要知道的是图像在图集中的开始和结束位置，这样你就可以为它计算合适的纹理坐标。然而，打包任意大小的图像是一个不小的问题。网上有一些工具可以帮助你创建一个纹理图谱；只要搜索一下，你就会发现有太多的选择。
*   通常你不能将游戏中的所有图像组合到一个纹理中。记住，不同的设备有不同的最大纹理尺寸。您可以放心地假设所有设备都支持 512×512 像素(甚至 1024×1024)的纹理大小。所以，你可以有多个纹理图谱。但是，您应该尝试将在屏幕上看到的对象组合在一个图谱中——比方说，一个图谱中所有级别 1 的对象，另一个图谱中所有级别 2 的对象，另一个图谱中所有 UI 元素，等等。在最终确定你的艺术资产之前，考虑一下逻辑分组。
*   还记得你在《诺姆先生》里是怎么动态画数字的吗？你用了纹理图谱。事实上，你可以通过纹理贴图集来执行所有的动态文本渲染。只需将游戏所需的所有角色放入地图中，并通过多个矩形映射到地图中相应的角色，按需渲染即可。你可以在网上找到一些工具，可以为你生成所谓的*位图字体*。在接下来的章节中，请坚持使用 Mr. Nom 中使用的方法:静态文本将作为一个整体进行预呈现，只有动态文本(例如，高分中的数字)将通过图集呈现。

你可能已经注意到 bob 在被炮弹击中之前就消失了。这是因为你的边界形状有点太大了。鲍勃和炮弹周围有一些空白。解决办法是什么？只是让边界形状小一点。你应该有这种感觉，所以操纵源，直到碰撞感觉正确。你在开发一款游戏的时候会经常发现这样的微调“机会”。除了好的关卡设计，微调可能是最重要的部分之一。让事情感觉正确可能很难，但一旦你在《超级马里奥兄弟》中达到完美的水平，这将是非常令人满意的。可悲的是，这是没有什么可以教的，因为它取决于你的游戏的外观和感觉。把它看作是区分好游戏和坏游戏的魔法酱。

**注意:**为了处理刚才提到的消失问题，使边界矩形比它们的图形表示稍微小一点，以便在触发碰撞之前允许一些重叠。

### 纹理区域、精灵和批次:隐藏 OpenGL ES

到目前为止，对于 cannon 示例，您的代码由许多样板文件组成，其中一些可以减少。一个这样的领域是`Vertices`实例的定义。用七行代码来定义一个纹理矩形是很乏味的。另一个可以改进的地方是手工计算纹理地图中图像的纹理坐标。最后，当你想要渲染你的 2D 矩形时，有许多高度重复的代码。还有一种更好的方法来呈现许多对象，而不是每个对象一个 draw 调用。您可以通过引入一些新概念来解决所有这些问题:

*   *纹理区域*:你在上一个例子中使用了纹理区域。纹理区域是单一纹理中的矩形区域(例如，地图中包含大炮的区域)。你需要一个好的类来封装将像素坐标转换成纹理坐标的所有讨厌的计算。
*   *精灵*:精灵很像一个游戏对象。它有一个位置(可能还有方向和比例)，以及一个图形范围。你通过一个矩形渲染一个精灵，就像你渲染鲍勃或者大炮一样。事实上，Bob 和其他对象的图形表示可以也应该被视为精灵。精灵也映射到纹理中的一个区域。这就是纹理区域出现的原因。虽然在游戏中直接组合精灵很有诱惑力，但是你应该按照模型-视图-控制器的模式将它们分开。图形和模式代码之间的清晰分离有助于更好的设计。
*   一个精灵批处理器负责一次渲染多个精灵。为此，精灵批处理程序需要知道每个精灵的位置、大小和纹理区域。雪碧批处理将是你的神奇成分，以摆脱多个绘制调用和每个对象的矩阵运算。

这些概念是高度相互关联的，将在下面讨论。

#### texture region 类

既然你已经使用了纹理区域，那么弄清楚你需要什么应该很简单。你知道如何从像素坐标转换到纹理坐标。您希望有一个类，可以在其中指定纹理贴图集中图像的像素坐标，然后存储贴图集区域的相应纹理坐标以供进一步处理(例如，当您希望渲染精灵时)。事不宜迟，[清单 8–16](#list_8_16)显示了您的`TextureRegion`类。

***清单 8–16。*** TextureRegion.java:将像素坐标转换为纹理坐标

`**package** com.badlogic.androidgames.framework.gl;

**public** **class** TextureRegion {
    **public** **final** **float** u1, v1;
    **public** **final** **float** u2, v2;
    **public** **final** Texture texture;

    **public** TextureRegion(Texture texture, **float** x, **float** y, **float** width, **float** height) {
        **this**.u1 = x / texture.width;
        **this**.v1 = y / texture.height;
        **this**.u2 = **this**.u1 + width / texture.width;
        **this**.v2 = **this**.v1 + height / texture.height;
        **this**.texture = texture;
    }
}`

`TextureRegion`以纹理坐标存储该区域左上角(`u1`、`v1`)和右下角(`u2`、`v2`)的纹理坐标。构造函数采用像素坐标中的一个`Texture`和左上角，以及区域的宽度和高度。要为`Cannon`构建一个纹理区域，你可以这样做:

`TextureRegion cannonRegion = **new** TextureRegion(texture, 0, 0, 64, 32);`

类似地，您可以为 Bob 构建一个区域:

`TextureRegion bobRegion = **new** TextureRegion(texture, 32, 32, 32, 32);`

诸如此类。您可以在已经创建的示例代码中使用它，并使用`TextureRegion.u1`、`v1`、`u2`和`v2`成员来指定矩形顶点的纹理坐标。但是你不需要这样做，因为你想完全摆脱这些乏味的定义。这就是你可以使用雪碧批处理。

#### sprite batcher 类

如前所述，子画面可以通过其位置、大小和纹理区域(以及可选的旋转和缩放)轻松定义。它只是你的世界空间中的一个图形矩形。为了使事情变得简单，坚持约定，位置在精灵的中心，矩形围绕中心构造。现在你可以拥有一个`Sprite`类，并像这样使用它:

`Sprite bobSprite = **new** Sprite(20, 20, 0.5f, 0.5f, bobRegion);`

这将构造一个新的精灵，它的中心在世界上的(20，20)，向每边延伸 0.25 米，并使用`bobRegion TextureRegion`。但是你可以这样做:

`spriteBatcher.drawSprite(bob.x, bob.y, BOB_WIDTH, BOB_HEIGHT, bobRegion);`

现在看起来好多了。您不需要构建另一个对象来表示对象的图形方面。相反，按需绘制 Bob 的实例。您也可以有一个重载的方法:

`spriteBatcher.drawSprite(cannon.x, cannon.y, CANNON_WIDTH, CANNON_HEIGHT, cannon.angle, cannonRegion);`

这会画出旋转了角度的大炮。那么如何实现 sprite 批处理程序呢？`Vertices`实例在哪里？让我们想想分批配料器是如何工作的。

究竟什么是批处理？在图形社区中，批处理被定义为将多个绘制调用合并成一个绘制调用。正如上一章所讨论的，这让 GPU 很高兴。雪碧批处理提供了一种方法来实现这一点。以下是如何:

*   批处理机有一个最初为空的缓冲区(或在您发出清除信号后变空)。该缓冲区将保存顶点。在你的例子中，它是一个简单的浮点数组。
*   每次调用`SpriteBatcher.drawSprite()`方法时，根据作为参数指定的位置、大小、方向和纹理区域，向缓冲区添加四个顶点。这也意味着您必须手动旋转和平移顶点位置，而没有 OpenGL ES 的帮助。不过，不用担心，您的`Vector2`类的代码在这里会派上用场。这是消除所有听牌要求的关键。
*   一旦你指定了你想要渲染的所有精灵，你告诉精灵批处理程序将精灵的所有矩形的顶点一次性提交给 GPU，然后调用实际的 OpenGL ES 绘制方法来渲染所有的矩形。为此，您可以将 float 数组的内容转移到一个`Vertices`实例，并使用它来呈现矩形。

注意:你只能批量处理使用相同纹理的精灵。然而，这不是一个大问题，因为你将使用纹理贴图集。

sprite 批处理程序的通常使用模式如下所示:

`batcher.beginBatch(texture);
// call batcher.drawSprite() as often as needed, referencing regions in the texture
batcher.endBatch();`

对`SpriteBatcher.beginBatch()`的调用将告诉批处理程序两件事:它应该清空它的缓冲区，并使用你传入的纹理。为了方便起见，您将在此方法中绑定纹理。

接下来，根据需要渲染尽可能多的引用该纹理中区域的精灵。这将填充缓冲区，为每个精灵添加四个顶点。

对`SpriteBatcher.endBatch()`的调用向 sprite batcher 发出信号，表明你已经完成了批量 sprite 的渲染，它现在应该将顶点上传到 GPU 进行实际渲染。您将对一个`Vertices`实例使用索引渲染，因此除了浮点数组缓冲区中的顶点之外，您还需要指定索引。然而，由于您总是在渲染矩形，您可以在`SpriteBatcher`的构造函数中预先生成一次索引。为此，你需要知道批处理程序每批可以绘制多少精灵。通过对每批可以渲染的精灵数量进行硬性限制，您不需要增加任何其他缓冲区的数组；您可以在构造函数中一次性分配这些数组和缓冲区。

一般的机制相当简单。方法可能看起来很神秘，但它不是一个大问题(如果你暂时不考虑旋转和缩放的话)。所有你需要做的是计算顶点位置和纹理坐标，正如参数所定义的。在前面的例子中，您已经手动完成了这一步——例如，当您为加农炮、炮弹和鲍勃定义矩形时。您可以在`SpriteBatcher.drawSprite()`方法中做或多或少相同的事情，只是基于方法的参数自动完成。所以让我们来看看`SpriteBatcher`。[清单 8–17](#list_8_17)显示了代码。

**清单 8–17。**摘自 SpriteBatcher.java 的*，没有旋转和缩放*

`**package** com.badlogic.androidgames.framework.gl;

**import** javax.microedition.khronos.opengles.GL10;

**import** android.util.FloatMath;` `**import** com.badlogic.androidgames.framework.impl.GLGraphics;
**import** com.badlogic.androidgames.framework.math.Vector2;

**public** **class** SpriteBatcher {
    **final** **float**[] verticesBuffer;
    **int** bufferIndex;
    **final** Vertices vertices;
    **int** numSprites;    `

先看成员。成员`verticesBuffer`是一个临时的浮动数组，用来存储当前批次的精灵的顶点。成员`bufferIndex`指出你应该在浮动数组中的什么地方开始写下一个顶点。成员`vertices`是用于呈现批处理的`Vertices`实例。它还存储了您稍后将定义的索引。成员`numSprites`持有当前批次中已抽取的号码。

`    **public** SpriteBatcher(GLGraphics glGraphics, **int** maxSprites) {
        **this**.verticesBuffer = **new** **float**[maxSprites*4*4];
        **this**.vertices = **new** Vertices(glGraphics, maxSprites*4, maxSprites*6, **false**,
**true**);
        **this**.bufferIndex = 0;
        **this**.numSprites = 0;

        **short**[] indices = **new** **short**[maxSprites*6];
        **int** len = indices.length;
        **short** j = 0;
        **for** (**int** i = 0; i < len; i += 6, j += 4) {
                indices[i + 0] = (**short**)(j + 0);
                indices[i + 1] = (**short**)(j + 1);
                indices[i + 2] = (**short**)(j + 2);
                indices[i + 3] = (**short**)(j + 2);
                indices[i + 4] = (**short**)(j + 3);
                indices[i + 5] = (**short**)(j + 0);
        }
        vertices.setIndices(indices, 0, indices.length);
    }      `

转到构造函数，您有两个参数:创建`Vertices`实例所需的`GLGraphics`实例，以及批处理程序在一个批处理中能够呈现的最大 sprites 数量。您在构造函数中做的第一件事是创建浮点数组。每个精灵有四个顶点，每个顶点占用四个浮点(两个用于 x 和 y 坐标，另外两个用于纹理坐标)。你可以拥有最多的`maxSprites`精灵，所以你需要 4 × 4 × `maxSprites`的浮动作为缓冲。

接下来，创建`Vertices`实例。你需要它存储`maxSprites` × 4 个顶点和`maxSprites` × 6 个索引。告诉`Vertices`实例，你不仅有位置属性，还有每个顶点的纹理坐标。然后将`bufferIndex`和`numSprites`成员初始化为零。为您的`Vertices`实例创建索引。您只需要这样做一次，因为索引永远不会改变。一批中的第一个子画面将总是具有索引 0，1，2，2，3，0；下一个精灵会有 4，5，6，6， 7，4；等等。您可以预先计算这些并将它们存储在`Vertices`实例中。这样，你只需要设置它们一次，而不是为每个精灵设置一次。

`    **public** **void** beginBatch(Texture texture) {
        texture.bind();
        numSprites = 0;
        bufferIndex = 0;
    }`

接下来是`beginBatch()`方法。它绑定纹理并重置`numSprites`和`bufferIndex`成员，这样第一个精灵的顶点将被插入到`verticesBuffer`浮动数组的前面。

`    **public** **void** endBatch() {
        vertices.setVertices(verticesBuffer, 0, bufferIndex);
        vertices.bind();
        vertices.draw(GL10.*GL_TRIANGLES*, 0, numSprites * 6);
        vertices.unbind();
    }`

接下来的方法是`endBatch()`；您将调用它来完成并绘制当前批次。它首先将为该批次定义的顶点从浮点数组传输到`Vertices`实例。剩下的就是绑定`Vertices`实例，绘制`numSprites` × 2 个三角形，然后再次解除`Vertices`实例的绑定。由于使用索引渲染，请指定要使用的索引数量——每个精灵六个索引乘以`numSprites`。这就是渲染的全部内容。

`**public** **void** drawSprite(**float** x, **float** y, **float** width, **float** height, TextureRegion region) {
        **float** halfWidth = width / 2;
        **float** halfHeight = height / 2;
        **float** x1 = x - halfWidth;
        **float** y1 = y - halfHeight;
        **float** x2 = x + halfWidth;
        **float** y2 = y + halfHeight;

        verticesBuffer[bufferIndex++] = x1;
        verticesBuffer[bufferIndex++] = y1;
        verticesBuffer[bufferIndex++] = region.u1;
        verticesBuffer[bufferIndex++] = region.v2;

        verticesBuffer[bufferIndex++] = x2;
        verticesBuffer[bufferIndex++] = y1;
        verticesBuffer[bufferIndex++] = region.u2;
        verticesBuffer[bufferIndex++] = region.v2;

        verticesBuffer[bufferIndex++] = x2;
        verticesBuffer[bufferIndex++] = y2;
        verticesBuffer[bufferIndex++] = region.u2;
        verticesBuffer[bufferIndex++] = region.v1;

        verticesBuffer[bufferIndex++] = x1;
        verticesBuffer[bufferIndex++] = y2;
        verticesBuffer[bufferIndex++] = region.u1;
        verticesBuffer[bufferIndex++] = region.v1;` `        numSprites++;
    }`

下一个方法是`SpriteBatcher`的主力。它获取精灵中心的 x 和 y 坐标，宽度和高度，以及它映射到的`TextureRegion`。该方法的职责是从当前的`bufferIndex`开始向浮动数组添加四个顶点。这四个顶点形成一个纹理映射的矩形。你计算左下角(`x1`、`y1`)和右上角(`x2`、`y2`)的位置，用这四个变量和来自`TextureRegion`的纹理坐标一起构造顶点。从左下角的顶点开始，按逆时针顺序添加顶点。一旦它们被添加到 float 数组中，您就增加`numSprites`计数器，并等待另一个 sprite 被添加或者批处理被完成。

这就是我们要做的一切。您只是简单地通过在一个浮点数组中缓冲预转换的顶点并一次性渲染它们，从而消除了许多绘制方法。与你之前使用的方法相比，这将大大提高你的 2D 精灵渲染性能。更少的 OpenGL ES 状态改变和更少的绘图调用让 GPU 很开心。

还有一件事需要实现:一个可以绘制旋转精灵的`SpriteBatcher.drawSprite()`方法。你所要做的就是在不添加位置的情况下构建四个角顶点，围绕原点旋转它们，添加精灵的位置，以便将顶点放置在世界空间中，然后像前面的绘制方法一样继续。您可以为此使用`Vector2.rotate()`，但是这将意味着一些功能开销。因此，您在`Vector2.rotate()`中复制代码，并在可能的地方进行优化。`SpriteBatcher`的最终方法类似于[清单 8–18](#list_8_18)。

**清单 8–18。***sprite batcher . Java 的其余部分:绘制旋转精灵的方法*

`**public** **void** drawSprite(**float** x, **float** y, **float** width, **float** height, **float** angle, TextureRegion region) {
        **float** halfWidth = width / 2;
        **float** halfHeight = height / 2;

        **float** rad = angle * Vector2.*TO_RADIANS*;
        **float** cos = FloatMath.*cos*(rad);
        **float** sin = FloatMath.*sin*(rad);

        **float** x1 = -halfWidth * cos - (-halfHeight) * sin;
        **float** y1 = -halfWidth * sin + (-halfHeight) * cos;
        **float** x2 = halfWidth * cos - (-halfHeight) * sin;
        **float** y2 = halfWidth * sin + (-halfHeight) * cos;
        **float** x3 = halfWidth * cos - halfHeight * sin;
        **float** y3 = halfWidth * sin + halfHeight * cos;
        **float** x4 = -halfWidth * cos - halfHeight * sin;
        **float** y4 = -halfWidth * sin + halfHeight * cos;

        x1 += x;
        y1 += y;
        x2 += x;
        y2 += y;
        x3 += x;` `        y3 += y;
        x4 += x;
        y4 += y;

        verticesBuffer[bufferIndex++] = x1;
        verticesBuffer[bufferIndex++] = y1;
        verticesBuffer[bufferIndex++] = region.u1;
        verticesBuffer[bufferIndex++] = region.v2;

        verticesBuffer[bufferIndex++] = x2;
        verticesBuffer[bufferIndex++] = y2;
        verticesBuffer[bufferIndex++] = region.u2;
        verticesBuffer[bufferIndex++] = region.v2;

        verticesBuffer[bufferIndex++] = x3;
        verticesBuffer[bufferIndex++] = y3;
        verticesBuffer[bufferIndex++] = region.u2;
        verticesBuffer[bufferIndex++] = region.v1;

        verticesBuffer[bufferIndex++] = x4;
        verticesBuffer[bufferIndex++] = y4;
        verticesBuffer[bufferIndex++] = region.u1;
        verticesBuffer[bufferIndex++] = region.v1;

        numSprites++;
    }
}`

除了构建所有四个角点而不仅仅是两个相对的角点之外，您的操作与更简单的绘制方法相同。这是旋转所需要的。剩下的和之前一样。

缩放呢？您并不明确需要另一种方法，因为缩放 sprite 只需要缩放其宽度和高度。您可以在这两个绘制方法之外完成，因此没有必要为精灵的缩放绘制提供另一堆方法。

这就是使用 OpenGL ES 进行闪电般快速的精灵渲染背后的大秘密。

##### 使用 SpriteBatcher 类

现在您可以将`TextureRegion`和`SpriteBatcher`类合并到您的 cannon 示例中。复制`TextureAtlas`示例，并将其重命名为`SpriteBatcherTest`。其中包含的类可以称为`SpriteBatcherTest`和`SpriteBatcherScreen`。

去掉 screen 类中的`Vertices`成员。你不再需要它们了，因为`SpriteBatcher`会为你做所有的脏活。相反，添加以下成员:

`TextureRegion cannonRegion;
TextureRegion ballRegion;
TextureRegion bobRegion;
SpriteBatcher batcher;`

现在你的地图中的三个物体都有了一个`TextureRegion`，还有一个`SpriteBatcher`。

接下来，修改屏幕的构造函数。去掉所有的`Vertices`实例化和初始化代码，代之以一行代码:

`batcher = **new** SpriteBatcher(glGraphics, 100);`

这将把`batcher`成员设置为一个新的`SpriteBatcher`实例，该实例可以一次渲染 100 个精灵。

`TextureRegion`在`resume()`方法中被初始化，因为它们依赖于`Texture`:

`@Override
**public** **void** resume() {
    texture = **new** Texture(((GLGame)game), "atlas.png");
    cannonRegion = **new** TextureRegion(texture, 0, 0, 64, 32);
    ballRegion = **new** TextureRegion(texture, 0, 32, 16, 16);
    bobRegion = **new** TextureRegion(texture, 32, 32, 32, 32);
}`

这里没有惊喜。最后需要改变的是`present()`方法。你会惊讶它现在看起来有多干净。这是:

`@Override
**public** **void** present(**float** deltaTime) {
    GL10 gl = glGraphics.getGL();
    gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
    camera.setViewportAndMatrices();

    gl.glEnable(GL10.GL_BLEND);
    gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
    gl.glEnable(GL10.GL_TEXTURE_2D);

    batcher.beginBatch(texture);

    **int** len = targets.size();
    **for**(**int** i = 0; i < len; i++) {              
        GameObject target = targets.get(i);
        batcher.drawSprite(target.position.x, target.position.y, 0.5f, 0.5f, bobRegion);
    }

    batcher.drawSprite(ball.position.x, ball.position.y, 0.2f, 0.2f, ballRegion);
    batcher.drawSprite(cannon.position.x, cannon.position.y, 1, 0.5f, cannon.angle, cannonRegion);
    batcher.endBatch();
}`

那真是太好了。您现在发出的唯一 OpenGL ES 调用是为了清除屏幕，启用混合和纹理，以及设置混合功能。剩下的就是纯粹的`SpriteBatcher`和`Camera2D`善良。由于所有对象共享同一个纹理贴图集，所以可以在一个批处理中渲染它们。你用 atlas 纹理调用`batcher.beginBatch()`，用简单的画图方法渲染所有的 Bob 目标，渲染球(还是用简单的画图方法)，最后用可以旋转一个 sprite 的画图方法渲染大炮。你通过调用`batcher.endBatch()`、来结束这个方法，这将实际上把你的精灵的几何图形传送到 GPU 并渲染一切。

##### 测量绩效

那么`SpriteBatcher`的方法比你在`BobTest`中用的方法快多少呢？向代码中添加一个`FPSCounter`，并为一个英雄、一个机器人和一个 Nexus 机器人计时，就像您在`BobTest`中所做的那样。将目标数量增加到 100，并将`SpriteBatcher`可以渲染的精灵数量设置为 102，因为你渲染了 100 个目标、1 个球和 1 门大炮。结果如下:

`Hero (1.5):
12-27 23:51:09.400: DEBUG/FPSCounter(2169): fps: 31
12-27 23:51:10.440: DEBUG/FPSCounter(2169): fps: 31
12-27 23:51:11.470: DEBUG/FPSCounter(2169): fps: 32
12-27 23:51:12.500: DEBUG/FPSCounter(2169): fps: 32

Droid (2.1.1):
12-27 23:50:23.416: DEBUG/FPSCounter(8145): fps: 56
12-27 23:50:24.448: DEBUG/FPSCounter(8145): fps: 56
12-27 23:50:25.456: DEBUG/FPSCounter(8145): fps: 56
12-27 23:50:26.456: DEBUG/FPSCounter(8145): fps: 55

Nexus One (2.2.1):
12-27 23:46:57.162: DEBUG/FPSCounter(754): fps: 61
12-27 23:46:58.171: DEBUG/FPSCounter(754): fps: 61
12-27 23:46:59.181: DEBUG/FPSCounter(754): fps: 61
12-27 23:47:00.181: DEBUG/FPSCounter(754): fps: 60`

在你得出任何结论之前，让我们也测试一下老方法。由于该示例不等同于旧的`BobTest`，修改`TextureAtlasTest`，这与当前示例相同——唯一的区别是它使用旧的`BobTest`方法进行渲染。结果如下:

`Hero (1.5):
12-27 23:53:45.950: DEBUG/FPSCounter(2303): fps: 46
12-27 23:53:46.720: DEBUG/dalvikvm(2303): GC freed 21811 objects / 524280 bytes in 135ms
12-27 23:53:46.970: DEBUG/FPSCounter(2303): fps: 40
12-27 23:53:47.980: DEBUG/FPSCounter(2303): fps: 46
12-27 23:53:48.990: DEBUG/FPSCounter(2303): fps: 46

Droid (2.1.1):
12-28 00:03:13.004: DEBUG/FPSCounter(8277): fps: 52
12-28 00:03:14.004: DEBUG/FPSCounter(8277): fps: 52
12-28 00:03:15.027: DEBUG/FPSCounter(8277): fps: 53
12-28 00:03:16.027: DEBUG/FPSCounter(8277): fps: 53

Nexus One (2.2.1):
12-27 23:56:09.591: DEBUG/FPSCounter(873): fps: 61
12-27 23:56:10.591: DEBUG/FPSCounter(873): fps: 60
12-27 23:56:11.601: DEBUG/FPSCounter(873): fps: 61
12-27 23:56:12.601: DEBUG/FPSCounter(873): fps: 60` 

与使用`glTranslate()`和类似方法的老方法相比，英雄用你的新`SpriteBatcher`方法表现差很多。Droid 实际上受益于新的`SpriteBatcher`方法，而 Nexus One 并不在乎你使用什么。如果你再增加 100 个目标，你会发现`SpriteBatcher`方法在 Nexus One 上也会更快。

那么男主角怎么样了？`BobTest`中的问题是你调用了太多的 OpenGL ES 方法，那么为什么现在你使用的 OpenGL ES 方法调用越少，它的性能就越差呢？

##### 在 FloatBuffer 中解决一个 Bug

这其中的原因并不明显。当你调用`Vertices.setVertices()`时，你的`SpriteBatcher`在每一帧把一个浮点数组放到一个直接的`ByteBuffer`中。该方法归结为调用`FloatBuffer.put(float[])`，这是您性能下降的罪魁祸首。desktop Java 通过真正的大容量内存移动来实现`FloatBuffer`方法，而 Harmony 版本为数组中的每个元素调用`FloatBuffer.put(float)`。这是非常不幸的，因为该方法是 JNI 方法，有很多开销(很像 OpenGL ES 方法，也是 JNI 方法)。

有几个解决方案。`IntBuffer.put(int[])`不苦于这个问题，比如。您可以用一个`IntBuffer,`替换您的`Vertices`类中的`FloatBuffer`，并修改`Vertices.setVertices()`，以便它首先将浮点从浮点数组转移到一个临时 int 数组，然后将该 int 数组的内容复制到`IntBuffer`。这个解决方案是由同为游戏开发者的 Ryan McNally 提出的，他也在 Android bug 追踪器上报告了这个 bug。它在 Hero 上产生了五倍的性能提升，在其他 Android 设备上稍低。

修改`Vertices`类以包含此修复。将`vertices`成员更改为`IntBuffer`。添加一个名为`tmpBuffer`的新成员，这是一个`int[]`数组。`tmpBuffer`数组在`Vertices,`的构造函数中初始化如下:

`this.tmpBuffer = **new** **int**[maxVertices * vertexSize / 4];`

您还可以从构造函数中的`ByteBuffer`获得一个`IntBuffer`视图，而不是一个`FloatBuffer`:

`vertices = buffer.asIntBuffer();`

而`Vertices.setVertices()`方法现在看起来像这样:

`**public** **void** setVertices(**float**[] vertices, **int** offset, **int** length) {
    **this**.vertices.clear();
    **int** len = offset + length;
    **for**(**int** i=offset, j=0; i < len; i++, j++)
        tmpBuffer[j] = Float.floatToRawIntBits(vertices[i]);
    **this**.vertices.put(tmpBuffer, 0, length);
    **this**.vertices.flip();
}`

首先，将`vertices`参数的内容传递给`tmpBuffer`。静态方法`Float.floatToRawIntBits()`将浮点的位模式重新解释为 int。然后需要将 int 数组的内容复制到`IntBuffer`，以前称为`FloatBuffer`。它能提高性能吗？运行`SpriteBatcherTest`会在 Hero、Droid 和 Nexus One 上产生以下输出:

`Hero (1.5):
12-28 00:24:54.770: DEBUG/FPSCounter(2538): fps: 61
12-28 00:24:54.770: DEBUG/FPSCounter(2538): fps: 61
12-28 00:24:55.790: DEBUG/FPSCounter(2538): fps: 62
12-28 00:24:55.790: DEBUG/FPSCounter(2538): fps: 62

Droid (2.1.1):
12-28 00:35:48.242: DEBUG/FPSCounter(1681): fps: 61
12-28 00:35:49.258: DEBUG/FPSCounter(1681): fps: 62
12-28 00:35:50.258: DEBUG/FPSCounter(1681): fps: 60
12-28 00:35:51.266: DEBUG/FPSCounter(1681): fps: 59

Nexus One (2.2.1):
12-28 00:27:39.642: DEBUG/FPSCounter(1006): fps: 61
12-28 00:27:40.652: DEBUG/FPSCounter(1006): fps: 61
12-28 00:27:41.662: DEBUG/FPSCounter(1006): fps: 61
12-28 00:27:42.662: DEBUG/FPSCounter(1006): fps: 61`

是的——我知道你复查过了——这不是打印错误。英雄现在真的达到 60 FPS 了。一个由五行代码组成的变通方法将您的性能提高了 50%。这个机器人也从这次修复中受益匪浅。

该问题在最新版本的 Android 中得到修复。但是，并非所有设备都会收到最新版本，因此您应该保留此变通方法以保持向后兼容性。

**注意:**还有一种更快的解决方法。它涉及一个自定义的 JNI 方法，该方法在本机代码中进行内存移动。你可以在网上搜索“Android 游戏开发维基”找到它。大多数情况下，您可以使用这种方法，而不是纯粹的 Java 变通方法。然而，包含 JNI 方法有点复杂，这就是为什么在这里描述纯 Java 解决方法的原因。

### 精灵动画

如果你玩过 2D 电子游戏，你就会知道你还缺少一个重要的部分:精灵动画。动画由所谓的*关键帧*组成，产生运动的错觉。[图 8–25](#fig_8_25)展示了一个由阿里·费尔德曼制作的漂亮的动画精灵(他的免版税精灵的一部分)。

![images](img/0825.jpg)

**图 8–25。** *行走的穴居人，作者阿里·费尔德曼*

图像大小为 256×64 像素，每个关键帧为 64×64 像素。要制作动画，只需使用第一个关键帧绘制一段时间(比如 0.25 秒)的精灵，然后切换到下一个关键帧，依此类推。当你到达最后一帧时，你有两个选择:你可以停留在最后一个关键帧或从头开始(并执行所谓的*循环动画*)。

你可以用你的`TextureRegion`和`SpriteBatcher`类很容易地做到这一点。通常，你不仅有一个单独的动画，就像[图 8–25](#fig_8_25)中的那个，而且在一个单独的地图集中有更多的动画。除了行走动画，你可以有一个跳跃动画，一个攻击动画，等等。对于每个动画，您需要知道帧持续时间，它告诉您在切换到下一帧之前，动画的单个关键帧要保持使用多长时间。

#### 动画课

由此，您可以定义一个`Animation`类的需求，该类存储单个动画的数据，例如[Figure 8–25](#fig_8_25)中的行走动画:

*   一个`Animation`保存了许多`TextureRegion`，它们存储了每个关键帧在纹理图谱中的位置。`TextureRegion`的顺序与播放动画的顺序相同。
*   `Animation`还存储帧持续时间，在切换到下一帧之前必须经过该时间。
*   `Animation`应该为您提供一个方法，您可以将处于`Animation`所代表的状态的时间传递给该方法(例如，向左走)，该方法将返回适当的`TextureRegion`。该方法应考虑当到达终点时，您是希望`Animation`循环还是停留在最后一帧。

最后一点很重要，因为它允许您存储一个单独的`Animation`实例，供您的世界中的多个对象使用。一个对象只是跟踪它的当前状态(即，它是在行走、射击还是跳跃，以及它在该状态下已经多长时间)。当你渲染这个对象时，使用状态来选择你想要回放的动画，使用状态时间从`Animation`中获得正确的`TextureRegion`。[清单 8–19](#list_8_19)显示了您的新`Animation`类的代码。

**清单 8–19。**Animation.java*一个简单的动画类*

`**package** com.badlogic.androidgames.framework.gl;

**public** **class** Animation {
    **public** **static** **final** **int** *ANIMATION_LOOPING* = 0;
    **public** **static** **final** **int** *ANIMATION_NONLOOPING* = 1;

    **final** TextureRegion[] keyFrames;
    **final** **float** frameDuration;

    **public** Animation(**float** frameDuration, TextureRegion … keyFrames) {
        **this**.frameDuration = frameDuration;
        **this**.keyFrames = keyFrames;
    }

    **public** TextureRegion getKeyFrame(**float** stateTime, **int** mode) {
        **int** frameNumber = (**int**)(stateTime / frameDuration);

        **if**(mode == *ANIMATION_NONLOOPING*) {
            frameNumber = Math.*min*(keyFrames.length-1, frameNumber);
        } **else** {
            frameNumber = frameNumber % keyFrames.length;
        }
        **return** keyFrames[frameNumber];
    }
}`

首先，定义两个与`getKeyFrame()`方法一起使用的常数。第一个命令说动画应该循环播放，第二个命令说它应该在最后一帧停止。

接下来，定义两个成员:一个保存`TextureRegion`的数组和一个存储帧持续时间的浮点数。

您将帧持续时间和保存关键帧的`TextureRegion`传递给构造函数，它只是存储它们。您可以创建一个`keyFrames`数组的防御性副本，但是这会分配一个新对象，这会让垃圾收集器有点抓狂。

有趣的部分是`getKeyFrame()`方法。你传入对象处于动画所表现的状态的时间，以及模式，或者是`Animation.ANIMATION_LOOPING`或者是`Animation.NON_LOOPING`。根据`stateTime`计算给定状态下已经播放了多少帧。如果动画不应该循环，只需将`frameNumber`夹到`TextureRegion`数组中的最后一个元素。否则，取模数，它将自动创建您想要的循环效果(例如，4 % 3 = 1)。剩下的就是返回正确的`TextureRegion`。

#### 一个例子

让我们创建一个名为`AnimationTest,`的示例，并创建一个名为`AnimationScreen`的相应屏幕。一如既往，只讨论屏幕本身。

你要渲染一些穴居人，都往左边走。你的世界将与你的视见体大小相同，视见体的大小为 4.8×3.2 米(这是任意的；你可以用任何尺寸。)穴居人是一个尺寸为 1×1 米的`DynamicGameObject`，你将从`DynamicGameObject`派生出一个名为`Caveman`的新类，它将存储一个额外的成员来记录穴居人行走了多长时间。每个穴居人将以 0.5 米/秒的速度移动，或者向左，或者向右。在`Caveman`类中添加一个`update()`方法，根据时间差和速度更新穴居人的位置。如果一个穴居人到达了世界的左边或右边，把他设定到世界的另一边。使用图 8–25 中的图像，并相应地创建`TextureRegion` s 和`Animation`实例。对于渲染，使用一个`Camera2D`实例和一个`SpriteBatcher`，因为它们很花哨。[清单 8–20](#list_8_20)显示了`Caveman`类的代码。

**清单 8–20。** *摘自 AnimationTest，展示内心的穴居人阶层。*

`**static final float** *WORLD_WIDTH* = 4.8f;
**static final float** *WORLD_HEIGHT* = 3.2f;

**static** **class** Caveman **extends** DynamicGameObject {
    **public** **float** walkingTime = 0;

    **public** Caveman(**float** x, **float** y, **float** width, **float** height) {
        **super**(x, y, width, height);
        **this**.position.set((**float**)Math.*random*() * *WORLD_WIDTH*,
                          (**float**)Math.*random*() * *WORLD_HEIGHT*);
        **this**.velocity.set(Math.*random*() > 0.5f?-0.5f:0.5f, 0);
        **this**.walkingTime = (**float**)Math.*random*() * 10;
    }

    **public** **void** update(**float** deltaTime) {
        position.add(velocity.x * deltaTime, velocity.y * deltaTime);
        **if**(position.x < 0) position.x = *WORLD_WIDTH*;
        **if**(position.x > *WORLD_WIDTH*) position.x = 0;
        walkingTime += deltaTime;
    }
}`

两个常量`WORLD_WIDTH`和`WORLD_HEIGHT`是封闭`AnimationTest`类的一部分，由内部类使用。你的世界大小为 4.8×3.2 m。

接下来是内部的`Caveman`类，它扩展了`DynamicGameObject`，因为你将基于速度移动穴居人。您定义了一个额外的成员来记录穴居人行走了多长时间。在构造器中，把穴居人放在一个随机的位置，让他向左或向右走。将`walkingTime`成员初始化为 0 到 10 之间的一个数字；这样你的穴居人就不会同步行走。

`update()`方法基于穴居人的速度和时间增量来推进穴居人。如果他离开了这个世界，把他重置到左边或者右边。给`walkingTime`加上 delta 时间来记录他走了多长时间。

[清单 8–21](#list_8_21)展示了`AnimationScreen`类。

**清单 8–21。**T3】摘自 animation test . Java:animation screen 类

`**class** AnimationScreen **extends** Screen {
    **static final** **int** NUM_CAVEMEN = 10;
    GLGraphics glGraphics;
    Caveman[] cavemen;
    SpriteBatcher batcher;
    Camera2D camera;
    Texture texture;
    Animation walkAnim;`

您的 screen 类有一些常见的成员。您有一个`GLGraphics`实例，一个`Caveman`数组，一个`SpriteBatcher`，一个`Camera2D`，一个包含行走关键帧的`Texture`，以及一个`Animation`实例。

`    **public** AnimationScreen(Game game) {
        **super**(game);
        glGraphics = ((GLGame)game).getGLGraphics();
        cavemen = **new** Caveman[*NUM_CAVEMEN*];
        **for**(**int** i = 0; i < *NUM_CAVEMEN*; i++) {
            cavemen[i] = **new** Caveman((**float**)Math.*random*(), (**float**)Math.*random*(), 1, 1);
        }
        batcher = **new** SpriteBatcher(glGraphics, *NUM_CAVEMEN*);
        camera = **new** Camera2D(glGraphics, *WORLD_WIDTH*, *WORLD_HEIGHT*);
    }`

在构造函数中，您创建了`Caveman`实例，以及`SpriteBatcher`和`Camera2D`。

`@Override` `    **public** **void** resume() {
        texture = **new** Texture(((GLGame)game), "walkanim.png");
        walkAnim = **new** Animation( 0.2f,
                                  **new** TextureRegion(texture, 0, 0, 64, 64),
                                  **new** TextureRegion(texture, 64, 0, 64, 64),
                                  **new** TextureRegion(texture, 128, 0, 64, 64),
                                  **new** TextureRegion(texture, 192, 0, 64, 64));
    }`

在`resume()`方法中，你从资产文件`walkanim.png`中加载包含动画关键帧的纹理贴图集，这与[图 8–25](#fig_8_25)中看到的相同。之后，创建`Animation`实例，将帧持续时间设置为 0.2 秒，并为纹理贴图集中的每个关键帧传入一个`TextureRegion`。

`    @Override
    **public** **void** update(**float** deltaTime) {
        **int** len = cavemen.length;
        **for**(**int** i = 0; i < len; i++) {
            cavemen[i].update(deltaTime);
        }
    }`

`update()`方法只是遍历所有的`Caveman`实例，并用当前的增量时间调用它们的`Caveman.update()`方法。这将使穴居人移动并更新他们的行走时间。

`    @Override
    **public** **void** present(**float** deltaTime) {
        GL10 gl = glGraphics.getGL();
        gl.glClear(GL10.*GL_COLOR_BUFFER_BIT*);
        camera.setViewportAndMatrices();

        gl.glEnable(GL10.*GL_BLEND*);
        gl.glBlendFunc(GL10.*GL_SRC_ALPHA*, GL10.*GL_ONE_MINUS_SRC_ALPHA*);
        gl.glEnable(GL10.*GL_TEXTURE_2D*);

        batcher.beginBatch(texture);
        **int** len = cavemen.length;
        **for**(**int** i = 0; i < len; i++) {
            Caveman caveman = cavemen[i];
            TextureRegion keyFrame = walkAnim.getKeyFrame(caveman.walkingTime, Animation.*ANIMATION_LOOPING*);
            batcher.drawSprite(caveman.position.x, caveman.position.y,
caveman.velocity.x < 0?1:-1, 1, keyFrame);
        }
        batcher.endBatch();
    }

    @Override
    **public** **void** pause() {
    }      

    @Override
    **public** **void** dispose() {
    }
}`

最后，你有了`present()`方法。首先清除屏幕，并通过相机设置视口和投影矩阵。接下来，启用混合和纹理映射，并设置混合功能。通过告诉 sprite 批处理程序您想要使用动画纹理贴图集开始一个新的批处理来开始渲染。接下来，循环遍历所有的穴居人并渲染他们。对于每个穴居人，首先根据穴居人的行走时间从`Animation`实例中获取正确的关键帧。您指定动画应该循环播放。然后你用正确的纹理区域绘制穴居人的位置。

但是你用这里的`width`参数做什么呢？请记住，您的动画纹理仅包含“向左走”动画的关键帧。如果穴居人向右走，你需要水平翻转纹理，这可以通过指定负宽度来实现。如果你不信任我们，回到`SpriteBatcher`代码，检查这是否有效。您实际上是通过指定负宽度来翻转 sprite 的矩形。通过指定负的高度，您也可以在垂直方向上做同样的事情。

[图 8–26](#fig_8_26)显示了行走的穴居人。

![images](img/0826.jpg)

**图 8–26。** *穴居人行走*

这就是用 OpenGL ES 制作一个好的 2D 游戏所需要知道的一切。请注意，您仍然将游戏逻辑和表示彼此分离。穴居人不需要知道他正在被渲染。因此，他没有保留任何与渲染相关的成员，比如一个`Animation`实例或一个`Texture`。你所需要做的就是记录穴居人的状态，以及他在这种状态下呆了多久。连同他的位置和大小，你可以通过使用你的小助手类轻松地渲染他。

### 总结

你现在应该已经准备好创建任何你想要的 2D 游戏了。您已经学习了向量以及如何使用它们，从而产生了一个漂亮的、可重用的`Vector2`类。你还研究了创造弹道炮弹等东西的基础物理学。碰撞检测也是大多数游戏的一个重要部分，你现在应该知道如何通过`SpatialHashGrid`正确有效地进行碰撞检测。通过创建跟踪对象状态和形状的`GameObject`和`DynamicGameObject`类，您探索了一种保持游戏逻辑和对象与渲染分离的方法。你提到了通过 OpenGL ES 实现 2D 相机的概念是多么容易，所有这些都基于一个叫做`glOrthof()`的方法。您了解了纹理贴图集，为什么需要它们，以及如何使用它们。这是通过引入纹理区域、精灵以及如何通过`SpriteBatcher`有效地渲染它们而扩展的。最后，您研究了 sprite 动画，它实现起来非常简单。

值得注意的是，本章涵盖的所有主题，包括宽相位和窄相位碰撞检测、物理模拟、运动积分和不同形状的边界，都在许多开源库中实现，如 Box2D、Chipmunk Physics、Bullet Physics 等。所有这些库最初都是用 C 或 C++开发的，但有一些是 Android 包装器或 Java 实现，这使得它们在你计划游戏时值得一试。

在下一章，你将使用新工具创建一个新游戏。你会惊讶它是多么容易。